<directory>terra-client-python</directory>

<source-tree>
terra-client-python
├── README.md
├── pyproject.toml
├── reference.md
├── requirements.txt
├── src
│   └── terra
│       ├── __init__.py
│       ├── activity
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── activity_fetch_request_start_date.py
│       │       ├── activity_fetch_response.py
│       │       ├── activity_fetch_response_data.py
│       │       └── activity_write_response.py
│       ├── athlete
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       └── athlete_fetch_response.py
│       ├── authentication
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── authentication_authenticate_user_response.py
│       │       ├── authentication_authenticate_user_response_status.py
│       │       ├── authentication_deauthenticate_user_response.py
│       │       ├── authentication_deauthenticate_user_response_status.py
│       │       ├── authentication_generate_auth_token_response.py
│       │       ├── authentication_generate_widget_session_response.py
│       │       └── authentication_generate_widget_session_response_status.py
│       ├── body
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── body_delete_response.py
│       │       ├── body_delete_response_processed_data_item.py
│       │       ├── body_fetch_request_start_date.py
│       │       ├── body_fetch_response.py
│       │       ├── body_fetch_response_data.py
│       │       └── body_write_response.py
│       ├── client.py
│       ├── core
│       │   ├── __init__.py
│       │   ├── api_error.py
│       │   ├── client_wrapper.py
│       │   ├── datetime_utils.py
│       │   ├── file.py
│       │   ├── force_multipart.py
│       │   ├── http_client.py
│       │   ├── http_response.py
│       │   ├── jsonable_encoder.py
│       │   ├── pydantic_utilities.py
│       │   ├── query_encoder.py
│       │   ├── remove_none_from_dict.py
│       │   ├── request_options.py
│       │   ├── serialization.py
│       │   └── unchecked_base_model.py
│       ├── daily
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── daily_fetch_request_start_date.py
│       │       ├── daily_fetch_response.py
│       │       └── daily_fetch_response_data.py
│       ├── environment.py
│       ├── errors
│       │   ├── __init__.py
│       │   ├── bad_request_error.py
│       │   ├── not_found_error.py
│       │   └── unauthorized_error.py
│       ├── integrations
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── integrations_fetch_response.py
│       │       └── integrations_fetch_response_status.py
│       ├── menstruation
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── menstruation_fetch_request_start_date.py
│       │       ├── menstruation_fetch_response.py
│       │       └── menstruation_fetch_response_data.py
│       ├── nutrition
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── nutrition_delete_response.py
│       │       ├── nutrition_delete_response_processed_data_item.py
│       │       ├── nutrition_fetch_request_start_date.py
│       │       ├── nutrition_fetch_response.py
│       │       ├── nutrition_fetch_response_data.py
│       │       └── nutrition_write_response.py
│       ├── plannedworkout
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── planned_workout_delete_response.py
│       │       ├── planned_workout_delete_response_processed_data_item.py
│       │       ├── planned_workout_fetch_request_start_date.py
│       │       ├── planned_workout_fetch_response.py
│       │       ├── planned_workout_fetch_response_data.py
│       │       └── planned_workout_write_response.py
│       ├── py.typed
│       ├── sleep
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── sleep_fetch_request_start_date.py
│       │       ├── sleep_fetch_response.py
│       │       └── sleep_fetch_response_data.py
│       ├── types
│       │   ├── __init__.py
│       │   ├── a_fib_classification_sample.py
│       │   ├── access_revoked_event.py
│       │   ├── access_revoked_webhook.py
│       │   ├── active_durations_data.py
│       │   ├── activity.py
│       │   ├── activity_event.py
│       │   ├── activity_level.py
│       │   ├── activity_level_sample.py
│       │   ├── activity_metadata.py
│       │   ├── activity_webhook.py
│       │   ├── asleep_durations.py
│       │   ├── athlete.py
│       │   ├── athlete_collection.py
│       │   ├── athlete_event.py
│       │   ├── athlete_webhook.py
│       │   ├── auth_error_event.py
│       │   ├── auth_event.py
│       │   ├── auth_success_event.py
│       │   ├── authentication_failed_webhook.py
│       │   ├── awake_durations.py
│       │   ├── bad_request_error_body.py
│       │   ├── bad_request_error_body_status.py
│       │   ├── blood_pressure_data.py
│       │   ├── blood_pressure_sample.py
│       │   ├── body.py
│       │   ├── body_battery_sample.py
│       │   ├── body_event.py
│       │   ├── body_metadata.py
│       │   ├── body_webhook.py
│       │   ├── breath.py
│       │   ├── breath_sample.py
│       │   ├── breaths_data.py
│       │   ├── cadence_planned_workout_step_target.py
│       │   ├── cadence_planned_workout_step_target_target_type.py
│       │   ├── cadence_sample.py
│       │   ├── calorie_sample.py
│       │   ├── calories_data.py
│       │   ├── calories_planned_workout_step_duration.py
│       │   ├── calories_planned_workout_step_duration_duration_type.py
│       │   ├── cardio_planned_workout_step.py
│       │   ├── cardio_planned_workout_step_exercise_category.py
│       │   ├── connection_error_event.py
│       │   ├── connection_error_webhook.py
│       │   ├── cycling_planned_workout_step.py
│       │   ├── daily.py
│       │   ├── daily_data_enrichment.py
│       │   ├── daily_distance_data.py
│       │   ├── daily_event.py
│       │   ├── daily_metadata.py
│       │   ├── daily_pattern_sample.py
│       │   ├── daily_webhook.py
│       │   ├── data_contributor.py
│       │   ├── data_enrichment.py
│       │   ├── data_processing_webhook.py
│       │   ├── data_sent_to_webhook.py
│       │   ├── deauth_event.py
│       │   ├── device_data.py
│       │   ├── device_data_type.py
│       │   ├── distance_data.py
│       │   ├── distance_data_detailed.py
│       │   ├── distance_data_summary.py
│       │   ├── distance_planned_workout_step_duration.py
│       │   ├── distance_planned_workout_step_duration_duration_type.py
│       │   ├── distance_sample.py
│       │   ├── drink_sample.py
│       │   ├── ecg_reading.py
│       │   ├── elevation_data.py
│       │   ├── elevation_sample.py
│       │   ├── energy_data.py
│       │   ├── fixed_rest_planned_workout_step_duration.py
│       │   ├── fixed_rest_planned_workout_step_duration_duration_type.py
│       │   ├── floors_climbed_sample.py
│       │   ├── glucose_data.py
│       │   ├── glucose_data_sample.py
│       │   ├── google_no_data_source_webhook.py
│       │   ├── google_no_datasource_event.py
│       │   ├── had.py
│       │   ├── health_check_webhook.py
│       │   ├── healthcheck_event.py
│       │   ├── heart_data.py
│       │   ├── heart_rate_context.py
│       │   ├── heart_rate_data.py
│       │   ├── heart_rate_data_detailed.py
│       │   ├── heart_rate_data_sample.py
│       │   ├── heart_rate_data_summary.py
│       │   ├── heart_rate_variability_data_sample_rmssd.py
│       │   ├── heart_rate_variability_data_sample_sdnn.py
│       │   ├── heart_rate_zone_data.py
│       │   ├── high.py
│       │   ├── hr_above_planned_workout_step_duration.py
│       │   ├── hr_above_planned_workout_step_duration_duration_type.py
│       │   ├── hr_below_planned_workout_step_duration.py
│       │   ├── hr_below_planned_workout_step_duration_duration_type.py
│       │   ├── hr_planned_workout_step_target.py
│       │   ├── hr_planned_workout_step_target_target_type.py
│       │   ├── hurling.py
│       │   ├── hydration_data.py
│       │   ├── hydration_measurement_sample.py
│       │   ├── if_planned_workout_step_target.py
│       │   ├── if_planned_workout_step_target_target_type.py
│       │   ├── inconclusive.py
│       │   ├── indeterminate.py
│       │   ├── integration_provider.py
│       │   ├── integration_provider_types.py
│       │   ├── integrations_response.py
│       │   ├── ketone_data.py
│       │   ├── ketone_sample.py
│       │   ├── lap_data.py
│       │   ├── lap_sample.py
│       │   ├── large_request_processing_event.py
│       │   ├── large_request_processing_response.py
│       │   ├── large_request_sending_event.py
│       │   ├── large_request_sending_webhook.py
│       │   ├── low.py
│       │   ├── meal.py
│       │   ├── measurement_data_sample.py
│       │   ├── measurements_data.py
│       │   ├── menstrual_phase.py
│       │   ├── menstruation.py
│       │   ├── menstruation_data.py
│       │   ├── menstruation_event.py
│       │   ├── menstruation_flow_sample.py
│       │   ├── menstruation_metadata.py
│       │   ├── menstruation_webhook.py
│       │   ├── met_data.py
│       │   ├── met_sample.py
│       │   ├── movement_data.py
│       │   ├── muscle.py
│       │   ├── no_data_returned.py
│       │   ├── no_data_returned_status.py
│       │   ├── not_found_error_body.py
│       │   ├── not_found_error_body_status.py
│       │   ├── nutrition.py
│       │   ├── nutrition_event.py
│       │   ├── nutrition_macros.py
│       │   ├── nutrition_metadata.py
│       │   ├── nutrition_micros.py
│       │   ├── nutrition_quantity.py
│       │   ├── nutrition_summary.py
│       │   ├── nutrition_units.py
│       │   ├── nutrition_webhook.py
│       │   ├── other.py
│       │   ├── other_device_data.py
│       │   ├── other_sleep_durations.py
│       │   ├── oxygen_data.py
│       │   ├── oxygen_saturation_data.py
│       │   ├── oxygen_saturation_sample.py
│       │   ├── pace_planned_workout_step_target.py
│       │   ├── pace_planned_workout_step_target_target_type.py
│       │   ├── permission_change_event.py
│       │   ├── permission_change_webhook.py
│       │   ├── pilates_planned_workout_step.py
│       │   ├── planned_workout.py
│       │   ├── planned_workout_metadata.py
│       │   ├── planned_workout_metadata_type.py
│       │   ├── planned_workout_repeat_step.py
│       │   ├── planned_workout_step.py
│       │   ├── planned_workout_step_duration.py
│       │   ├── planned_workout_step_duration_duration_type.py
│       │   ├── planned_workout_step_durations.py
│       │   ├── planned_workout_step_intensity.py
│       │   ├── planned_workout_step_target.py
│       │   ├── planned_workout_step_target_target_type.py
│       │   ├── planned_workout_step_targets.py
│       │   ├── planned_workout_steps.py
│       │   ├── polyline_map_data.py
│       │   ├── position_data.py
│       │   ├── position_sample.py
│       │   ├── power_above_planned_workout_step_duration.py
│       │   ├── power_above_planned_workout_step_duration_duration_type.py
│       │   ├── power_below_planned_workout_step_duration.py
│       │   ├── power_below_planned_workout_step_duration_duration_type.py
│       │   ├── power_data.py
│       │   ├── power_planned_workout_step_target.py
│       │   ├── power_planned_workout_step_target_target_type.py
│       │   ├── power_sample.py
│       │   ├── processing_event.py
│       │   ├── pulse_velocity_sample.py
│       │   ├── rate_limit_hit_event.py
│       │   ├── rate_limit_hit_webhook.py
│       │   ├── rate_limit_request_processing.py
│       │   ├── raw_ecg_sample.py
│       │   ├── readiness_data.py
│       │   ├── recovery_level.py
│       │   ├── repetition_planned_workout_step_target.py
│       │   ├── repetition_planned_workout_step_target_target_type.py
│       │   ├── reps_planned_workout_step_duration.py
│       │   ├── reps_planned_workout_step_duration_duration_type.py
│       │   ├── request_processing.py
│       │   ├── respiration_data.py
│       │   ├── rr_interval_sample.py
│       │   ├── running_planned_workout_step.py
│       │   ├── s_3_payload_event.py
│       │   ├── s_3_upload_webhook.py
│       │   ├── scores_data.py
│       │   ├── sleep.py
│       │   ├── sleep_data_enrichment.py
│       │   ├── sleep_durations_data.py
│       │   ├── sleep_event.py
│       │   ├── sleep_hypnogram_sample.py
│       │   ├── sleep_level.py
│       │   ├── sleep_metadata.py
│       │   ├── sleep_scores.py
│       │   ├── sleep_temperature_data.py
│       │   ├── sleep_webhook.py
│       │   ├── snack.py
│       │   ├── snoring_data.py
│       │   ├── snoring_sample.py
│       │   ├── speed_planned_workout_step_target.py
│       │   ├── speed_planned_workout_step_target_target_type.py
│       │   ├── speed_sample.py
│       │   ├── step_sample.py
│       │   ├── steps_planned_workout_step_duration.py
│       │   ├── steps_planned_workout_step_duration_duration_type.py
│       │   ├── strain_data.py
│       │   ├── strength_planned_workout_step.py
│       │   ├── strength_planned_workout_step_exercise_category.py
│       │   ├── stress_data.py
│       │   ├── stress_sample.py
│       │   ├── stroke_type.py
│       │   ├── swim_stroke_planned_workout_step_target.py
│       │   ├── swim_stroke_planned_workout_step_target_target_type.py
│       │   ├── swimming_data.py
│       │   ├── swimming_planned_workout_step.py
│       │   ├── swimming_planned_workout_step_equipment_type.py
│       │   ├── swimming_planned_workout_step_stroke_type.py
│       │   ├── tag_data.py
│       │   ├── tag_entry.py
│       │   ├── temperature_data.py
│       │   ├── temperature_sample.py
│       │   ├── terra_user.py
│       │   ├── time_planned_workout_step_duration.py
│       │   ├── time_planned_workout_step_duration_duration_type.py
│       │   ├── timestamp_localization.py
│       │   ├── torque_sample.py
│       │   ├── trend_arrow.py
│       │   ├── tss_data.py
│       │   ├── tss_planned_workout_step_target.py
│       │   ├── tss_planned_workout_step_target_target_type.py
│       │   ├── tss_sample.py
│       │   ├── unauthorized_error_body.py
│       │   ├── unauthorized_error_body_status.py
│       │   ├── upload_type.py
│       │   ├── user.py
│       │   ├── user_auth_webhook.py
│       │   ├── user_auth_webhook_error.py
│       │   ├── user_auth_webhook_payload.py
│       │   ├── user_deauth_webhook.py
│       │   ├── user_reauth_event.py
│       │   ├── user_reauth_webhook.py
│       │   ├── vo_2_max_sample.py
│       │   ├── webhook_event.py
│       │   ├── webhook_event_type.py
│       │   ├── webhook_events.py
│       │   ├── work_data.py
│       │   └── yoga_planned_workout_step.py
│       ├── user
│       │   ├── __init__.py
│       │   ├── client.py
│       │   ├── raw_client.py
│       │   └── types
│       │       ├── __init__.py
│       │       ├── user_get_all_user_i_ds_response.py
│       │       ├── user_get_all_user_i_ds_response_data.py
│       │       ├── user_get_all_user_i_ds_response_data_data.py
│       │       ├── user_get_all_user_i_ds_response_users.py
│       │       ├── user_get_info_for_user_id_response.py
│       │       ├── user_get_info_for_user_id_response_is_authenticated.py
│       │       ├── user_get_info_for_user_id_response_is_authenticated_status.py
│       │       ├── user_modify_user_response.py
│       │       └── user_modify_user_response_status.py
│       └── version.py
├── terra
│   ├── api
│   └── models
│       └── v2
└── tests
    ├── custom
    │   └── test_client.py
    └── utils
        ├── __init__.py
        ├── assets
        │   └── models
        │       ├── __init__.py
        │       ├── circle.py
        │       ├── color.py
        │       ├── object_with_defaults.py
        │       ├── object_with_optional_field.py
        │       ├── shape.py
        │       ├── square.py
        │       └── undiscriminated_shape.py
        ├── test_http_client.py
        ├── test_query_encoding.py
        └── test_serialization.py

</source-tree>

<files>
<file path="terra-client-python/README.md">
```md
# Terra Python Library

[![fern shield](https://img.shields.io/badge/%F0%9F%8C%BF-Built%20with%20Fern-brightgreen)](https://buildwithfern.com?utm_source=github&utm_medium=github&utm_campaign=readme&utm_source=https%3A%2F%2Fgithub.com%2Ftryterra%2Fterra-client-python)
[![pypi](https://img.shields.io/pypi/v/terra-python)](https://pypi.python.org/pypi/terra-python)

The Terra Python library provides convenient access to the Terra API from Python.

## Documentation

API reference documentation is available [here](https://docs.tryterra.co/reference).

## Installation

```sh
pip install terra-python
```

## Reference

A full reference for this library is available [here](https://github.com/tryterra/terra-client-python/blob/HEAD/./reference.md).

## Usage

Instantiate and use the client with the following:

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.integrations.fetch()
```

## Async Client

The SDK also exports an `async` client so that you can make non-blocking calls to our API.

```python
import asyncio

from terra import AsyncTerra

client = AsyncTerra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)


async def main() -> None:
    await client.integrations.fetch()


asyncio.run(main())
```

## Exception Handling

When the API returns a non-success status code (4xx or 5xx response), a subclass of the following error
will be thrown.

```python
from terra.core.api_error import ApiError

try:
    client.integrations.fetch(...)
except ApiError as e:
    print(e.status_code)
    print(e.body)
```

## Advanced

### Access Raw Response Data

The SDK provides access to raw response data, including headers, through the `.with_raw_response` property.
The `.with_raw_response` property returns a "raw" client that can be used to access the `.headers` and `.data` attributes.

```python
from terra import Terra

client = Terra(
    ...,
)
response = client.integrations.with_raw_response.fetch(...)
print(response.headers)  # access the response headers
print(response.data)  # access the underlying object
```

### Retries

The SDK is instrumented with automatic retries with exponential backoff. A request will be retried as long
as the request is deemed retryable and the number of retry attempts has not grown larger than the configured
retry limit (default: 2).

A request is deemed retryable when any of the following HTTP status codes is returned:

- [408](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408) (Timeout)
- [429](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429) (Too Many Requests)
- [5XX](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500) (Internal Server Errors)

Use the `max_retries` request option to configure this behavior.

```python
client.integrations.fetch(..., request_options={
    "max_retries": 1
})
```

### Timeouts

The SDK defaults to a 60 second timeout. You can configure this with a timeout option at the client or request level.

```python

from terra import Terra

client = Terra(
    ...,
    timeout=20.0,
)


# Override timeout for a specific method
client.integrations.fetch(..., request_options={
    "timeout_in_seconds": 1
})
```

### Custom Client

You can override the `httpx` client to customize it for your use-case. Some common use-cases include support for proxies
and transports.

```python
import httpx
from terra import Terra

client = Terra(
    ...,
    httpx_client=httpx.Client(
        proxies="http://my.test.proxy.example.com",
        transport=httpx.HTTPTransport(local_address="0.0.0.0"),
    ),
)
```

## Contributing

While we value open-source contributions to this SDK, this library is generated programmatically.
Additions made directly to this library would have to be moved over to our generation code,
otherwise they would be overwritten upon the next generated release. Feel free to open a PR as
a proof of concept, but know that we will not be able to merge it as-is. We suggest opening
an issue first to discuss with us!

On the other hand, contributions to the README are always very welcome!

```
</file>
<file path="terra-client-python/pyproject.toml">
```toml
[project]
name = "terra-python"

[tool.poetry]
name = "terra-python"
version = "1.0.5"
description = ""
readme = "README.md"
authors = []
keywords = []

classifiers = [
    "Intended Audience :: Developers",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Operating System :: OS Independent",
    "Operating System :: POSIX",
    "Operating System :: MacOS",
    "Operating System :: POSIX :: Linux",
    "Operating System :: Microsoft :: Windows",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Typing :: Typed"
]
packages = [
    { include = "terra", from = "src"}
]

[project.urls]
Repository = 'https://github.com/tryterra/terra-client-python'

[tool.poetry.dependencies]
python = "^3.8"
httpx = ">=0.21.2"
pydantic = ">= 1.9.2"
pydantic-core = "^2.18.2"
typing_extensions = ">= 4.0.0"

[tool.poetry.group.dev.dependencies]
mypy = "==1.13.0"
pytest = "^7.4.0"
pytest-asyncio = "^0.23.5"
python-dateutil = "^2.9.0"
types-python-dateutil = "^2.9.0.20240316"
ruff = "==0.11.5"

[tool.pytest.ini_options]
testpaths = [ "tests" ]
asyncio_mode = "auto"

[tool.mypy]
plugins = ["pydantic.mypy"]

[tool.ruff]
line-length = 120

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "F",  # pyflakes
    "I",  # isort
]
ignore = [
    "E402",  # Module level import not at top of file
    "E501",  # Line too long
    "E711",  # Comparison to `None` should be `cond is not None`
    "E712",  # Avoid equality comparisons to `True`; use `if ...:` checks
    "E721",  # Use `is` and `is not` for type comparisons, or `isinstance()` for insinstance checks
    "E722",  # Do not use bare `except`
    "E731",  # Do not assign a `lambda` expression, use a `def`
    "F821",  # Undefined name
    "F841"   # Local variable ... is assigned to but never used
]

[tool.ruff.lint.isort]
section-order = ["future", "standard-library", "third-party", "first-party"]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

```
</file>
<file path="terra-client-python/reference.md">
```md
# Reference
## Authentication
<details><summary><code>client.authentication.<a href="src/terra/authentication/client.py">authenticateuser</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Creates a login link that allows end users to connect their fitness tracking account
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.authentication.authenticateuser(
    resource="FITBIT",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**resource:** `str` — Provider resource identifier (e.g., 'FITBIT', 'GARMIN', 'OURA'). See "Get detailed list of integrations" for available providers
    
</dd>
</dl>

<dl>
<dd>

**language:** `typing.Optional[str]` 
    
</dd>
</dl>

<dl>
<dd>

**reference_id:** `typing.Optional[str]` 
    
</dd>
</dl>

<dl>
<dd>

**auth_success_redirect_url:** `typing.Optional[str]` 
    
</dd>
</dl>

<dl>
<dd>

**auth_failure_redirect_url:** `typing.Optional[str]` 
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.authentication.<a href="src/terra/authentication/client.py">generatewidgetsession</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.authentication.generatewidgetsession()

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**providers:** `typing.Optional[str]` — Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard
    
</dd>
</dl>

<dl>
<dd>

**language:** `typing.Optional[str]` — Display language of the widget
    
</dd>
</dl>

<dl>
<dd>

**reference_id:** `typing.Optional[str]` — Identifier of the end user on your system, such as a user ID or email associated with them
    
</dd>
</dl>

<dl>
<dd>

**auth_success_redirect_url:** `typing.Optional[str]` — URL the user is redirected to upon successful authentication
    
</dd>
</dl>

<dl>
<dd>

**auth_failure_redirect_url:** `typing.Optional[str]` — URL the user is redirected to upon unsuccessful authentication
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.authentication.<a href="src/terra/authentication/client.py">deauthenticateuser</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Deletes all records of the user on Terra's end, revoking Terra's access to their data
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.authentication.deauthenticateuser(
    user_id="user_id",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to deauthenticate and remove from Terra system
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.authentication.<a href="src/terra/authentication/client.py">generateauthtoken</a>()</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.authentication.generateauthtoken()

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## User
<details><summary><code>client.user.<a href="src/terra/user/client.py">modifyuser</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Update a Terra user's reference_id or active status
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.user.modifyuser(
    user_id="user_id",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID to update
    
</dd>
</dl>

<dl>
<dd>

**reference_id:** `typing.Optional[str]` — Identifier on your system to associate with this user
    
</dd>
</dl>

<dl>
<dd>

**active:** `typing.Optional[bool]` — Whether the user should remain active
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.user.<a href="src/terra/user/client.py">getinfoforuserid</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.user.getinfoforuserid()

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `typing.Optional[str]` — user ID to query for
    
</dd>
</dl>

<dl>
<dd>

**reference_id:** `typing.Optional[str]` — reference ID to query for
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.user.<a href="src/terra/user/client.py">getalluserids</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.user.getalluserids()

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**page:** `typing.Optional[int]` — Zero-based page number. If omitted, results are not paginated.
    
</dd>
</dl>

<dl>
<dd>

**per_page:** `typing.Optional[int]` — Number of results per page (default is 500).
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.user.<a href="src/terra/user/client.py">getinfoformultipleuserids</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to query for information for multiple Terra User IDs
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.user.getinfoformultipleuserids(
    request=["string"],
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `typing.Sequence[str]` 
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Activity
<details><summary><code>client.activity.<a href="src/terra/activity/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.activity.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `ActivityFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**with_samples:** `typing.Optional[bool]` — Boolean flag specifying whether to include detailed samples in the returned payload (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.activity.<a href="src/terra/activity/client.py">write</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to post activity data to a provider. This endpoint only works for users connected via Wahoo. Returns error for other providers.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Activity, ActivityMetadata, Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.activity.write(
    data=[
        Activity(
            metadata=ActivityMetadata(
                end_time="2022-10-28T10:00:00.000000+01:00",
                start_time="1999-11-23T09:00:00.000000+02:00",
                summary_id="123e4567-e89b-12d3-a456-426614174000",
                type=1.1,
                upload_type=1.1,
            ),
        )
    ],
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**data:** `typing.Sequence[Activity]` — List of user-tracked workouts to post to data provider
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Athlete
<details><summary><code>client.athlete.<a href="src/terra/athlete/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches relevant profile info such as first & last name, birth date etc. for a given user ID
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.athlete.fetch(
    user_id="user_id",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Body
<details><summary><code>client.body.<a href="src/terra/body/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.body.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `BodyFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**with_samples:** `typing.Optional[bool]` — Boolean flag specifying whether to include detailed samples in the returned payload (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.body.<a href="src/terra/body/client.py">write</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to post body data to a provider. This endpoint only works for users connected via Google Fit. Returns error for other providers.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Body, BodyMetadata, Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.body.write(
    data=[
        Body(
            metadata=BodyMetadata(
                end_time="2022-10-28T10:00:00.000000+01:00",
                start_time="1999-11-23T09:00:00.000000+02:00",
            ),
        )
    ],
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**data:** `typing.Sequence[Body]` — Body measurement metrics to post to data provider
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.body.<a href="src/terra/body/client.py">delete</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to delete Body metrics the user has registered on their account
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.body.delete(
    user_id="user_id",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**log_ids:** `typing.Optional[typing.Sequence[str]]` — List of identifiers for body metrics entries to be deleted
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Daily
<details><summary><code>client.daily.<a href="src/terra/daily/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.daily.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `DailyFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**with_samples:** `typing.Optional[bool]` — Boolean flag specifying whether to include detailed samples in the returned payload (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Menstruation
<details><summary><code>client.menstruation.<a href="src/terra/menstruation/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.menstruation.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `MenstruationFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**with_samples:** `typing.Optional[bool]` — Boolean flag specifying whether to include detailed samples in the returned payload (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Nutrition
<details><summary><code>client.nutrition.<a href="src/terra/nutrition/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.nutrition.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `NutritionFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**with_samples:** `typing.Optional[bool]` — Boolean flag specifying whether to include detailed samples in the returned payload (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.nutrition.<a href="src/terra/nutrition/client.py">write</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to post nutrition logs to a provider. This endpoint only works for users connected via Fitbit. Returns error for other providers.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Nutrition, NutritionMetadata, Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.nutrition.write(
    data=[
        Nutrition(
            metadata=NutritionMetadata(
                end_time="2022-10-28T10:00:00.000000+01:00",
                start_time="1999-11-23T09:00:00.000000+02:00",
            ),
        )
    ],
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**data:** `typing.Sequence[Nutrition]` — Nutrition entry to post to data provider
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.nutrition.<a href="src/terra/nutrition/client.py">delete</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to delete nutrition logs the user has registered on their account
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.nutrition.delete(
    user_id="user_id",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**data:** `typing.Optional[typing.Sequence[str]]` — List of identifiers for nutrition entries to be deleted
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Sleep
<details><summary><code>client.sleep.<a href="src/terra/sleep/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.sleep.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `SleepFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**with_samples:** `typing.Optional[bool]` — Boolean flag specifying whether to include detailed samples in the returned payload (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Plannedworkout
<details><summary><code>client.plannedworkout.<a href="src/terra/plannedworkout/client.py">fetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to get workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.plannedworkout.fetch(
    user_id="user_id",
    start_date=1,
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**start_date:** `PlannedWorkoutFetchRequestStartDate` — Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**end_date:** `typing.Optional[int]` — End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)
    
</dd>
</dl>

<dl>
<dd>

**to_webhook:** `typing.Optional[bool]` — Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.plannedworkout.<a href="src/terra/plannedworkout/client.py">write</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to post workout plans users can follow on their wearable. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import PlannedWorkout, Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.plannedworkout.write(
    data=[PlannedWorkout()],
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**data:** `typing.Sequence[PlannedWorkout]` — PlannedWorkout entry to post to data provider
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.plannedworkout.<a href="src/terra/plannedworkout/client.py">delete</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Used to delete workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.plannedworkout.delete(
    user_id="user_id",
)

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**user_id:** `str` — Terra user ID (UUID format) to retrieve data for
    
</dd>
</dl>

<dl>
<dd>

**data:** `typing.Optional[typing.Sequence[str]]` — List of identifiers for planned workout entries to be deleted
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Integrations
<details><summary><code>client.integrations.<a href="src/terra/integrations/client.py">fetch</a>()</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Retrieve a list of all available provider integrations on the API.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.integrations.fetch()

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.integrations.<a href="src/terra/integrations/client.py">detailedfetch</a>(...)</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```python
from terra import Terra

client = Terra(
    dev_id="YOUR_DEV_ID",
    api_key="YOUR_API_KEY",
)
client.integrations.detailedfetch()

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**sdk:** `typing.Optional[bool]` — If `true`, allows SDK integrations to be included in the response.
    
</dd>
</dl>

<dl>
<dd>

**request_options:** `typing.Optional[RequestOptions]` — Request-specific configuration.
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>


```
</file>
<file path="terra-client-python/requirements.txt">
```txt
httpx>=0.21.2
pydantic>= 1.9.2
pydantic-core==2.18.2
typing_extensions>= 4.0.0

```
</file>
<file path="terra-client-python/src/terra/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file

from . import (
    activity,
    athlete,
    authentication,
    body,
    daily,
    integrations,
    menstruation,
    nutrition,
    plannedworkout,
    sleep,
    user,
)
from .client import AsyncTerra, Terra
from .version import __version__

__all__ = [
    "AsyncTerra",
    "Terra",
    "__version__",
    "activity",
    "athlete",
    "authentication",
    "body",
    "daily",
    "integrations",
    "menstruation",
    "nutrition",
    "plannedworkout",
    "sleep",
    "user",
]

```
</file>
<file path="terra-client-python/src/terra/activity/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/activity/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.activity import Activity
from .raw_client import AsyncRawActivityClient, RawActivityClient
from .types.activity_fetch_request_start_date import ActivityFetchRequestStartDate
from .types.activity_fetch_response import ActivityFetchResponse
from .types.activity_write_response import ActivityWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ActivityClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawActivityClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawActivityClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawActivityClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: ActivityFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActivityFetchResponse:
        """
        Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : ActivityFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActivityFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.activity.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

    def write(
        self, *, data: typing.Sequence[Activity], request_options: typing.Optional[RequestOptions] = None
    ) -> ActivityWriteResponse:
        """
        Used to post activity data to a provider. This endpoint only works for users connected via Wahoo. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Activity]
            List of user-tracked workouts to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActivityWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        from terra import Activity, ActivityMetadata, Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.activity.write(
            data=[
                Activity(
                    metadata=ActivityMetadata(
                        end_time="2022-10-28T10:00:00.000000+01:00",
                        start_time="1999-11-23T09:00:00.000000+02:00",
                        summary_id="123e4567-e89b-12d3-a456-426614174000",
                        type=1.1,
                        upload_type=1.1,
                    ),
                )
            ],
        )
        """
        _response = self._raw_client.write(data=data, request_options=request_options)
        return _response.data


class AsyncActivityClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawActivityClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawActivityClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawActivityClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: ActivityFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActivityFetchResponse:
        """
        Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : ActivityFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActivityFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.activity.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

    async def write(
        self, *, data: typing.Sequence[Activity], request_options: typing.Optional[RequestOptions] = None
    ) -> ActivityWriteResponse:
        """
        Used to post activity data to a provider. This endpoint only works for users connected via Wahoo. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Activity]
            List of user-tracked workouts to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActivityWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        import asyncio

        from terra import Activity, ActivityMetadata, AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.activity.write(
                data=[
                    Activity(
                        metadata=ActivityMetadata(
                            end_time="2022-10-28T10:00:00.000000+01:00",
                            start_time="1999-11-23T09:00:00.000000+02:00",
                            summary_id="123e4567-e89b-12d3-a456-426614174000",
                            type=1.1,
                            upload_type=1.1,
                        ),
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.write(data=data, request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/activity/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.activity import Activity
from .types.activity_fetch_request_start_date import ActivityFetchRequestStartDate
from .types.activity_fetch_response import ActivityFetchResponse
from .types.activity_write_response import ActivityWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawActivityClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: ActivityFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ActivityFetchResponse]:
        """
        Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : ActivityFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ActivityFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "activity",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActivityFetchResponse,
                    construct_type(
                        type_=ActivityFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def write(
        self, *, data: typing.Sequence[Activity], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ActivityWriteResponse]:
        """
        Used to post activity data to a provider. This endpoint only works for users connected via Wahoo. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Activity]
            List of user-tracked workouts to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ActivityWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = self._client_wrapper.httpx_client.request(
            "activity",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[Activity], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActivityWriteResponse,
                    construct_type(
                        type_=ActivityWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawActivityClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: ActivityFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ActivityFetchResponse]:
        """
        Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : ActivityFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ActivityFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "activity",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActivityFetchResponse,
                    construct_type(
                        type_=ActivityFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def write(
        self, *, data: typing.Sequence[Activity], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ActivityWriteResponse]:
        """
        Used to post activity data to a provider. This endpoint only works for users connected via Wahoo. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Activity]
            List of user-tracked workouts to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ActivityWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = await self._client_wrapper.httpx_client.request(
            "activity",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[Activity], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActivityWriteResponse,
                    construct_type(
                        type_=ActivityWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/activity/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/activity/types/activity_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

ActivityFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/activity/types/activity_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.large_request_processing_event import LargeRequestProcessingEvent
from ...types.no_data_returned import NoDataReturned
from ...types.rate_limit_request_processing import RateLimitRequestProcessing
from ...types.request_processing import RequestProcessing
from .activity_fetch_response_data import ActivityFetchResponseData

ActivityFetchResponse = typing.Union[
    ActivityFetchResponseData,
    NoDataReturned,
    DataSentToWebhook,
    RequestProcessing,
    RateLimitRequestProcessing,
    LargeRequestProcessingEvent,
]

```
</file>
<file path="terra-client-python/src/terra/activity/types/activity_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.activity import Activity
from ...types.terra_user import TerraUser


class ActivityFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[Activity]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/activity/types/activity_write_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser


class ActivityWriteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    log_ids: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB]
    """

    message: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/athlete/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/athlete/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from .raw_client import AsyncRawAthleteClient, RawAthleteClient
from .types.athlete_fetch_response import AthleteFetchResponse


class AthleteClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawAthleteClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawAthleteClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawAthleteClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AthleteFetchResponse:
        """
        Fetches relevant profile info such as first & last name, birth date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AthleteFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.athlete.fetch(
            user_id="user_id",
        )
        """
        _response = self._raw_client.fetch(user_id=user_id, to_webhook=to_webhook, request_options=request_options)
        return _response.data


class AsyncAthleteClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawAthleteClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawAthleteClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawAthleteClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AthleteFetchResponse:
        """
        Fetches relevant profile info such as first & last name, birth date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AthleteFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.athlete.fetch(
                user_id="user_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id, to_webhook=to_webhook, request_options=request_options
        )
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/athlete/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from .types.athlete_fetch_response import AthleteFetchResponse


class RawAthleteClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AthleteFetchResponse]:
        """
        Fetches relevant profile info such as first & last name, birth date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AthleteFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "athlete",
            method="GET",
            params={
                "user_id": user_id,
                "to_webhook": to_webhook,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AthleteFetchResponse,
                    construct_type(
                        type_=AthleteFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawAthleteClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AthleteFetchResponse]:
        """
        Fetches relevant profile info such as first & last name, birth date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AthleteFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "athlete",
            method="GET",
            params={
                "user_id": user_id,
                "to_webhook": to_webhook,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AthleteFetchResponse,
                    construct_type(
                        type_=AthleteFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/athlete/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/athlete/types/athlete_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from ...types.athlete import Athlete
from ...types.no_data_returned_status import NoDataReturnedStatus
from ...types.terra_user import TerraUser


class AthleteFetchResponse_Athlete(UncheckedBaseModel):
    type: typing.Literal["athlete"] = "athlete"
    athlete: typing.Optional[Athlete] = None
    user: typing.Optional[TerraUser] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class AthleteFetchResponse_NoData(UncheckedBaseModel):
    type: typing.Literal["no_data"] = "no_data"
    status: typing.Optional[NoDataReturnedStatus] = None
    message: typing.Optional[str] = None
    user: typing.Optional[TerraUser] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class AthleteFetchResponse_Webhook(UncheckedBaseModel):
    type: typing.Literal["webhook"] = "webhook"
    reference: typing.Optional[str] = None
    message: typing.Optional[str] = None
    user: typing.Optional[TerraUser] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


AthleteFetchResponse = typing_extensions.Annotated[
    typing.Union[AthleteFetchResponse_Athlete, AthleteFetchResponse_NoData, AthleteFetchResponse_Webhook],
    UnionMetadata(discriminant="type"),
]

```
</file>
<file path="terra-client-python/src/terra/authentication/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/authentication/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from .raw_client import AsyncRawAuthenticationClient, RawAuthenticationClient
from .types.authentication_authenticate_user_response import AuthenticationAuthenticateUserResponse
from .types.authentication_deauthenticate_user_response import AuthenticationDeauthenticateUserResponse
from .types.authentication_generate_auth_token_response import AuthenticationGenerateAuthTokenResponse
from .types.authentication_generate_widget_session_response import AuthenticationGenerateWidgetSessionResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AuthenticationClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawAuthenticationClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawAuthenticationClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawAuthenticationClient
        """
        return self._raw_client

    def authenticateuser(
        self,
        *,
        resource: str,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AuthenticationAuthenticateUserResponse:
        """
        Creates a login link that allows end users to connect their fitness tracking account

        Parameters
        ----------
        resource : str
            Provider resource identifier (e.g., 'FITBIT', 'GARMIN', 'OURA'). See "Get detailed list of integrations" for available providers

        language : typing.Optional[str]

        reference_id : typing.Optional[str]

        auth_success_redirect_url : typing.Optional[str]

        auth_failure_redirect_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationAuthenticateUserResponse
            Returned when authentication link could be successfully generated

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.authentication.authenticateuser(
            resource="FITBIT",
        )
        """
        _response = self._raw_client.authenticateuser(
            resource=resource,
            language=language,
            reference_id=reference_id,
            auth_success_redirect_url=auth_success_redirect_url,
            auth_failure_redirect_url=auth_failure_redirect_url,
            request_options=request_options,
        )
        return _response.data

    def generatewidgetsession(
        self,
        *,
        providers: typing.Optional[str] = OMIT,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AuthenticationGenerateWidgetSessionResponse:
        """
        Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider

        Parameters
        ----------
        providers : typing.Optional[str]
            Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard

        language : typing.Optional[str]
            Display language of the widget

        reference_id : typing.Optional[str]
            Identifier of the end user on your system, such as a user ID or email associated with them

        auth_success_redirect_url : typing.Optional[str]
            URL the user is redirected to upon successful authentication

        auth_failure_redirect_url : typing.Optional[str]
            URL the user is redirected to upon unsuccessful authentication

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationGenerateWidgetSessionResponse
            Returned when authentication link could be successfully generated

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.authentication.generatewidgetsession()
        """
        _response = self._raw_client.generatewidgetsession(
            providers=providers,
            language=language,
            reference_id=reference_id,
            auth_success_redirect_url=auth_success_redirect_url,
            auth_failure_redirect_url=auth_failure_redirect_url,
            request_options=request_options,
        )
        return _response.data

    def deauthenticateuser(
        self, *, user_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AuthenticationDeauthenticateUserResponse:
        """
        Deletes all records of the user on Terra's end, revoking Terra's access to their data

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to deauthenticate and remove from Terra system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationDeauthenticateUserResponse
            Returned when user is successfully deauthenticated and data is deleted

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.authentication.deauthenticateuser(
            user_id="user_id",
        )
        """
        _response = self._raw_client.deauthenticateuser(user_id=user_id, request_options=request_options)
        return _response.data

    def generateauthtoken(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AuthenticationGenerateAuthTokenResponse:
        """
        Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationGenerateAuthTokenResponse
            200

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.authentication.generateauthtoken()
        """
        _response = self._raw_client.generateauthtoken(request_options=request_options)
        return _response.data


class AsyncAuthenticationClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawAuthenticationClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawAuthenticationClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawAuthenticationClient
        """
        return self._raw_client

    async def authenticateuser(
        self,
        *,
        resource: str,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AuthenticationAuthenticateUserResponse:
        """
        Creates a login link that allows end users to connect their fitness tracking account

        Parameters
        ----------
        resource : str
            Provider resource identifier (e.g., 'FITBIT', 'GARMIN', 'OURA'). See "Get detailed list of integrations" for available providers

        language : typing.Optional[str]

        reference_id : typing.Optional[str]

        auth_success_redirect_url : typing.Optional[str]

        auth_failure_redirect_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationAuthenticateUserResponse
            Returned when authentication link could be successfully generated

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.authentication.authenticateuser(
                resource="FITBIT",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.authenticateuser(
            resource=resource,
            language=language,
            reference_id=reference_id,
            auth_success_redirect_url=auth_success_redirect_url,
            auth_failure_redirect_url=auth_failure_redirect_url,
            request_options=request_options,
        )
        return _response.data

    async def generatewidgetsession(
        self,
        *,
        providers: typing.Optional[str] = OMIT,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AuthenticationGenerateWidgetSessionResponse:
        """
        Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider

        Parameters
        ----------
        providers : typing.Optional[str]
            Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard

        language : typing.Optional[str]
            Display language of the widget

        reference_id : typing.Optional[str]
            Identifier of the end user on your system, such as a user ID or email associated with them

        auth_success_redirect_url : typing.Optional[str]
            URL the user is redirected to upon successful authentication

        auth_failure_redirect_url : typing.Optional[str]
            URL the user is redirected to upon unsuccessful authentication

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationGenerateWidgetSessionResponse
            Returned when authentication link could be successfully generated

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.authentication.generatewidgetsession()


        asyncio.run(main())
        """
        _response = await self._raw_client.generatewidgetsession(
            providers=providers,
            language=language,
            reference_id=reference_id,
            auth_success_redirect_url=auth_success_redirect_url,
            auth_failure_redirect_url=auth_failure_redirect_url,
            request_options=request_options,
        )
        return _response.data

    async def deauthenticateuser(
        self, *, user_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AuthenticationDeauthenticateUserResponse:
        """
        Deletes all records of the user on Terra's end, revoking Terra's access to their data

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to deauthenticate and remove from Terra system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationDeauthenticateUserResponse
            Returned when user is successfully deauthenticated and data is deleted

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.authentication.deauthenticateuser(
                user_id="user_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.deauthenticateuser(user_id=user_id, request_options=request_options)
        return _response.data

    async def generateauthtoken(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AuthenticationGenerateAuthTokenResponse:
        """
        Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AuthenticationGenerateAuthTokenResponse
            200

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.authentication.generateauthtoken()


        asyncio.run(main())
        """
        _response = await self._raw_client.generateauthtoken(request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/authentication/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from .types.authentication_authenticate_user_response import AuthenticationAuthenticateUserResponse
from .types.authentication_deauthenticate_user_response import AuthenticationDeauthenticateUserResponse
from .types.authentication_generate_auth_token_response import AuthenticationGenerateAuthTokenResponse
from .types.authentication_generate_widget_session_response import AuthenticationGenerateWidgetSessionResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawAuthenticationClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def authenticateuser(
        self,
        *,
        resource: str,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AuthenticationAuthenticateUserResponse]:
        """
        Creates a login link that allows end users to connect their fitness tracking account

        Parameters
        ----------
        resource : str
            Provider resource identifier (e.g., 'FITBIT', 'GARMIN', 'OURA'). See "Get detailed list of integrations" for available providers

        language : typing.Optional[str]

        reference_id : typing.Optional[str]

        auth_success_redirect_url : typing.Optional[str]

        auth_failure_redirect_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthenticationAuthenticateUserResponse]
            Returned when authentication link could be successfully generated
        """
        _response = self._client_wrapper.httpx_client.request(
            "auth/authenticateUser",
            method="POST",
            params={
                "resource": resource,
            },
            json={
                "language": language,
                "reference_id": reference_id,
                "auth_success_redirect_url": auth_success_redirect_url,
                "auth_failure_redirect_url": auth_failure_redirect_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationAuthenticateUserResponse,
                    construct_type(
                        type_=AuthenticationAuthenticateUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generatewidgetsession(
        self,
        *,
        providers: typing.Optional[str] = OMIT,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AuthenticationGenerateWidgetSessionResponse]:
        """
        Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider

        Parameters
        ----------
        providers : typing.Optional[str]
            Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard

        language : typing.Optional[str]
            Display language of the widget

        reference_id : typing.Optional[str]
            Identifier of the end user on your system, such as a user ID or email associated with them

        auth_success_redirect_url : typing.Optional[str]
            URL the user is redirected to upon successful authentication

        auth_failure_redirect_url : typing.Optional[str]
            URL the user is redirected to upon unsuccessful authentication

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthenticationGenerateWidgetSessionResponse]
            Returned when authentication link could be successfully generated
        """
        _response = self._client_wrapper.httpx_client.request(
            "auth/generateWidgetSession",
            method="POST",
            json={
                "providers": providers,
                "language": language,
                "reference_id": reference_id,
                "auth_success_redirect_url": auth_success_redirect_url,
                "auth_failure_redirect_url": auth_failure_redirect_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationGenerateWidgetSessionResponse,
                    construct_type(
                        type_=AuthenticationGenerateWidgetSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deauthenticateuser(
        self, *, user_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AuthenticationDeauthenticateUserResponse]:
        """
        Deletes all records of the user on Terra's end, revoking Terra's access to their data

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to deauthenticate and remove from Terra system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthenticationDeauthenticateUserResponse]
            Returned when user is successfully deauthenticated and data is deleted
        """
        _response = self._client_wrapper.httpx_client.request(
            "auth/deauthenticateUser",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationDeauthenticateUserResponse,
                    construct_type(
                        type_=AuthenticationDeauthenticateUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generateauthtoken(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AuthenticationGenerateAuthTokenResponse]:
        """
        Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthenticationGenerateAuthTokenResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            "auth/generateAuthToken",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationGenerateAuthTokenResponse,
                    construct_type(
                        type_=AuthenticationGenerateAuthTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawAuthenticationClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def authenticateuser(
        self,
        *,
        resource: str,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AuthenticationAuthenticateUserResponse]:
        """
        Creates a login link that allows end users to connect their fitness tracking account

        Parameters
        ----------
        resource : str
            Provider resource identifier (e.g., 'FITBIT', 'GARMIN', 'OURA'). See "Get detailed list of integrations" for available providers

        language : typing.Optional[str]

        reference_id : typing.Optional[str]

        auth_success_redirect_url : typing.Optional[str]

        auth_failure_redirect_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthenticationAuthenticateUserResponse]
            Returned when authentication link could be successfully generated
        """
        _response = await self._client_wrapper.httpx_client.request(
            "auth/authenticateUser",
            method="POST",
            params={
                "resource": resource,
            },
            json={
                "language": language,
                "reference_id": reference_id,
                "auth_success_redirect_url": auth_success_redirect_url,
                "auth_failure_redirect_url": auth_failure_redirect_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationAuthenticateUserResponse,
                    construct_type(
                        type_=AuthenticationAuthenticateUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generatewidgetsession(
        self,
        *,
        providers: typing.Optional[str] = OMIT,
        language: typing.Optional[str] = OMIT,
        reference_id: typing.Optional[str] = OMIT,
        auth_success_redirect_url: typing.Optional[str] = OMIT,
        auth_failure_redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AuthenticationGenerateWidgetSessionResponse]:
        """
        Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider

        Parameters
        ----------
        providers : typing.Optional[str]
            Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard

        language : typing.Optional[str]
            Display language of the widget

        reference_id : typing.Optional[str]
            Identifier of the end user on your system, such as a user ID or email associated with them

        auth_success_redirect_url : typing.Optional[str]
            URL the user is redirected to upon successful authentication

        auth_failure_redirect_url : typing.Optional[str]
            URL the user is redirected to upon unsuccessful authentication

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthenticationGenerateWidgetSessionResponse]
            Returned when authentication link could be successfully generated
        """
        _response = await self._client_wrapper.httpx_client.request(
            "auth/generateWidgetSession",
            method="POST",
            json={
                "providers": providers,
                "language": language,
                "reference_id": reference_id,
                "auth_success_redirect_url": auth_success_redirect_url,
                "auth_failure_redirect_url": auth_failure_redirect_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationGenerateWidgetSessionResponse,
                    construct_type(
                        type_=AuthenticationGenerateWidgetSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deauthenticateuser(
        self, *, user_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AuthenticationDeauthenticateUserResponse]:
        """
        Deletes all records of the user on Terra's end, revoking Terra's access to their data

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to deauthenticate and remove from Terra system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthenticationDeauthenticateUserResponse]
            Returned when user is successfully deauthenticated and data is deleted
        """
        _response = await self._client_wrapper.httpx_client.request(
            "auth/deauthenticateUser",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationDeauthenticateUserResponse,
                    construct_type(
                        type_=AuthenticationDeauthenticateUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generateauthtoken(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AuthenticationGenerateAuthTokenResponse]:
        """
        Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthenticationGenerateAuthTokenResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            "auth/generateAuthToken",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthenticationGenerateAuthTokenResponse,
                    construct_type(
                        type_=AuthenticationGenerateAuthTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/authentication/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_authenticate_user_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from .authentication_authenticate_user_response_status import AuthenticationAuthenticateUserResponseStatus


class AuthenticationAuthenticateUserResponse(UncheckedBaseModel):
    status: typing.Optional[AuthenticationAuthenticateUserResponseStatus] = pydantic.Field(default=None)
    """
    indicates that the request was successful
    """

    user_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    User ID for the user being created
    """

    auth_url: typing.Optional[str] = pydantic.Field(default=None)
    """
    authentication URL the user must be redirected to in order to link their account
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_authenticate_user_response_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

AuthenticationAuthenticateUserResponseStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_deauthenticate_user_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from .authentication_deauthenticate_user_response_status import AuthenticationDeauthenticateUserResponseStatus


class AuthenticationDeauthenticateUserResponse(UncheckedBaseModel):
    status: typing.Optional[AuthenticationDeauthenticateUserResponseStatus] = pydantic.Field(default=None)
    """
    indicates that the deauthentication was successful (value is success)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_deauthenticate_user_response_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

AuthenticationDeauthenticateUserResponseStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_generate_auth_token_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel


class AuthenticationGenerateAuthTokenResponse(UncheckedBaseModel):
    status: typing.Optional[str] = None
    token: typing.Optional[str] = None
    expires_in: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_generate_widget_session_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from .authentication_generate_widget_session_response_status import AuthenticationGenerateWidgetSessionResponseStatus


class AuthenticationGenerateWidgetSessionResponse(UncheckedBaseModel):
    session_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Session ID for the widget authentication session
    """

    url: typing.Optional[str] = pydantic.Field(default=None)
    """
    the widget URL the user must be redirected to in order to link their account
    """

    status: typing.Optional[AuthenticationGenerateWidgetSessionResponseStatus] = pydantic.Field(default=None)
    """
    indicates that the request was successful (value is success)
    """

    expires_in: typing.Optional[float] = pydantic.Field(default=None)
    """
    a number in seconds depicting how long the url is valid for
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/authentication/types/authentication_generate_widget_session_response_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

AuthenticationGenerateWidgetSessionResponseStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/body/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/body/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.body import Body
from .raw_client import AsyncRawBodyClient, RawBodyClient
from .types.body_delete_response import BodyDeleteResponse
from .types.body_fetch_request_start_date import BodyFetchRequestStartDate
from .types.body_fetch_response import BodyFetchResponse
from .types.body_write_response import BodyWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class BodyClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawBodyClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawBodyClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawBodyClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: BodyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BodyFetchResponse:
        """
        Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : BodyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BodyFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.body.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

    def write(
        self, *, data: typing.Sequence[Body], request_options: typing.Optional[RequestOptions] = None
    ) -> BodyWriteResponse:
        """
        Used to post body data to a provider. This endpoint only works for users connected via Google Fit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Body]
            Body measurement metrics to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BodyWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        from terra import Body, BodyMetadata, Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.body.write(
            data=[
                Body(
                    metadata=BodyMetadata(
                        end_time="2022-10-28T10:00:00.000000+01:00",
                        start_time="1999-11-23T09:00:00.000000+02:00",
                    ),
                )
            ],
        )
        """
        _response = self._raw_client.write(data=data, request_options=request_options)
        return _response.data

    def delete(
        self,
        *,
        user_id: str,
        log_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BodyDeleteResponse:
        """
        Used to delete Body metrics the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        log_ids : typing.Optional[typing.Sequence[str]]
            List of identifiers for body metrics entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BodyDeleteResponse
            Returned when all records were deleted successfully

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.body.delete(
            user_id="user_id",
        )
        """
        _response = self._raw_client.delete(user_id=user_id, log_ids=log_ids, request_options=request_options)
        return _response.data


class AsyncBodyClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawBodyClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawBodyClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawBodyClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: BodyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BodyFetchResponse:
        """
        Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : BodyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BodyFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.body.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

    async def write(
        self, *, data: typing.Sequence[Body], request_options: typing.Optional[RequestOptions] = None
    ) -> BodyWriteResponse:
        """
        Used to post body data to a provider. This endpoint only works for users connected via Google Fit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Body]
            Body measurement metrics to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BodyWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        import asyncio

        from terra import AsyncTerra, Body, BodyMetadata

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.body.write(
                data=[
                    Body(
                        metadata=BodyMetadata(
                            end_time="2022-10-28T10:00:00.000000+01:00",
                            start_time="1999-11-23T09:00:00.000000+02:00",
                        ),
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.write(data=data, request_options=request_options)
        return _response.data

    async def delete(
        self,
        *,
        user_id: str,
        log_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BodyDeleteResponse:
        """
        Used to delete Body metrics the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        log_ids : typing.Optional[typing.Sequence[str]]
            List of identifiers for body metrics entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BodyDeleteResponse
            Returned when all records were deleted successfully

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.body.delete(
                user_id="user_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete(user_id=user_id, log_ids=log_ids, request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/body/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.body import Body
from .types.body_delete_response import BodyDeleteResponse
from .types.body_fetch_request_start_date import BodyFetchRequestStartDate
from .types.body_fetch_response import BodyFetchResponse
from .types.body_write_response import BodyWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawBodyClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: BodyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BodyFetchResponse]:
        """
        Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : BodyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BodyFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "body",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BodyFetchResponse,
                    construct_type(
                        type_=BodyFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def write(
        self, *, data: typing.Sequence[Body], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[BodyWriteResponse]:
        """
        Used to post body data to a provider. This endpoint only works for users connected via Google Fit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Body]
            Body measurement metrics to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BodyWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = self._client_wrapper.httpx_client.request(
            "body",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[Body], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BodyWriteResponse,
                    construct_type(
                        type_=BodyWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        *,
        user_id: str,
        log_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BodyDeleteResponse]:
        """
        Used to delete Body metrics the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        log_ids : typing.Optional[typing.Sequence[str]]
            List of identifiers for body metrics entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BodyDeleteResponse]
            Returned when all records were deleted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "body",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            json={
                "log_ids": log_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BodyDeleteResponse,
                    construct_type(
                        type_=BodyDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawBodyClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: BodyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BodyFetchResponse]:
        """
        Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : BodyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BodyFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "body",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BodyFetchResponse,
                    construct_type(
                        type_=BodyFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def write(
        self, *, data: typing.Sequence[Body], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[BodyWriteResponse]:
        """
        Used to post body data to a provider. This endpoint only works for users connected via Google Fit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Body]
            Body measurement metrics to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BodyWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = await self._client_wrapper.httpx_client.request(
            "body",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[Body], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BodyWriteResponse,
                    construct_type(
                        type_=BodyWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        *,
        user_id: str,
        log_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BodyDeleteResponse]:
        """
        Used to delete Body metrics the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        log_ids : typing.Optional[typing.Sequence[str]]
            List of identifiers for body metrics entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BodyDeleteResponse]
            Returned when all records were deleted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "body",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            json={
                "log_ids": log_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BodyDeleteResponse,
                    construct_type(
                        type_=BodyDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/body/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/body/types/body_delete_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser
from .body_delete_response_processed_data_item import BodyDeleteResponseProcessedDataItem


class BodyDeleteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    processed_data: typing.Optional[typing.List[BodyDeleteResponseProcessedDataItem]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/body/types/body_delete_response_processed_data_item.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel


class BodyDeleteResponseProcessedDataItem(UncheckedBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Identifier of the body metric entries whose deletion was attempted
    """

    response_code: typing.Optional[int] = pydantic.Field(default=None)
    """
    Response code from the provider when attempting to delete the body metric entries
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/body/types/body_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

BodyFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/body/types/body_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.large_request_processing_event import LargeRequestProcessingEvent
from ...types.no_data_returned import NoDataReturned
from ...types.rate_limit_request_processing import RateLimitRequestProcessing
from ...types.request_processing import RequestProcessing
from .body_fetch_response_data import BodyFetchResponseData

BodyFetchResponse = typing.Union[
    BodyFetchResponseData,
    NoDataReturned,
    DataSentToWebhook,
    RequestProcessing,
    RateLimitRequestProcessing,
    LargeRequestProcessingEvent,
]

```
</file>
<file path="terra-client-python/src/terra/body/types/body_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.body import Body
from ...types.terra_user import TerraUser


class BodyFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[Body]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/body/types/body_write_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser


class BodyWriteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    log_ids: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB]
    """

    message: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import httpx
from .activity.client import ActivityClient, AsyncActivityClient
from .athlete.client import AsyncAthleteClient, AthleteClient
from .authentication.client import AsyncAuthenticationClient, AuthenticationClient
from .body.client import AsyncBodyClient, BodyClient
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .daily.client import AsyncDailyClient, DailyClient
from .environment import TerraEnvironment
from .integrations.client import AsyncIntegrationsClient, IntegrationsClient
from .menstruation.client import AsyncMenstruationClient, MenstruationClient
from .nutrition.client import AsyncNutritionClient, NutritionClient
from .plannedworkout.client import AsyncPlannedworkoutClient, PlannedworkoutClient
from .sleep.client import AsyncSleepClient, SleepClient
from .user.client import AsyncUserClient, UserClient


class Terra:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : TerraEnvironment
        The environment to use for requests from the client. from .environment import TerraEnvironment



        Defaults to TerraEnvironment.DEFAULT



    dev_id : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from terra import Terra

    client = Terra(
        dev_id="YOUR_DEV_ID",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: TerraEnvironment = TerraEnvironment.DEFAULT,
        dev_id: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            dev_id=dev_id,
            api_key=api_key,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self.authentication = AuthenticationClient(client_wrapper=self._client_wrapper)
        self.user = UserClient(client_wrapper=self._client_wrapper)
        self.activity = ActivityClient(client_wrapper=self._client_wrapper)
        self.athlete = AthleteClient(client_wrapper=self._client_wrapper)
        self.body = BodyClient(client_wrapper=self._client_wrapper)
        self.daily = DailyClient(client_wrapper=self._client_wrapper)
        self.menstruation = MenstruationClient(client_wrapper=self._client_wrapper)
        self.nutrition = NutritionClient(client_wrapper=self._client_wrapper)
        self.sleep = SleepClient(client_wrapper=self._client_wrapper)
        self.plannedworkout = PlannedworkoutClient(client_wrapper=self._client_wrapper)
        self.integrations = IntegrationsClient(client_wrapper=self._client_wrapper)


class AsyncTerra:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : TerraEnvironment
        The environment to use for requests from the client. from .environment import TerraEnvironment



        Defaults to TerraEnvironment.DEFAULT



    dev_id : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from terra import AsyncTerra

    client = AsyncTerra(
        dev_id="YOUR_DEV_ID",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: TerraEnvironment = TerraEnvironment.DEFAULT,
        dev_id: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            dev_id=dev_id,
            api_key=api_key,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self.authentication = AsyncAuthenticationClient(client_wrapper=self._client_wrapper)
        self.user = AsyncUserClient(client_wrapper=self._client_wrapper)
        self.activity = AsyncActivityClient(client_wrapper=self._client_wrapper)
        self.athlete = AsyncAthleteClient(client_wrapper=self._client_wrapper)
        self.body = AsyncBodyClient(client_wrapper=self._client_wrapper)
        self.daily = AsyncDailyClient(client_wrapper=self._client_wrapper)
        self.menstruation = AsyncMenstruationClient(client_wrapper=self._client_wrapper)
        self.nutrition = AsyncNutritionClient(client_wrapper=self._client_wrapper)
        self.sleep = AsyncSleepClient(client_wrapper=self._client_wrapper)
        self.plannedworkout = AsyncPlannedworkoutClient(client_wrapper=self._client_wrapper)
        self.integrations = AsyncIntegrationsClient(client_wrapper=self._client_wrapper)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: TerraEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")

```
</file>
<file path="terra-client-python/src/terra/core/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file

from .file import File, with_content_type

__all__ = ["File", "with_content_type"]

```
</file>
<file path="terra-client-python/src/terra/core/api_error.py">
```py
# This file was auto-generated by Fern from our API Definition.

from typing import Any, Dict, Optional


class ApiError(Exception):
    headers: Optional[Dict[str, str]]
    status_code: Optional[int]
    body: Any

    def __init__(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        status_code: Optional[int] = None,
        body: Any = None,
    ) -> None:
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def __str__(self) -> str:
        return f"headers: {self.headers}, status_code: {self.status_code}, body: {self.body}"

```
</file>
<file path="terra-client-python/src/terra/core/client_wrapper.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import httpx
from .http_client import AsyncHttpClient, HttpClient


class BaseClientWrapper:
    def __init__(self, *, dev_id: str, api_key: str, base_url: str, timeout: typing.Optional[float] = None):
        self._dev_id = dev_id
        self.api_key = api_key
        self._base_url = base_url
        self._timeout = timeout

    def get_headers(self) -> typing.Dict[str, str]:
        headers: typing.Dict[str, str] = {
            "User-Agent": "terra-python/1.0.5",
            "X-Fern-Language": "Python",
            "X-Fern-SDK-Name": "terra-python",
            "X-Fern-SDK-Version": "1.0.5",
        }
        headers["dev-id"] = self._dev_id
        headers["x-api-key"] = self.api_key
        return headers

    def get_base_url(self) -> str:
        return self._base_url

    def get_timeout(self) -> typing.Optional[float]:
        return self._timeout


class SyncClientWrapper(BaseClientWrapper):
    def __init__(
        self,
        *,
        dev_id: str,
        api_key: str,
        base_url: str,
        timeout: typing.Optional[float] = None,
        httpx_client: httpx.Client,
    ):
        super().__init__(dev_id=dev_id, api_key=api_key, base_url=base_url, timeout=timeout)
        self.httpx_client = HttpClient(
            httpx_client=httpx_client,
            base_headers=self.get_headers,
            base_timeout=self.get_timeout,
            base_url=self.get_base_url,
        )


class AsyncClientWrapper(BaseClientWrapper):
    def __init__(
        self,
        *,
        dev_id: str,
        api_key: str,
        base_url: str,
        timeout: typing.Optional[float] = None,
        httpx_client: httpx.AsyncClient,
    ):
        super().__init__(dev_id=dev_id, api_key=api_key, base_url=base_url, timeout=timeout)
        self.httpx_client = AsyncHttpClient(
            httpx_client=httpx_client,
            base_headers=self.get_headers,
            base_timeout=self.get_timeout,
            base_url=self.get_base_url,
        )

```
</file>
<file path="terra-client-python/src/terra/core/datetime_utils.py">
```py
# This file was auto-generated by Fern from our API Definition.

import datetime as dt


def serialize_datetime(v: dt.datetime) -> str:
    """
    Serialize a datetime including timezone info.

    Uses the timezone info provided if present, otherwise uses the current runtime's timezone info.

    UTC datetimes end in "Z" while all other timezones are represented as offset from UTC, e.g. +05:00.
    """

    def _serialize_zoned_datetime(v: dt.datetime) -> str:
        if v.tzinfo is not None and v.tzinfo.tzname(None) == dt.timezone.utc.tzname(None):
            # UTC is a special case where we use "Z" at the end instead of "+00:00"
            return v.isoformat().replace("+00:00", "Z")
        else:
            # Delegate to the typical +/- offset format
            return v.isoformat()

    if v.tzinfo is not None:
        return _serialize_zoned_datetime(v)
    else:
        local_tz = dt.datetime.now().astimezone().tzinfo
        localized_dt = v.replace(tzinfo=local_tz)
        return _serialize_zoned_datetime(localized_dt)

```
</file>
<file path="terra-client-python/src/terra/core/file.py">
```py
# This file was auto-generated by Fern from our API Definition.

from typing import IO, Dict, List, Mapping, Optional, Tuple, Union, cast

# File typing inspired by the flexibility of types within the httpx library
# https://github.com/encode/httpx/blob/master/httpx/_types.py
FileContent = Union[IO[bytes], bytes, str]
File = Union[
    # file (or bytes)
    FileContent,
    # (filename, file (or bytes))
    Tuple[Optional[str], FileContent],
    # (filename, file (or bytes), content_type)
    Tuple[Optional[str], FileContent, Optional[str]],
    # (filename, file (or bytes), content_type, headers)
    Tuple[
        Optional[str],
        FileContent,
        Optional[str],
        Mapping[str, str],
    ],
]


def convert_file_dict_to_httpx_tuples(
    d: Dict[str, Union[File, List[File]]],
) -> List[Tuple[str, File]]:
    """
    The format we use is a list of tuples, where the first element is the
    name of the file and the second is the file object. Typically HTTPX wants
    a dict, but to be able to send lists of files, you have to use the list
    approach (which also works for non-lists)
    https://github.com/encode/httpx/pull/1032
    """

    httpx_tuples = []
    for key, file_like in d.items():
        if isinstance(file_like, list):
            for file_like_item in file_like:
                httpx_tuples.append((key, file_like_item))
        else:
            httpx_tuples.append((key, file_like))
    return httpx_tuples


def with_content_type(*, file: File, default_content_type: str) -> File:
    """
    This function resolves to the file's content type, if provided, and defaults
    to the default_content_type value if not.
    """
    if isinstance(file, tuple):
        if len(file) == 2:
            filename, content = cast(Tuple[Optional[str], FileContent], file)  # type: ignore
            return (filename, content, default_content_type)
        elif len(file) == 3:
            filename, content, file_content_type = cast(Tuple[Optional[str], FileContent, Optional[str]], file)  # type: ignore
            out_content_type = file_content_type or default_content_type
            return (filename, content, out_content_type)
        elif len(file) == 4:
            filename, content, file_content_type, headers = cast(  # type: ignore
                Tuple[Optional[str], FileContent, Optional[str], Mapping[str, str]], file
            )
            out_content_type = file_content_type or default_content_type
            return (filename, content, out_content_type, headers)
        else:
            raise ValueError(f"Unexpected tuple length: {len(file)}")
    return (None, file, default_content_type)

```
</file>
<file path="terra-client-python/src/terra/core/force_multipart.py">
```py
# This file was auto-generated by Fern from our API Definition.


class ForceMultipartDict(dict):
    """
    A dictionary subclass that always evaluates to True in boolean contexts.

    This is used to force multipart/form-data encoding in HTTP requests even when
    the dictionary is empty, which would normally evaluate to False.
    """

    def __bool__(self):
        return True


FORCE_MULTIPART = ForceMultipartDict()

```
</file>
<file path="terra-client-python/src/terra/core/http_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import asyncio
import email.utils
import re
import time
import typing
import urllib.parse
from contextlib import asynccontextmanager, contextmanager
from random import random

import httpx
from .file import File, convert_file_dict_to_httpx_tuples
from .force_multipart import FORCE_MULTIPART
from .jsonable_encoder import jsonable_encoder
from .query_encoder import encode_query
from .remove_none_from_dict import remove_none_from_dict
from .request_options import RequestOptions
from httpx._types import RequestFiles

INITIAL_RETRY_DELAY_SECONDS = 0.5
MAX_RETRY_DELAY_SECONDS = 10
MAX_RETRY_DELAY_SECONDS_FROM_HEADER = 30


def _parse_retry_after(response_headers: httpx.Headers) -> typing.Optional[float]:
    """
    This function parses the `Retry-After` header in a HTTP response and returns the number of seconds to wait.

    Inspired by the urllib3 retry implementation.
    """
    retry_after_ms = response_headers.get("retry-after-ms")
    if retry_after_ms is not None:
        try:
            return int(retry_after_ms) / 1000 if retry_after_ms > 0 else 0
        except Exception:
            pass

    retry_after = response_headers.get("retry-after")
    if retry_after is None:
        return None

    # Attempt to parse the header as an int.
    if re.match(r"^\s*[0-9]+\s*$", retry_after):
        seconds = float(retry_after)
    # Fallback to parsing it as a date.
    else:
        retry_date_tuple = email.utils.parsedate_tz(retry_after)
        if retry_date_tuple is None:
            return None
        if retry_date_tuple[9] is None:  # Python 2
            # Assume UTC if no timezone was specified
            # On Python2.7, parsedate_tz returns None for a timezone offset
            # instead of 0 if no timezone is given, where mktime_tz treats
            # a None timezone offset as local time.
            retry_date_tuple = retry_date_tuple[:9] + (0,) + retry_date_tuple[10:]

        retry_date = email.utils.mktime_tz(retry_date_tuple)
        seconds = retry_date - time.time()

    if seconds < 0:
        seconds = 0

    return seconds


def _retry_timeout(response: httpx.Response, retries: int) -> float:
    """
    Determine the amount of time to wait before retrying a request.
    This function begins by trying to parse a retry-after header from the response, and then proceeds to use exponential backoff
    with a jitter to determine the number of seconds to wait.
    """

    # If the API asks us to wait a certain amount of time (and it's a reasonable amount), just do what it says.
    retry_after = _parse_retry_after(response.headers)
    if retry_after is not None and retry_after <= MAX_RETRY_DELAY_SECONDS_FROM_HEADER:
        return retry_after

    # Apply exponential backoff, capped at MAX_RETRY_DELAY_SECONDS.
    retry_delay = min(INITIAL_RETRY_DELAY_SECONDS * pow(2.0, retries), MAX_RETRY_DELAY_SECONDS)

    # Add a randomness / jitter to the retry delay to avoid overwhelming the server with retries.
    timeout = retry_delay * (1 - 0.25 * random())
    return timeout if timeout >= 0 else 0


def _should_retry(response: httpx.Response) -> bool:
    retryable_400s = [429, 408, 409]
    return response.status_code >= 500 or response.status_code in retryable_400s


def remove_omit_from_dict(
    original: typing.Dict[str, typing.Optional[typing.Any]],
    omit: typing.Optional[typing.Any],
) -> typing.Dict[str, typing.Any]:
    if omit is None:
        return original
    new: typing.Dict[str, typing.Any] = {}
    for key, value in original.items():
        if value is not omit:
            new[key] = value
    return new


def maybe_filter_request_body(
    data: typing.Optional[typing.Any],
    request_options: typing.Optional[RequestOptions],
    omit: typing.Optional[typing.Any],
) -> typing.Optional[typing.Any]:
    if data is None:
        return (
            jsonable_encoder(request_options.get("additional_body_parameters", {})) or {}
            if request_options is not None
            else None
        )
    elif not isinstance(data, typing.Mapping):
        data_content = jsonable_encoder(data)
    else:
        data_content = {
            **(jsonable_encoder(remove_omit_from_dict(data, omit))),  # type: ignore
            **(
                jsonable_encoder(request_options.get("additional_body_parameters", {})) or {}
                if request_options is not None
                else {}
            ),
        }
    return data_content


# Abstracted out for testing purposes
def get_request_body(
    *,
    json: typing.Optional[typing.Any],
    data: typing.Optional[typing.Any],
    request_options: typing.Optional[RequestOptions],
    omit: typing.Optional[typing.Any],
) -> typing.Tuple[typing.Optional[typing.Any], typing.Optional[typing.Any]]:
    json_body = None
    data_body = None
    if data is not None:
        data_body = maybe_filter_request_body(data, request_options, omit)
    else:
        # If both data and json are None, we send json data in the event extra properties are specified
        json_body = maybe_filter_request_body(json, request_options, omit)

    # If you have an empty JSON body, you should just send None
    return (json_body if json_body != {} else None), data_body if data_body != {} else None


class HttpClient:
    def __init__(
        self,
        *,
        httpx_client: httpx.Client,
        base_timeout: typing.Callable[[], typing.Optional[float]],
        base_headers: typing.Callable[[], typing.Dict[str, str]],
        base_url: typing.Optional[typing.Callable[[], str]] = None,
    ):
        self.base_url = base_url
        self.base_timeout = base_timeout
        self.base_headers = base_headers
        self.httpx_client = httpx_client

    def get_base_url(self, maybe_base_url: typing.Optional[str]) -> str:
        base_url = maybe_base_url
        if self.base_url is not None and base_url is None:
            base_url = self.base_url()

        if base_url is None:
            raise ValueError("A base_url is required to make this request, please provide one and try again.")
        return base_url

    def request(
        self,
        path: typing.Optional[str] = None,
        *,
        method: str,
        base_url: typing.Optional[str] = None,
        params: typing.Optional[typing.Dict[str, typing.Any]] = None,
        json: typing.Optional[typing.Any] = None,
        data: typing.Optional[typing.Any] = None,
        content: typing.Optional[typing.Union[bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]]] = None,
        files: typing.Optional[
            typing.Union[
                typing.Dict[str, typing.Optional[typing.Union[File, typing.List[File]]]],
                typing.List[typing.Tuple[str, File]],
            ]
        ] = None,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = None,
        request_options: typing.Optional[RequestOptions] = None,
        retries: int = 2,
        omit: typing.Optional[typing.Any] = None,
        force_multipart: typing.Optional[bool] = None,
    ) -> httpx.Response:
        base_url = self.get_base_url(base_url)
        timeout = (
            request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self.base_timeout()
        )

        json_body, data_body = get_request_body(json=json, data=data, request_options=request_options, omit=omit)

        request_files: typing.Optional[RequestFiles] = (
            convert_file_dict_to_httpx_tuples(remove_omit_from_dict(remove_none_from_dict(files), omit))
            if (files is not None and files is not omit and isinstance(files, dict))
            else None
        )

        if (request_files is None or len(request_files) == 0) and force_multipart:
            request_files = FORCE_MULTIPART

        response = self.httpx_client.request(
            method=method,
            url=urllib.parse.urljoin(f"{base_url}/", path),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self.base_headers(),
                        **(headers if headers is not None else {}),
                        **(request_options.get("additional_headers", {}) or {} if request_options is not None else {}),
                    }
                )
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        remove_omit_from_dict(
                            {
                                **(params if params is not None else {}),
                                **(
                                    request_options.get("additional_query_parameters", {}) or {}
                                    if request_options is not None
                                    else {}
                                ),
                            },
                            omit,
                        )
                    )
                )
            ),
            json=json_body,
            data=data_body,
            content=content,
            files=request_files,
            timeout=timeout,
        )

        max_retries: int = request_options.get("max_retries", 0) if request_options is not None else 0
        if _should_retry(response=response):
            if max_retries > retries:
                time.sleep(_retry_timeout(response=response, retries=retries))
                return self.request(
                    path=path,
                    method=method,
                    base_url=base_url,
                    params=params,
                    json=json,
                    content=content,
                    files=files,
                    headers=headers,
                    request_options=request_options,
                    retries=retries + 1,
                    omit=omit,
                )

        return response

    @contextmanager
    def stream(
        self,
        path: typing.Optional[str] = None,
        *,
        method: str,
        base_url: typing.Optional[str] = None,
        params: typing.Optional[typing.Dict[str, typing.Any]] = None,
        json: typing.Optional[typing.Any] = None,
        data: typing.Optional[typing.Any] = None,
        content: typing.Optional[typing.Union[bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]]] = None,
        files: typing.Optional[
            typing.Union[
                typing.Dict[str, typing.Optional[typing.Union[File, typing.List[File]]]],
                typing.List[typing.Tuple[str, File]],
            ]
        ] = None,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = None,
        request_options: typing.Optional[RequestOptions] = None,
        retries: int = 2,
        omit: typing.Optional[typing.Any] = None,
        force_multipart: typing.Optional[bool] = None,
    ) -> typing.Iterator[httpx.Response]:
        base_url = self.get_base_url(base_url)
        timeout = (
            request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self.base_timeout()
        )

        request_files: typing.Optional[RequestFiles] = (
            convert_file_dict_to_httpx_tuples(remove_omit_from_dict(remove_none_from_dict(files), omit))
            if (files is not None and files is not omit and isinstance(files, dict))
            else None
        )

        if (request_files is None or len(request_files) == 0) and force_multipart:
            request_files = FORCE_MULTIPART

        json_body, data_body = get_request_body(json=json, data=data, request_options=request_options, omit=omit)

        with self.httpx_client.stream(
            method=method,
            url=urllib.parse.urljoin(f"{base_url}/", path),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self.base_headers(),
                        **(headers if headers is not None else {}),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        remove_omit_from_dict(
                            {
                                **(params if params is not None else {}),
                                **(
                                    request_options.get("additional_query_parameters", {})
                                    if request_options is not None
                                    else {}
                                ),
                            },
                            omit,
                        )
                    )
                )
            ),
            json=json_body,
            data=data_body,
            content=content,
            files=request_files,
            timeout=timeout,
        ) as stream:
            yield stream


class AsyncHttpClient:
    def __init__(
        self,
        *,
        httpx_client: httpx.AsyncClient,
        base_timeout: typing.Callable[[], typing.Optional[float]],
        base_headers: typing.Callable[[], typing.Dict[str, str]],
        base_url: typing.Optional[typing.Callable[[], str]] = None,
    ):
        self.base_url = base_url
        self.base_timeout = base_timeout
        self.base_headers = base_headers
        self.httpx_client = httpx_client

    def get_base_url(self, maybe_base_url: typing.Optional[str]) -> str:
        base_url = maybe_base_url
        if self.base_url is not None and base_url is None:
            base_url = self.base_url()

        if base_url is None:
            raise ValueError("A base_url is required to make this request, please provide one and try again.")
        return base_url

    async def request(
        self,
        path: typing.Optional[str] = None,
        *,
        method: str,
        base_url: typing.Optional[str] = None,
        params: typing.Optional[typing.Dict[str, typing.Any]] = None,
        json: typing.Optional[typing.Any] = None,
        data: typing.Optional[typing.Any] = None,
        content: typing.Optional[typing.Union[bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]]] = None,
        files: typing.Optional[
            typing.Union[
                typing.Dict[str, typing.Optional[typing.Union[File, typing.List[File]]]],
                typing.List[typing.Tuple[str, File]],
            ]
        ] = None,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = None,
        request_options: typing.Optional[RequestOptions] = None,
        retries: int = 2,
        omit: typing.Optional[typing.Any] = None,
        force_multipart: typing.Optional[bool] = None,
    ) -> httpx.Response:
        base_url = self.get_base_url(base_url)
        timeout = (
            request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self.base_timeout()
        )

        request_files: typing.Optional[RequestFiles] = (
            convert_file_dict_to_httpx_tuples(remove_omit_from_dict(remove_none_from_dict(files), omit))
            if (files is not None and files is not omit and isinstance(files, dict))
            else None
        )

        if (request_files is None or len(request_files) == 0) and force_multipart:
            request_files = FORCE_MULTIPART

        json_body, data_body = get_request_body(json=json, data=data, request_options=request_options, omit=omit)

        # Add the input to each of these and do None-safety checks
        response = await self.httpx_client.request(
            method=method,
            url=urllib.parse.urljoin(f"{base_url}/", path),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self.base_headers(),
                        **(headers if headers is not None else {}),
                        **(request_options.get("additional_headers", {}) or {} if request_options is not None else {}),
                    }
                )
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        remove_omit_from_dict(
                            {
                                **(params if params is not None else {}),
                                **(
                                    request_options.get("additional_query_parameters", {}) or {}
                                    if request_options is not None
                                    else {}
                                ),
                            },
                            omit,
                        )
                    )
                )
            ),
            json=json_body,
            data=data_body,
            content=content,
            files=request_files,
            timeout=timeout,
        )

        max_retries: int = request_options.get("max_retries", 0) if request_options is not None else 0
        if _should_retry(response=response):
            if max_retries > retries:
                await asyncio.sleep(_retry_timeout(response=response, retries=retries))
                return await self.request(
                    path=path,
                    method=method,
                    base_url=base_url,
                    params=params,
                    json=json,
                    content=content,
                    files=files,
                    headers=headers,
                    request_options=request_options,
                    retries=retries + 1,
                    omit=omit,
                )
        return response

    @asynccontextmanager
    async def stream(
        self,
        path: typing.Optional[str] = None,
        *,
        method: str,
        base_url: typing.Optional[str] = None,
        params: typing.Optional[typing.Dict[str, typing.Any]] = None,
        json: typing.Optional[typing.Any] = None,
        data: typing.Optional[typing.Any] = None,
        content: typing.Optional[typing.Union[bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]]] = None,
        files: typing.Optional[
            typing.Union[
                typing.Dict[str, typing.Optional[typing.Union[File, typing.List[File]]]],
                typing.List[typing.Tuple[str, File]],
            ]
        ] = None,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = None,
        request_options: typing.Optional[RequestOptions] = None,
        retries: int = 2,
        omit: typing.Optional[typing.Any] = None,
        force_multipart: typing.Optional[bool] = None,
    ) -> typing.AsyncIterator[httpx.Response]:
        base_url = self.get_base_url(base_url)
        timeout = (
            request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self.base_timeout()
        )

        request_files: typing.Optional[RequestFiles] = (
            convert_file_dict_to_httpx_tuples(remove_omit_from_dict(remove_none_from_dict(files), omit))
            if (files is not None and files is not omit and isinstance(files, dict))
            else None
        )

        if (request_files is None or len(request_files) == 0) and force_multipart:
            request_files = FORCE_MULTIPART

        json_body, data_body = get_request_body(json=json, data=data, request_options=request_options, omit=omit)

        async with self.httpx_client.stream(
            method=method,
            url=urllib.parse.urljoin(f"{base_url}/", path),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self.base_headers(),
                        **(headers if headers is not None else {}),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        remove_omit_from_dict(
                            {
                                **(params if params is not None else {}),
                                **(
                                    request_options.get("additional_query_parameters", {})
                                    if request_options is not None
                                    else {}
                                ),
                            },
                            omit=omit,
                        )
                    )
                )
            ),
            json=json_body,
            data=data_body,
            content=content,
            files=request_files,
            timeout=timeout,
        ) as stream:
            yield stream

```
</file>
<file path="terra-client-python/src/terra/core/http_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

from typing import Dict, Generic, TypeVar

import httpx

T = TypeVar("T")
"""Generic to represent the underlying type of the data wrapped by the HTTP response."""


class BaseHttpResponse:
    """Minimalist HTTP response wrapper that exposes response headers."""

    _response: httpx.Response

    def __init__(self, response: httpx.Response):
        self._response = response

    @property
    def headers(self) -> Dict[str, str]:
        return dict(self._response.headers)


class HttpResponse(Generic[T], BaseHttpResponse):
    """HTTP response wrapper that exposes response headers and data."""

    _data: T

    def __init__(self, response: httpx.Response, data: T):
        super().__init__(response)
        self._data = data

    @property
    def data(self) -> T:
        return self._data

    def close(self) -> None:
        self._response.close()


class AsyncHttpResponse(Generic[T], BaseHttpResponse):
    """HTTP response wrapper that exposes response headers and data."""

    _data: T

    def __init__(self, response: httpx.Response, data: T):
        super().__init__(response)
        self._data = data

    @property
    def data(self) -> T:
        return self._data

    async def close(self) -> None:
        await self._response.aclose()

```
</file>
<file path="terra-client-python/src/terra/core/jsonable_encoder.py">
```py
# This file was auto-generated by Fern from our API Definition.

"""
jsonable_encoder converts a Python object to a JSON-friendly dict
(e.g. datetimes to strings, Pydantic models to dicts).

Taken from FastAPI, and made a bit simpler
https://github.com/tiangolo/fastapi/blob/master/fastapi/encoders.py
"""

import base64
import dataclasses
import datetime as dt
from enum import Enum
from pathlib import PurePath
from types import GeneratorType
from typing import Any, Callable, Dict, List, Optional, Set, Union

import pydantic
from .datetime_utils import serialize_datetime
from .pydantic_utilities import (
    IS_PYDANTIC_V2,
    encode_by_type,
    to_jsonable_with_fallback,
)

SetIntStr = Set[Union[int, str]]
DictIntStrAny = Dict[Union[int, str], Any]


def jsonable_encoder(obj: Any, custom_encoder: Optional[Dict[Any, Callable[[Any], Any]]] = None) -> Any:
    custom_encoder = custom_encoder or {}
    if custom_encoder:
        if type(obj) in custom_encoder:
            return custom_encoder[type(obj)](obj)
        else:
            for encoder_type, encoder_instance in custom_encoder.items():
                if isinstance(obj, encoder_type):
                    return encoder_instance(obj)
    if isinstance(obj, pydantic.BaseModel):
        if IS_PYDANTIC_V2:
            encoder = getattr(obj.model_config, "json_encoders", {})  # type: ignore # Pydantic v2
        else:
            encoder = getattr(obj.__config__, "json_encoders", {})  # type: ignore # Pydantic v1
        if custom_encoder:
            encoder.update(custom_encoder)
        obj_dict = obj.dict(by_alias=True)
        if "__root__" in obj_dict:
            obj_dict = obj_dict["__root__"]
        if "root" in obj_dict:
            obj_dict = obj_dict["root"]
        return jsonable_encoder(obj_dict, custom_encoder=encoder)
    if dataclasses.is_dataclass(obj):
        obj_dict = dataclasses.asdict(obj)  # type: ignore
        return jsonable_encoder(obj_dict, custom_encoder=custom_encoder)
    if isinstance(obj, bytes):
        return base64.b64encode(obj).decode("utf-8")
    if isinstance(obj, Enum):
        return obj.value
    if isinstance(obj, PurePath):
        return str(obj)
    if isinstance(obj, (str, int, float, type(None))):
        return obj
    if isinstance(obj, dt.datetime):
        return serialize_datetime(obj)
    if isinstance(obj, dt.date):
        return str(obj)
    if isinstance(obj, dict):
        encoded_dict = {}
        allowed_keys = set(obj.keys())
        for key, value in obj.items():
            if key in allowed_keys:
                encoded_key = jsonable_encoder(key, custom_encoder=custom_encoder)
                encoded_value = jsonable_encoder(value, custom_encoder=custom_encoder)
                encoded_dict[encoded_key] = encoded_value
        return encoded_dict
    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple)):
        encoded_list = []
        for item in obj:
            encoded_list.append(jsonable_encoder(item, custom_encoder=custom_encoder))
        return encoded_list

    def fallback_serializer(o: Any) -> Any:
        attempt_encode = encode_by_type(o)
        if attempt_encode is not None:
            return attempt_encode

        try:
            data = dict(o)
        except Exception as e:
            errors: List[Exception] = []
            errors.append(e)
            try:
                data = vars(o)
            except Exception as e:
                errors.append(e)
                raise ValueError(errors) from e
        return jsonable_encoder(data, custom_encoder=custom_encoder)

    return to_jsonable_with_fallback(obj, fallback_serializer)

```
</file>
<file path="terra-client-python/src/terra/core/pydantic_utilities.py">
```py
# This file was auto-generated by Fern from our API Definition.

# nopycln: file
import datetime as dt
from collections import defaultdict
from typing import Any, Callable, ClassVar, Dict, List, Mapping, Optional, Set, Tuple, Type, TypeVar, Union, cast

import pydantic

IS_PYDANTIC_V2 = pydantic.VERSION.startswith("2.")

if IS_PYDANTIC_V2:
    from pydantic.v1.datetime_parse import parse_date as parse_date
    from pydantic.v1.datetime_parse import parse_datetime as parse_datetime
    from pydantic.v1.fields import ModelField as ModelField
    from pydantic.v1.json import ENCODERS_BY_TYPE as encoders_by_type  # type: ignore[attr-defined]
    from pydantic.v1.typing import get_args as get_args
    from pydantic.v1.typing import get_origin as get_origin
    from pydantic.v1.typing import is_literal_type as is_literal_type
    from pydantic.v1.typing import is_union as is_union
else:
    from pydantic.datetime_parse import parse_date as parse_date  # type: ignore[no-redef]
    from pydantic.datetime_parse import parse_datetime as parse_datetime  # type: ignore[no-redef]
    from pydantic.fields import ModelField as ModelField  # type: ignore[attr-defined, no-redef]
    from pydantic.json import ENCODERS_BY_TYPE as encoders_by_type  # type: ignore[no-redef]
    from pydantic.typing import get_args as get_args  # type: ignore[no-redef]
    from pydantic.typing import get_origin as get_origin  # type: ignore[no-redef]
    from pydantic.typing import is_literal_type as is_literal_type  # type: ignore[no-redef]
    from pydantic.typing import is_union as is_union  # type: ignore[no-redef]

from .datetime_utils import serialize_datetime
from .serialization import convert_and_respect_annotation_metadata
from typing_extensions import TypeAlias

T = TypeVar("T")
Model = TypeVar("Model", bound=pydantic.BaseModel)


def parse_obj_as(type_: Type[T], object_: Any) -> T:
    dealiased_object = convert_and_respect_annotation_metadata(object_=object_, annotation=type_, direction="read")
    if IS_PYDANTIC_V2:
        adapter = pydantic.TypeAdapter(type_)  # type: ignore[attr-defined]
        return adapter.validate_python(dealiased_object)
    return pydantic.parse_obj_as(type_, dealiased_object)


def to_jsonable_with_fallback(obj: Any, fallback_serializer: Callable[[Any], Any]) -> Any:
    if IS_PYDANTIC_V2:
        from pydantic_core import to_jsonable_python

        return to_jsonable_python(obj, fallback=fallback_serializer)
    return fallback_serializer(obj)


class UniversalBaseModel(pydantic.BaseModel):
    if IS_PYDANTIC_V2:
        model_config: ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(  # type: ignore[typeddict-unknown-key]
            # Allow fields beginning with `model_` to be used in the model
            protected_namespaces=(),
        )

        @pydantic.model_serializer(mode="wrap", when_used="json")  # type: ignore[attr-defined]
        def serialize_model(self, handler: pydantic.SerializerFunctionWrapHandler) -> Any:  # type: ignore[name-defined]
            serialized = handler(self)
            data = {k: serialize_datetime(v) if isinstance(v, dt.datetime) else v for k, v in serialized.items()}
            return data

    else:

        class Config:
            smart_union = True
            json_encoders = {dt.datetime: serialize_datetime}

    @classmethod
    def model_construct(cls: Type["Model"], _fields_set: Optional[Set[str]] = None, **values: Any) -> "Model":
        dealiased_object = convert_and_respect_annotation_metadata(object_=values, annotation=cls, direction="read")
        return cls.construct(_fields_set, **dealiased_object)

    @classmethod
    def construct(cls: Type["Model"], _fields_set: Optional[Set[str]] = None, **values: Any) -> "Model":
        dealiased_object = convert_and_respect_annotation_metadata(object_=values, annotation=cls, direction="read")
        if IS_PYDANTIC_V2:
            return super().model_construct(_fields_set, **dealiased_object)  # type: ignore[misc]
        return super().construct(_fields_set, **dealiased_object)

    def json(self, **kwargs: Any) -> str:
        kwargs_with_defaults = {
            "by_alias": True,
            "exclude_unset": True,
            **kwargs,
        }
        if IS_PYDANTIC_V2:
            return super().model_dump_json(**kwargs_with_defaults)  # type: ignore[misc]
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Override the default dict method to `exclude_unset` by default. This function patches
        `exclude_unset` to work include fields within non-None default values.
        """
        # Note: the logic here is multiplexed given the levers exposed in Pydantic V1 vs V2
        # Pydantic V1's .dict can be extremely slow, so we do not want to call it twice.
        #
        # We'd ideally do the same for Pydantic V2, but it shells out to a library to serialize models
        # that we have less control over, and this is less intrusive than custom serializers for now.
        if IS_PYDANTIC_V2:
            kwargs_with_defaults_exclude_unset = {
                **kwargs,
                "by_alias": True,
                "exclude_unset": True,
                "exclude_none": False,
            }
            kwargs_with_defaults_exclude_none = {
                **kwargs,
                "by_alias": True,
                "exclude_none": True,
                "exclude_unset": False,
            }
            dict_dump = deep_union_pydantic_dicts(
                super().model_dump(**kwargs_with_defaults_exclude_unset),  # type: ignore[misc]
                super().model_dump(**kwargs_with_defaults_exclude_none),  # type: ignore[misc]
            )

        else:
            _fields_set = self.__fields_set__.copy()

            fields = _get_model_fields(self.__class__)
            for name, field in fields.items():
                if name not in _fields_set:
                    default = _get_field_default(field)

                    # If the default values are non-null act like they've been set
                    # This effectively allows exclude_unset to work like exclude_none where
                    # the latter passes through intentionally set none values.
                    if default is not None or ("exclude_unset" in kwargs and not kwargs["exclude_unset"]):
                        _fields_set.add(name)

                        if default is not None:
                            self.__fields_set__.add(name)

            kwargs_with_defaults_exclude_unset_include_fields = {
                "by_alias": True,
                "exclude_unset": True,
                "include": _fields_set,
                **kwargs,
            }

            dict_dump = super().dict(**kwargs_with_defaults_exclude_unset_include_fields)

        return convert_and_respect_annotation_metadata(object_=dict_dump, annotation=self.__class__, direction="write")


def _union_list_of_pydantic_dicts(source: List[Any], destination: List[Any]) -> List[Any]:
    converted_list: List[Any] = []
    for i, item in enumerate(source):
        destination_value = destination[i]
        if isinstance(item, dict):
            converted_list.append(deep_union_pydantic_dicts(item, destination_value))
        elif isinstance(item, list):
            converted_list.append(_union_list_of_pydantic_dicts(item, destination_value))
        else:
            converted_list.append(item)
    return converted_list


def deep_union_pydantic_dicts(source: Dict[str, Any], destination: Dict[str, Any]) -> Dict[str, Any]:
    for key, value in source.items():
        node = destination.setdefault(key, {})
        if isinstance(value, dict):
            deep_union_pydantic_dicts(value, node)
        # Note: we do not do this same processing for sets given we do not have sets of models
        # and given the sets are unordered, the processing of the set and matching objects would
        # be non-trivial.
        elif isinstance(value, list):
            destination[key] = _union_list_of_pydantic_dicts(value, node)
        else:
            destination[key] = value

    return destination


if IS_PYDANTIC_V2:

    class V2RootModel(UniversalBaseModel, pydantic.RootModel):  # type: ignore[misc, name-defined, type-arg]
        pass

    UniversalRootModel: TypeAlias = V2RootModel  # type: ignore[misc]
else:
    UniversalRootModel: TypeAlias = UniversalBaseModel  # type: ignore[misc, no-redef]


def encode_by_type(o: Any) -> Any:
    encoders_by_class_tuples: Dict[Callable[[Any], Any], Tuple[Any, ...]] = defaultdict(tuple)
    for type_, encoder in encoders_by_type.items():
        encoders_by_class_tuples[encoder] += (type_,)

    if type(o) in encoders_by_type:
        return encoders_by_type[type(o)](o)
    for encoder, classes_tuple in encoders_by_class_tuples.items():
        if isinstance(o, classes_tuple):
            return encoder(o)


def update_forward_refs(model: Type["Model"], **localns: Any) -> None:
    if IS_PYDANTIC_V2:
        model.model_rebuild(raise_errors=False)  # type: ignore[attr-defined]
    else:
        model.update_forward_refs(**localns)


# Mirrors Pydantic's internal typing
AnyCallable = Callable[..., Any]


def universal_root_validator(
    pre: bool = False,
) -> Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        if IS_PYDANTIC_V2:
            return cast(AnyCallable, pydantic.model_validator(mode="before" if pre else "after")(func))  # type: ignore[attr-defined]
        return cast(AnyCallable, pydantic.root_validator(pre=pre)(func))  # type: ignore[call-overload]

    return decorator


def universal_field_validator(field_name: str, pre: bool = False) -> Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        if IS_PYDANTIC_V2:
            return cast(AnyCallable, pydantic.field_validator(field_name, mode="before" if pre else "after")(func))  # type: ignore[attr-defined]
        return cast(AnyCallable, pydantic.validator(field_name, pre=pre)(func))

    return decorator


PydanticField = Union[ModelField, pydantic.fields.FieldInfo]


def _get_model_fields(model: Type["Model"]) -> Mapping[str, PydanticField]:
    if IS_PYDANTIC_V2:
        return cast(Mapping[str, PydanticField], model.model_fields)  # type: ignore[attr-defined]
    return cast(Mapping[str, PydanticField], model.__fields__)


def _get_field_default(field: PydanticField) -> Any:
    try:
        value = field.get_default()  # type: ignore[union-attr]
    except:
        value = field.default
    if IS_PYDANTIC_V2:
        from pydantic_core import PydanticUndefined

        if value == PydanticUndefined:
            return None
        return value
    return value

```
</file>
<file path="terra-client-python/src/terra/core/query_encoder.py">
```py
# This file was auto-generated by Fern from our API Definition.

from typing import Any, Dict, List, Optional, Tuple

import pydantic


# Flattens dicts to be of the form {"key[subkey][subkey2]": value} where value is not a dict
def traverse_query_dict(dict_flat: Dict[str, Any], key_prefix: Optional[str] = None) -> List[Tuple[str, Any]]:
    result = []
    for k, v in dict_flat.items():
        key = f"{key_prefix}[{k}]" if key_prefix is not None else k
        if isinstance(v, dict):
            result.extend(traverse_query_dict(v, key))
        elif isinstance(v, list):
            for arr_v in v:
                if isinstance(arr_v, dict):
                    result.extend(traverse_query_dict(arr_v, key))
                else:
                    result.append((key, arr_v))
        else:
            result.append((key, v))
    return result


def single_query_encoder(query_key: str, query_value: Any) -> List[Tuple[str, Any]]:
    if isinstance(query_value, pydantic.BaseModel) or isinstance(query_value, dict):
        if isinstance(query_value, pydantic.BaseModel):
            obj_dict = query_value.dict(by_alias=True)
        else:
            obj_dict = query_value
        return traverse_query_dict(obj_dict, query_key)
    elif isinstance(query_value, list):
        encoded_values: List[Tuple[str, Any]] = []
        for value in query_value:
            if isinstance(value, pydantic.BaseModel) or isinstance(value, dict):
                if isinstance(value, pydantic.BaseModel):
                    obj_dict = value.dict(by_alias=True)
                elif isinstance(value, dict):
                    obj_dict = value

                encoded_values.extend(single_query_encoder(query_key, obj_dict))
            else:
                encoded_values.append((query_key, value))

        return encoded_values

    return [(query_key, query_value)]


def encode_query(query: Optional[Dict[str, Any]]) -> Optional[List[Tuple[str, Any]]]:
    if query is None:
        return None

    encoded_query = []
    for k, v in query.items():
        encoded_query.extend(single_query_encoder(k, v))
    return encoded_query

```
</file>
<file path="terra-client-python/src/terra/core/remove_none_from_dict.py">
```py
# This file was auto-generated by Fern from our API Definition.

from typing import Any, Dict, Mapping, Optional


def remove_none_from_dict(original: Mapping[str, Optional[Any]]) -> Dict[str, Any]:
    new: Dict[str, Any] = {}
    for key, value in original.items():
        if value is not None:
            new[key] = value
    return new

```
</file>
<file path="terra-client-python/src/terra/core/request_options.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

try:
    from typing import NotRequired  # type: ignore
except ImportError:
    from typing_extensions import NotRequired


class RequestOptions(typing.TypedDict, total=False):
    """
    Additional options for request-specific configuration when calling APIs via the SDK.
    This is used primarily as an optional final parameter for service functions.

    Attributes:
        - timeout_in_seconds: int. The number of seconds to await an API call before timing out.

        - max_retries: int. The max number of retries to attempt if the API call fails.

        - additional_headers: typing.Dict[str, typing.Any]. A dictionary containing additional parameters to spread into the request's header dict

        - additional_query_parameters: typing.Dict[str, typing.Any]. A dictionary containing additional parameters to spread into the request's query parameters dict

        - additional_body_parameters: typing.Dict[str, typing.Any]. A dictionary containing additional parameters to spread into the request's body parameters dict

        - chunk_size: int. The size, in bytes, to process each chunk of data being streamed back within the response. This equates to leveraging `chunk_size` within `requests` or `httpx`, and is only leveraged for file downloads.
    """

    timeout_in_seconds: NotRequired[int]
    max_retries: NotRequired[int]
    additional_headers: NotRequired[typing.Dict[str, typing.Any]]
    additional_query_parameters: NotRequired[typing.Dict[str, typing.Any]]
    additional_body_parameters: NotRequired[typing.Dict[str, typing.Any]]
    chunk_size: NotRequired[int]

```
</file>
<file path="terra-client-python/src/terra/core/serialization.py">
```py
# This file was auto-generated by Fern from our API Definition.

import collections
import inspect
import typing

import pydantic
import typing_extensions


class FieldMetadata:
    """
    Metadata class used to annotate fields to provide additional information.

    Example:
    class MyDict(TypedDict):
        field: typing.Annotated[str, FieldMetadata(alias="field_name")]

    Will serialize: `{"field": "value"}`
    To: `{"field_name": "value"}`
    """

    alias: str

    def __init__(self, *, alias: str) -> None:
        self.alias = alias


def convert_and_respect_annotation_metadata(
    *,
    object_: typing.Any,
    annotation: typing.Any,
    inner_type: typing.Optional[typing.Any] = None,
    direction: typing.Literal["read", "write"],
) -> typing.Any:
    """
    Respect the metadata annotations on a field, such as aliasing. This function effectively
    manipulates the dict-form of an object to respect the metadata annotations. This is primarily used for
    TypedDicts, which cannot support aliasing out of the box, and can be extended for additional
    utilities, such as defaults.

    Parameters
    ----------
    object_ : typing.Any

    annotation : type
        The type we're looking to apply typing annotations from

    inner_type : typing.Optional[type]

    Returns
    -------
    typing.Any
    """

    if object_ is None:
        return None
    if inner_type is None:
        inner_type = annotation

    clean_type = _remove_annotations(inner_type)
    # Pydantic models
    if (
        inspect.isclass(clean_type)
        and issubclass(clean_type, pydantic.BaseModel)
        and isinstance(object_, typing.Mapping)
    ):
        return _convert_mapping(object_, clean_type, direction)
    # TypedDicts
    if typing_extensions.is_typeddict(clean_type) and isinstance(object_, typing.Mapping):
        return _convert_mapping(object_, clean_type, direction)

    if (
        typing_extensions.get_origin(clean_type) == typing.Dict
        or typing_extensions.get_origin(clean_type) == dict
        or clean_type == typing.Dict
    ) and isinstance(object_, typing.Dict):
        key_type = typing_extensions.get_args(clean_type)[0]
        value_type = typing_extensions.get_args(clean_type)[1]

        return {
            key: convert_and_respect_annotation_metadata(
                object_=value,
                annotation=annotation,
                inner_type=value_type,
                direction=direction,
            )
            for key, value in object_.items()
        }

    # If you're iterating on a string, do not bother to coerce it to a sequence.
    if not isinstance(object_, str):
        if (
            typing_extensions.get_origin(clean_type) == typing.Set
            or typing_extensions.get_origin(clean_type) == set
            or clean_type == typing.Set
        ) and isinstance(object_, typing.Set):
            inner_type = typing_extensions.get_args(clean_type)[0]
            return {
                convert_and_respect_annotation_metadata(
                    object_=item,
                    annotation=annotation,
                    inner_type=inner_type,
                    direction=direction,
                )
                for item in object_
            }
        elif (
            (
                typing_extensions.get_origin(clean_type) == typing.List
                or typing_extensions.get_origin(clean_type) == list
                or clean_type == typing.List
            )
            and isinstance(object_, typing.List)
        ) or (
            (
                typing_extensions.get_origin(clean_type) == typing.Sequence
                or typing_extensions.get_origin(clean_type) == collections.abc.Sequence
                or clean_type == typing.Sequence
            )
            and isinstance(object_, typing.Sequence)
        ):
            inner_type = typing_extensions.get_args(clean_type)[0]
            return [
                convert_and_respect_annotation_metadata(
                    object_=item,
                    annotation=annotation,
                    inner_type=inner_type,
                    direction=direction,
                )
                for item in object_
            ]

    if typing_extensions.get_origin(clean_type) == typing.Union:
        # We should be able to ~relatively~ safely try to convert keys against all
        # member types in the union, the edge case here is if one member aliases a field
        # of the same name to a different name from another member
        # Or if another member aliases a field of the same name that another member does not.
        for member in typing_extensions.get_args(clean_type):
            object_ = convert_and_respect_annotation_metadata(
                object_=object_,
                annotation=annotation,
                inner_type=member,
                direction=direction,
            )
        return object_

    annotated_type = _get_annotation(annotation)
    if annotated_type is None:
        return object_

    # If the object is not a TypedDict, a Union, or other container (list, set, sequence, etc.)
    # Then we can safely call it on the recursive conversion.
    return object_


def _convert_mapping(
    object_: typing.Mapping[str, object],
    expected_type: typing.Any,
    direction: typing.Literal["read", "write"],
) -> typing.Mapping[str, object]:
    converted_object: typing.Dict[str, object] = {}
    try:
        annotations = typing_extensions.get_type_hints(expected_type, include_extras=True)
    except NameError:
        # The TypedDict contains a circular reference, so
        # we use the __annotations__ attribute directly.
        annotations = getattr(expected_type, "__annotations__", {})
    aliases_to_field_names = _get_alias_to_field_name(annotations)
    for key, value in object_.items():
        if direction == "read" and key in aliases_to_field_names:
            dealiased_key = aliases_to_field_names.get(key)
            if dealiased_key is not None:
                type_ = annotations.get(dealiased_key)
        else:
            type_ = annotations.get(key)
        # Note you can't get the annotation by the field name if you're in read mode, so you must check the aliases map
        #
        # So this is effectively saying if we're in write mode, and we don't have a type, or if we're in read mode and we don't have an alias
        # then we can just pass the value through as is
        if type_ is None:
            converted_object[key] = value
        elif direction == "read" and key not in aliases_to_field_names:
            converted_object[key] = convert_and_respect_annotation_metadata(
                object_=value, annotation=type_, direction=direction
            )
        else:
            converted_object[_alias_key(key, type_, direction, aliases_to_field_names)] = (
                convert_and_respect_annotation_metadata(object_=value, annotation=type_, direction=direction)
            )
    return converted_object


def _get_annotation(type_: typing.Any) -> typing.Optional[typing.Any]:
    maybe_annotated_type = typing_extensions.get_origin(type_)
    if maybe_annotated_type is None:
        return None

    if maybe_annotated_type == typing_extensions.NotRequired:
        type_ = typing_extensions.get_args(type_)[0]
        maybe_annotated_type = typing_extensions.get_origin(type_)

    if maybe_annotated_type == typing_extensions.Annotated:
        return type_

    return None


def _remove_annotations(type_: typing.Any) -> typing.Any:
    maybe_annotated_type = typing_extensions.get_origin(type_)
    if maybe_annotated_type is None:
        return type_

    if maybe_annotated_type == typing_extensions.NotRequired:
        return _remove_annotations(typing_extensions.get_args(type_)[0])

    if maybe_annotated_type == typing_extensions.Annotated:
        return _remove_annotations(typing_extensions.get_args(type_)[0])

    return type_


def get_alias_to_field_mapping(type_: typing.Any) -> typing.Dict[str, str]:
    annotations = typing_extensions.get_type_hints(type_, include_extras=True)
    return _get_alias_to_field_name(annotations)


def get_field_to_alias_mapping(type_: typing.Any) -> typing.Dict[str, str]:
    annotations = typing_extensions.get_type_hints(type_, include_extras=True)
    return _get_field_to_alias_name(annotations)


def _get_alias_to_field_name(
    field_to_hint: typing.Dict[str, typing.Any],
) -> typing.Dict[str, str]:
    aliases = {}
    for field, hint in field_to_hint.items():
        maybe_alias = _get_alias_from_type(hint)
        if maybe_alias is not None:
            aliases[maybe_alias] = field
    return aliases


def _get_field_to_alias_name(
    field_to_hint: typing.Dict[str, typing.Any],
) -> typing.Dict[str, str]:
    aliases = {}
    for field, hint in field_to_hint.items():
        maybe_alias = _get_alias_from_type(hint)
        if maybe_alias is not None:
            aliases[field] = maybe_alias
    return aliases


def _get_alias_from_type(type_: typing.Any) -> typing.Optional[str]:
    maybe_annotated_type = _get_annotation(type_)

    if maybe_annotated_type is not None:
        # The actual annotations are 1 onward, the first is the annotated type
        annotations = typing_extensions.get_args(maybe_annotated_type)[1:]

        for annotation in annotations:
            if isinstance(annotation, FieldMetadata) and annotation.alias is not None:
                return annotation.alias
    return None


def _alias_key(
    key: str,
    type_: typing.Any,
    direction: typing.Literal["read", "write"],
    aliases_to_field_names: typing.Dict[str, str],
) -> str:
    if direction == "read":
        return aliases_to_field_names.get(key, key)
    return _get_alias_from_type(type_=type_) or key

```
</file>
<file path="terra-client-python/src/terra/core/unchecked_base_model.py">
```py
# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import inspect
import typing
import uuid

import pydantic
import typing_extensions
from .pydantic_utilities import (
    IS_PYDANTIC_V2,
    ModelField,
    UniversalBaseModel,
    get_args,
    get_origin,
    is_literal_type,
    is_union,
    parse_date,
    parse_datetime,
    parse_obj_as,
)
from .serialization import get_field_to_alias_mapping
from pydantic_core import PydanticUndefined


class UnionMetadata:
    discriminant: str

    def __init__(self, *, discriminant: str) -> None:
        self.discriminant = discriminant


Model = typing.TypeVar("Model", bound=pydantic.BaseModel)


class UncheckedBaseModel(UniversalBaseModel):
    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow

    @classmethod
    def model_construct(
        cls: typing.Type["Model"],
        _fields_set: typing.Optional[typing.Set[str]] = None,
        **values: typing.Any,
    ) -> "Model":
        # Fallback construct function to the specified override below.
        return cls.construct(_fields_set=_fields_set, **values)

    # Allow construct to not validate model
    # Implementation taken from: https://github.com/pydantic/pydantic/issues/1168#issuecomment-817742836
    @classmethod
    def construct(
        cls: typing.Type["Model"],
        _fields_set: typing.Optional[typing.Set[str]] = None,
        **values: typing.Any,
    ) -> "Model":
        m = cls.__new__(cls)
        fields_values = {}

        if _fields_set is None:
            _fields_set = set(values.keys())

        fields = _get_model_fields(cls)
        populate_by_name = _get_is_populate_by_name(cls)
        field_aliases = get_field_to_alias_mapping(cls)

        for name, field in fields.items():
            # Key here is only used to pull data from the values dict
            # you should always use the NAME of the field to for field_values, etc.
            # because that's how the object is constructed from a pydantic perspective
            key = field.alias
            if (key is None or field.alias == name) and name in field_aliases:
                key = field_aliases[name]

            if key is None or (key not in values and populate_by_name):  # Added this to allow population by field name
                key = name

            if key in values:
                if IS_PYDANTIC_V2:
                    type_ = field.annotation  # type: ignore # Pydantic v2
                else:
                    type_ = typing.cast(typing.Type, field.outer_type_)  # type: ignore # Pydantic < v1.10.15

                fields_values[name] = (
                    construct_type(object_=values[key], type_=type_) if type_ is not None else values[key]
                )
                _fields_set.add(name)
            else:
                default = _get_field_default(field)
                fields_values[name] = default

                # If the default values are non-null act like they've been set
                # This effectively allows exclude_unset to work like exclude_none where
                # the latter passes through intentionally set none values.
                if default != None and default != PydanticUndefined:
                    _fields_set.add(name)

        # Add extras back in
        extras = {}
        pydantic_alias_fields = [field.alias for field in fields.values()]
        internal_alias_fields = list(field_aliases.values())
        for key, value in values.items():
            # If the key is not a field by name, nor an alias to a field, then it's extra
            if (key not in pydantic_alias_fields and key not in internal_alias_fields) and key not in fields:
                if IS_PYDANTIC_V2:
                    extras[key] = value
                else:
                    _fields_set.add(key)
                    fields_values[key] = value

        object.__setattr__(m, "__dict__", fields_values)

        if IS_PYDANTIC_V2:
            object.__setattr__(m, "__pydantic_private__", None)
            object.__setattr__(m, "__pydantic_extra__", extras)
            object.__setattr__(m, "__pydantic_fields_set__", _fields_set)
        else:
            object.__setattr__(m, "__fields_set__", _fields_set)
            m._init_private_attributes()  # type: ignore # Pydantic v1
        return m


def _convert_undiscriminated_union_type(union_type: typing.Type[typing.Any], object_: typing.Any) -> typing.Any:
    inner_types = get_args(union_type)
    if typing.Any in inner_types:
        return object_

    for inner_type in inner_types:
        try:
            if inspect.isclass(inner_type) and issubclass(inner_type, pydantic.BaseModel):
                # Attempt a validated parse until one works
                return parse_obj_as(inner_type, object_)
        except Exception:
            continue

    # If none of the types work, just return the first successful cast
    for inner_type in inner_types:
        try:
            return construct_type(object_=object_, type_=inner_type)
        except Exception:
            continue


def _convert_union_type(type_: typing.Type[typing.Any], object_: typing.Any) -> typing.Any:
    base_type = get_origin(type_) or type_
    union_type = type_
    if base_type == typing_extensions.Annotated:
        union_type = get_args(type_)[0]
        annotated_metadata = get_args(type_)[1:]
        for metadata in annotated_metadata:
            if isinstance(metadata, UnionMetadata):
                try:
                    # Cast to the correct type, based on the discriminant
                    for inner_type in get_args(union_type):
                        try:
                            objects_discriminant = getattr(object_, metadata.discriminant)
                        except:
                            objects_discriminant = object_[metadata.discriminant]
                        if inner_type.__fields__[metadata.discriminant].default == objects_discriminant:
                            return construct_type(object_=object_, type_=inner_type)
                except Exception:
                    # Allow to fall through to our regular union handling
                    pass
    return _convert_undiscriminated_union_type(union_type, object_)


def construct_type(*, type_: typing.Type[typing.Any], object_: typing.Any) -> typing.Any:
    """
    Here we are essentially creating the same `construct` method in spirit as the above, but for all types, not just
    Pydantic models.
    The idea is to essentially attempt to coerce object_ to type_ (recursively)
    """
    # Short circuit when dealing with optionals, don't try to coerces None to a type
    if object_ is None:
        return None

    base_type = get_origin(type_) or type_
    is_annotated = base_type == typing_extensions.Annotated
    maybe_annotation_members = get_args(type_)
    is_annotated_union = is_annotated and is_union(get_origin(maybe_annotation_members[0]))

    if base_type == typing.Any:
        return object_

    if base_type == dict:
        if not isinstance(object_, typing.Mapping):
            return object_

        key_type, items_type = get_args(type_)
        d = {
            construct_type(object_=key, type_=key_type): construct_type(object_=item, type_=items_type)
            for key, item in object_.items()
        }
        return d

    if base_type == list:
        if not isinstance(object_, list):
            return object_

        inner_type = get_args(type_)[0]
        return [construct_type(object_=entry, type_=inner_type) for entry in object_]

    if base_type == set:
        if not isinstance(object_, set) and not isinstance(object_, list):
            return object_

        inner_type = get_args(type_)[0]
        return {construct_type(object_=entry, type_=inner_type) for entry in object_}

    if is_union(base_type) or is_annotated_union:
        return _convert_union_type(type_, object_)

    # Cannot do an `issubclass` with a literal type, let's also just confirm we have a class before this call
    if (
        object_ is not None
        and not is_literal_type(type_)
        and (
            (inspect.isclass(base_type) and issubclass(base_type, pydantic.BaseModel))
            or (
                is_annotated
                and inspect.isclass(maybe_annotation_members[0])
                and issubclass(maybe_annotation_members[0], pydantic.BaseModel)
            )
        )
    ):
        if IS_PYDANTIC_V2:
            return type_.model_construct(**object_)
        else:
            return type_.construct(**object_)

    if base_type == dt.datetime:
        try:
            return parse_datetime(object_)
        except Exception:
            return object_

    if base_type == dt.date:
        try:
            return parse_date(object_)
        except Exception:
            return object_

    if base_type == uuid.UUID:
        try:
            return uuid.UUID(object_)
        except Exception:
            return object_

    if base_type == int:
        try:
            return int(object_)
        except Exception:
            return object_

    if base_type == bool:
        try:
            if isinstance(object_, str):
                stringified_object = object_.lower()
                return stringified_object == "true" or stringified_object == "1"

            return bool(object_)
        except Exception:
            return object_

    return object_


def _get_is_populate_by_name(model: typing.Type["Model"]) -> bool:
    if IS_PYDANTIC_V2:
        return model.model_config.get("populate_by_name", False)  # type: ignore # Pydantic v2
    return model.__config__.allow_population_by_field_name  # type: ignore # Pydantic v1


PydanticField = typing.Union[ModelField, pydantic.fields.FieldInfo]


# Pydantic V1 swapped the typing of __fields__'s values from ModelField to FieldInfo
# And so we try to handle both V1 cases, as well as V2 (FieldInfo from model.model_fields)
def _get_model_fields(
    model: typing.Type["Model"],
) -> typing.Mapping[str, PydanticField]:
    if IS_PYDANTIC_V2:
        return model.model_fields  # type: ignore # Pydantic v2
    else:
        return model.__fields__  # type: ignore # Pydantic v1


def _get_field_default(field: PydanticField) -> typing.Any:
    try:
        value = field.get_default()  # type: ignore # Pydantic < v1.10.15
    except:
        value = field.default
    if IS_PYDANTIC_V2:
        from pydantic_core import PydanticUndefined

        if value == PydanticUndefined:
            return None
        return value
    return value

```
</file>
<file path="terra-client-python/src/terra/daily/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/daily/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from .raw_client import AsyncRawDailyClient, RawDailyClient
from .types.daily_fetch_request_start_date import DailyFetchRequestStartDate
from .types.daily_fetch_response import DailyFetchResponse


class DailyClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawDailyClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawDailyClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawDailyClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: DailyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DailyFetchResponse:
        """
        Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : DailyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DailyFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.daily.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data


class AsyncDailyClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawDailyClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawDailyClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawDailyClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: DailyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DailyFetchResponse:
        """
        Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : DailyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DailyFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.daily.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/daily/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from .types.daily_fetch_request_start_date import DailyFetchRequestStartDate
from .types.daily_fetch_response import DailyFetchResponse


class RawDailyClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: DailyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DailyFetchResponse]:
        """
        Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : DailyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DailyFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "daily",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DailyFetchResponse,
                    construct_type(
                        type_=DailyFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawDailyClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: DailyFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DailyFetchResponse]:
        """
        Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : DailyFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DailyFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "daily",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DailyFetchResponse,
                    construct_type(
                        type_=DailyFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/daily/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/daily/types/daily_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

DailyFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/daily/types/daily_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.large_request_processing_event import LargeRequestProcessingEvent
from ...types.no_data_returned import NoDataReturned
from ...types.rate_limit_request_processing import RateLimitRequestProcessing
from ...types.request_processing import RequestProcessing
from .daily_fetch_response_data import DailyFetchResponseData

DailyFetchResponse = typing.Union[
    DailyFetchResponseData,
    NoDataReturned,
    DataSentToWebhook,
    RequestProcessing,
    RateLimitRequestProcessing,
    LargeRequestProcessingEvent,
]

```
</file>
<file path="terra-client-python/src/terra/daily/types/daily_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.daily import Daily
from ...types.terra_user import TerraUser


class DailyFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[Daily]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/environment.py">
```py
# This file was auto-generated by Fern from our API Definition.

import enum


class TerraEnvironment(enum.Enum):
    DEFAULT = "https://api.tryterra.co/v2"

```
</file>
<file path="terra-client-python/src/terra/errors/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/errors/bad_request_error.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.api_error import ApiError


class BadRequestError(ApiError):
    def __init__(self, body: typing.Optional[typing.Any], headers: typing.Optional[typing.Dict[str, str]] = None):
        super().__init__(status_code=400, headers=headers, body=body)

```
</file>
<file path="terra-client-python/src/terra/errors/not_found_error.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.api_error import ApiError


class NotFoundError(ApiError):
    def __init__(self, body: typing.Optional[typing.Any], headers: typing.Optional[typing.Dict[str, str]] = None):
        super().__init__(status_code=404, headers=headers, body=body)

```
</file>
<file path="terra-client-python/src/terra/errors/unauthorized_error.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.api_error import ApiError


class UnauthorizedError(ApiError):
    def __init__(self, body: typing.Optional[typing.Any], headers: typing.Optional[typing.Dict[str, str]] = None):
        super().__init__(status_code=401, headers=headers, body=body)

```
</file>
<file path="terra-client-python/src/terra/integrations/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/integrations/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.integrations_response import IntegrationsResponse
from .raw_client import AsyncRawIntegrationsClient, RawIntegrationsClient
from .types.integrations_fetch_response import IntegrationsFetchResponse


class IntegrationsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawIntegrationsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawIntegrationsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawIntegrationsClient
        """
        return self._raw_client

    def fetch(self, *, request_options: typing.Optional[RequestOptions] = None) -> IntegrationsFetchResponse:
        """
        Retrieve a list of all available provider integrations on the API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IntegrationsFetchResponse
            Returns list of all available integrations on the API

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.integrations.fetch()
        """
        _response = self._raw_client.fetch(request_options=request_options)
        return _response.data

    def detailedfetch(
        self, *, sdk: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> IntegrationsResponse:
        """
        Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.

        Parameters
        ----------
        sdk : typing.Optional[bool]
            If `true`, allows SDK integrations to be included in the response.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IntegrationsResponse
            Successful response containing a list of integrations.

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.integrations.detailedfetch()
        """
        _response = self._raw_client.detailedfetch(sdk=sdk, request_options=request_options)
        return _response.data


class AsyncIntegrationsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawIntegrationsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawIntegrationsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawIntegrationsClient
        """
        return self._raw_client

    async def fetch(self, *, request_options: typing.Optional[RequestOptions] = None) -> IntegrationsFetchResponse:
        """
        Retrieve a list of all available provider integrations on the API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IntegrationsFetchResponse
            Returns list of all available integrations on the API

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.integrations.fetch()


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(request_options=request_options)
        return _response.data

    async def detailedfetch(
        self, *, sdk: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> IntegrationsResponse:
        """
        Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.

        Parameters
        ----------
        sdk : typing.Optional[bool]
            If `true`, allows SDK integrations to be included in the response.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IntegrationsResponse
            Successful response containing a list of integrations.

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.integrations.detailedfetch()


        asyncio.run(main())
        """
        _response = await self._raw_client.detailedfetch(sdk=sdk, request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/integrations/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..types.integrations_response import IntegrationsResponse
from .types.integrations_fetch_response import IntegrationsFetchResponse


class RawIntegrationsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[IntegrationsFetchResponse]:
        """
        Retrieve a list of all available provider integrations on the API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IntegrationsFetchResponse]
            Returns list of all available integrations on the API
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IntegrationsFetchResponse,
                    construct_type(
                        type_=IntegrationsFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def detailedfetch(
        self, *, sdk: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[IntegrationsResponse]:
        """
        Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.

        Parameters
        ----------
        sdk : typing.Optional[bool]
            If `true`, allows SDK integrations to be included in the response.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IntegrationsResponse]
            Successful response containing a list of integrations.
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/detailed",
            method="GET",
            params={
                "sdk": sdk,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IntegrationsResponse,
                    construct_type(
                        type_=IntegrationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawIntegrationsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[IntegrationsFetchResponse]:
        """
        Retrieve a list of all available provider integrations on the API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IntegrationsFetchResponse]
            Returns list of all available integrations on the API
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IntegrationsFetchResponse,
                    construct_type(
                        type_=IntegrationsFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def detailedfetch(
        self, *, sdk: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[IntegrationsResponse]:
        """
        Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.

        Parameters
        ----------
        sdk : typing.Optional[bool]
            If `true`, allows SDK integrations to be included in the response.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IntegrationsResponse]
            Successful response containing a list of integrations.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/detailed",
            method="GET",
            params={
                "sdk": sdk,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IntegrationsResponse,
                    construct_type(
                        type_=IntegrationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/integrations/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/integrations/types/integrations_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from .integrations_fetch_response_status import IntegrationsFetchResponseStatus


class IntegrationsFetchResponse(UncheckedBaseModel):
    providers: typing.Optional[typing.List[str]] = None
    sdk_resource: typing.Optional[typing.List[str]] = None
    status: typing.Optional[IntegrationsFetchResponseStatus] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/integrations/types/integrations_fetch_response_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

IntegrationsFetchResponseStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/menstruation/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/menstruation/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from .raw_client import AsyncRawMenstruationClient, RawMenstruationClient
from .types.menstruation_fetch_request_start_date import MenstruationFetchRequestStartDate
from .types.menstruation_fetch_response import MenstruationFetchResponse


class MenstruationClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawMenstruationClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawMenstruationClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawMenstruationClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: MenstruationFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> MenstruationFetchResponse:
        """
        Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : MenstruationFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        MenstruationFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.menstruation.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data


class AsyncMenstruationClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawMenstruationClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawMenstruationClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawMenstruationClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: MenstruationFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> MenstruationFetchResponse:
        """
        Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : MenstruationFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        MenstruationFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.menstruation.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/menstruation/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from .types.menstruation_fetch_request_start_date import MenstruationFetchRequestStartDate
from .types.menstruation_fetch_response import MenstruationFetchResponse


class RawMenstruationClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: MenstruationFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[MenstruationFetchResponse]:
        """
        Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : MenstruationFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[MenstruationFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "menstruation",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MenstruationFetchResponse,
                    construct_type(
                        type_=MenstruationFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawMenstruationClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: MenstruationFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[MenstruationFetchResponse]:
        """
        Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : MenstruationFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[MenstruationFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "menstruation",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MenstruationFetchResponse,
                    construct_type(
                        type_=MenstruationFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/menstruation/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/menstruation/types/menstruation_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

MenstruationFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/menstruation/types/menstruation_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.large_request_processing_event import LargeRequestProcessingEvent
from ...types.no_data_returned import NoDataReturned
from ...types.rate_limit_request_processing import RateLimitRequestProcessing
from ...types.request_processing import RequestProcessing
from .menstruation_fetch_response_data import MenstruationFetchResponseData

MenstruationFetchResponse = typing.Union[
    MenstruationFetchResponseData,
    NoDataReturned,
    DataSentToWebhook,
    RequestProcessing,
    RateLimitRequestProcessing,
    LargeRequestProcessingEvent,
]

```
</file>
<file path="terra-client-python/src/terra/menstruation/types/menstruation_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.menstruation import Menstruation
from ...types.terra_user import TerraUser


class MenstruationFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[Menstruation]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/nutrition/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/nutrition/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.nutrition import Nutrition
from .raw_client import AsyncRawNutritionClient, RawNutritionClient
from .types.nutrition_delete_response import NutritionDeleteResponse
from .types.nutrition_fetch_request_start_date import NutritionFetchRequestStartDate
from .types.nutrition_fetch_response import NutritionFetchResponse
from .types.nutrition_write_response import NutritionWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class NutritionClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawNutritionClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawNutritionClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawNutritionClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: NutritionFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> NutritionFetchResponse:
        """
        Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : NutritionFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NutritionFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.nutrition.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

    def write(
        self, *, data: typing.Sequence[Nutrition], request_options: typing.Optional[RequestOptions] = None
    ) -> NutritionWriteResponse:
        """
        Used to post nutrition logs to a provider. This endpoint only works for users connected via Fitbit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Nutrition]
            Nutrition entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NutritionWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        from terra import Nutrition, NutritionMetadata, Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.nutrition.write(
            data=[
                Nutrition(
                    metadata=NutritionMetadata(
                        end_time="2022-10-28T10:00:00.000000+01:00",
                        start_time="1999-11-23T09:00:00.000000+02:00",
                    ),
                )
            ],
        )
        """
        _response = self._raw_client.write(data=data, request_options=request_options)
        return _response.data

    def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> NutritionDeleteResponse:
        """
        Used to delete nutrition logs the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for nutrition entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NutritionDeleteResponse
            Returned when all records were deleted successfully

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.nutrition.delete(
            user_id="user_id",
        )
        """
        _response = self._raw_client.delete(user_id=user_id, data=data, request_options=request_options)
        return _response.data


class AsyncNutritionClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawNutritionClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawNutritionClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawNutritionClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: NutritionFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> NutritionFetchResponse:
        """
        Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : NutritionFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NutritionFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.nutrition.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

    async def write(
        self, *, data: typing.Sequence[Nutrition], request_options: typing.Optional[RequestOptions] = None
    ) -> NutritionWriteResponse:
        """
        Used to post nutrition logs to a provider. This endpoint only works for users connected via Fitbit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Nutrition]
            Nutrition entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NutritionWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        import asyncio

        from terra import AsyncTerra, Nutrition, NutritionMetadata

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.nutrition.write(
                data=[
                    Nutrition(
                        metadata=NutritionMetadata(
                            end_time="2022-10-28T10:00:00.000000+01:00",
                            start_time="1999-11-23T09:00:00.000000+02:00",
                        ),
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.write(data=data, request_options=request_options)
        return _response.data

    async def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> NutritionDeleteResponse:
        """
        Used to delete nutrition logs the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for nutrition entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NutritionDeleteResponse
            Returned when all records were deleted successfully

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.nutrition.delete(
                user_id="user_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete(user_id=user_id, data=data, request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/nutrition/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.nutrition import Nutrition
from .types.nutrition_delete_response import NutritionDeleteResponse
from .types.nutrition_fetch_request_start_date import NutritionFetchRequestStartDate
from .types.nutrition_fetch_response import NutritionFetchResponse
from .types.nutrition_write_response import NutritionWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawNutritionClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: NutritionFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[NutritionFetchResponse]:
        """
        Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : NutritionFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[NutritionFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "nutrition",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NutritionFetchResponse,
                    construct_type(
                        type_=NutritionFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def write(
        self, *, data: typing.Sequence[Nutrition], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[NutritionWriteResponse]:
        """
        Used to post nutrition logs to a provider. This endpoint only works for users connected via Fitbit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Nutrition]
            Nutrition entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[NutritionWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = self._client_wrapper.httpx_client.request(
            "nutrition",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[Nutrition], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NutritionWriteResponse,
                    construct_type(
                        type_=NutritionWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[NutritionDeleteResponse]:
        """
        Used to delete nutrition logs the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for nutrition entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[NutritionDeleteResponse]
            Returned when all records were deleted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "nutrition",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NutritionDeleteResponse,
                    construct_type(
                        type_=NutritionDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawNutritionClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: NutritionFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[NutritionFetchResponse]:
        """
        Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : NutritionFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[NutritionFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "nutrition",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NutritionFetchResponse,
                    construct_type(
                        type_=NutritionFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def write(
        self, *, data: typing.Sequence[Nutrition], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[NutritionWriteResponse]:
        """
        Used to post nutrition logs to a provider. This endpoint only works for users connected via Fitbit. Returns error for other providers.

        Parameters
        ----------
        data : typing.Sequence[Nutrition]
            Nutrition entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[NutritionWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = await self._client_wrapper.httpx_client.request(
            "nutrition",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[Nutrition], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NutritionWriteResponse,
                    construct_type(
                        type_=NutritionWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[NutritionDeleteResponse]:
        """
        Used to delete nutrition logs the user has registered on their account

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for nutrition entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[NutritionDeleteResponse]
            Returned when all records were deleted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "nutrition",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NutritionDeleteResponse,
                    construct_type(
                        type_=NutritionDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/nutrition/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/nutrition/types/nutrition_delete_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser
from .nutrition_delete_response_processed_data_item import NutritionDeleteResponseProcessedDataItem


class NutritionDeleteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    processed_data: typing.Optional[typing.List[NutritionDeleteResponseProcessedDataItem]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/nutrition/types/nutrition_delete_response_processed_data_item.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel


class NutritionDeleteResponseProcessedDataItem(UncheckedBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Identifier of the nutrition log whose deletion was attempted
    """

    response_code: typing.Optional[int] = pydantic.Field(default=None)
    """
    Response code from the provider when attempting to delete the nutrition log
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/nutrition/types/nutrition_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

NutritionFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/nutrition/types/nutrition_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.large_request_processing_event import LargeRequestProcessingEvent
from ...types.no_data_returned import NoDataReturned
from ...types.rate_limit_request_processing import RateLimitRequestProcessing
from ...types.request_processing import RequestProcessing
from .nutrition_fetch_response_data import NutritionFetchResponseData

NutritionFetchResponse = typing.Union[
    NutritionFetchResponseData,
    NoDataReturned,
    DataSentToWebhook,
    RequestProcessing,
    RateLimitRequestProcessing,
    LargeRequestProcessingEvent,
]

```
</file>
<file path="terra-client-python/src/terra/nutrition/types/nutrition_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.nutrition import Nutrition
from ...types.terra_user import TerraUser


class NutritionFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[Nutrition]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/nutrition/types/nutrition_write_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser


class NutritionWriteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    log_ids: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB]
    """

    message: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/plannedworkout/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.planned_workout import PlannedWorkout
from .raw_client import AsyncRawPlannedworkoutClient, RawPlannedworkoutClient
from .types.planned_workout_delete_response import PlannedWorkoutDeleteResponse
from .types.planned_workout_fetch_request_start_date import PlannedWorkoutFetchRequestStartDate
from .types.planned_workout_fetch_response import PlannedWorkoutFetchResponse
from .types.planned_workout_write_response import PlannedWorkoutWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class PlannedworkoutClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawPlannedworkoutClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawPlannedworkoutClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawPlannedworkoutClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: PlannedWorkoutFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PlannedWorkoutFetchResponse:
        """
        Used to get workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : PlannedWorkoutFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PlannedWorkoutFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.plannedworkout.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            request_options=request_options,
        )
        return _response.data

    def write(
        self, *, data: typing.Sequence[PlannedWorkout], request_options: typing.Optional[RequestOptions] = None
    ) -> PlannedWorkoutWriteResponse:
        """
        Used to post workout plans users can follow on their wearable. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        data : typing.Sequence[PlannedWorkout]
            PlannedWorkout entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PlannedWorkoutWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        from terra import PlannedWorkout, Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.plannedworkout.write(
            data=[PlannedWorkout()],
        )
        """
        _response = self._raw_client.write(data=data, request_options=request_options)
        return _response.data

    def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PlannedWorkoutDeleteResponse:
        """
        Used to delete workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for planned workout entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PlannedWorkoutDeleteResponse
            Returned when all records were deleted successfully

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.plannedworkout.delete(
            user_id="user_id",
        )
        """
        _response = self._raw_client.delete(user_id=user_id, data=data, request_options=request_options)
        return _response.data


class AsyncPlannedworkoutClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawPlannedworkoutClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawPlannedworkoutClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawPlannedworkoutClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: PlannedWorkoutFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PlannedWorkoutFetchResponse:
        """
        Used to get workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : PlannedWorkoutFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PlannedWorkoutFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.plannedworkout.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            request_options=request_options,
        )
        return _response.data

    async def write(
        self, *, data: typing.Sequence[PlannedWorkout], request_options: typing.Optional[RequestOptions] = None
    ) -> PlannedWorkoutWriteResponse:
        """
        Used to post workout plans users can follow on their wearable. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        data : typing.Sequence[PlannedWorkout]
            PlannedWorkout entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PlannedWorkoutWriteResponse
            Returned when activity was successfully created on the provider

        Examples
        --------
        import asyncio

        from terra import AsyncTerra, PlannedWorkout

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.plannedworkout.write(
                data=[PlannedWorkout()],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.write(data=data, request_options=request_options)
        return _response.data

    async def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PlannedWorkoutDeleteResponse:
        """
        Used to delete workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for planned workout entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PlannedWorkoutDeleteResponse
            Returned when all records were deleted successfully

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.plannedworkout.delete(
                user_id="user_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete(user_id=user_id, data=data, request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.planned_workout import PlannedWorkout
from .types.planned_workout_delete_response import PlannedWorkoutDeleteResponse
from .types.planned_workout_fetch_request_start_date import PlannedWorkoutFetchRequestStartDate
from .types.planned_workout_fetch_response import PlannedWorkoutFetchResponse
from .types.planned_workout_write_response import PlannedWorkoutWriteResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPlannedworkoutClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: PlannedWorkoutFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PlannedWorkoutFetchResponse]:
        """
        Used to get workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : PlannedWorkoutFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PlannedWorkoutFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "plannedWorkout",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlannedWorkoutFetchResponse,
                    construct_type(
                        type_=PlannedWorkoutFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def write(
        self, *, data: typing.Sequence[PlannedWorkout], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PlannedWorkoutWriteResponse]:
        """
        Used to post workout plans users can follow on their wearable. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        data : typing.Sequence[PlannedWorkout]
            PlannedWorkout entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PlannedWorkoutWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = self._client_wrapper.httpx_client.request(
            "plannedWorkout",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[PlannedWorkout], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlannedWorkoutWriteResponse,
                    construct_type(
                        type_=PlannedWorkoutWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PlannedWorkoutDeleteResponse]:
        """
        Used to delete workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for planned workout entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PlannedWorkoutDeleteResponse]
            Returned when all records were deleted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "plannedWorkout",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlannedWorkoutDeleteResponse,
                    construct_type(
                        type_=PlannedWorkoutDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPlannedworkoutClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: PlannedWorkoutFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PlannedWorkoutFetchResponse]:
        """
        Used to get workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : PlannedWorkoutFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PlannedWorkoutFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "plannedWorkout",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlannedWorkoutFetchResponse,
                    construct_type(
                        type_=PlannedWorkoutFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def write(
        self, *, data: typing.Sequence[PlannedWorkout], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PlannedWorkoutWriteResponse]:
        """
        Used to post workout plans users can follow on their wearable. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        data : typing.Sequence[PlannedWorkout]
            PlannedWorkout entry to post to data provider

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PlannedWorkoutWriteResponse]
            Returned when activity was successfully created on the provider
        """
        _response = await self._client_wrapper.httpx_client.request(
            "plannedWorkout",
            method="POST",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[PlannedWorkout], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlannedWorkoutWriteResponse,
                    construct_type(
                        type_=PlannedWorkoutWriteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        *,
        user_id: str,
        data: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PlannedWorkoutDeleteResponse]:
        """
        Used to delete workout plans the user has registered on their account. This can be strength workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        data : typing.Optional[typing.Sequence[str]]
            List of identifiers for planned workout entries to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PlannedWorkoutDeleteResponse]
            Returned when all records were deleted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "plannedWorkout",
            method="DELETE",
            params={
                "user_id": user_id,
            },
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlannedWorkoutDeleteResponse,
                    construct_type(
                        type_=PlannedWorkoutDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/planned_workout_delete_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser
from .planned_workout_delete_response_processed_data_item import PlannedWorkoutDeleteResponseProcessedDataItem


class PlannedWorkoutDeleteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    processed_data: typing.Optional[typing.List[PlannedWorkoutDeleteResponseProcessedDataItem]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/planned_workout_delete_response_processed_data_item.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel


class PlannedWorkoutDeleteResponseProcessedDataItem(UncheckedBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Identifier of the planned workout whose deletion was attempted
    """

    response_code: typing.Optional[int] = pydantic.Field(default=None)
    """
    Response code from the provider when attempting to delete the planned workout
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/planned_workout_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PlannedWorkoutFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/planned_workout_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.no_data_returned import NoDataReturned
from .planned_workout_fetch_response_data import PlannedWorkoutFetchResponseData

PlannedWorkoutFetchResponse = typing.Union[PlannedWorkoutFetchResponseData, NoDataReturned, DataSentToWebhook]

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/planned_workout_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.planned_workout import PlannedWorkout
from ...types.terra_user import TerraUser


class PlannedWorkoutFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[PlannedWorkout]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/plannedworkout/types/planned_workout_write_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser


class PlannedWorkoutWriteResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    log_ids: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB]
    """

    message: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/sleep/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/sleep/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from .raw_client import AsyncRawSleepClient, RawSleepClient
from .types.sleep_fetch_request_start_date import SleepFetchRequestStartDate
from .types.sleep_fetch_response import SleepFetchResponse


class SleepClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawSleepClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawSleepClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawSleepClient
        """
        return self._raw_client

    def fetch(
        self,
        *,
        user_id: str,
        start_date: SleepFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SleepFetchResponse:
        """
        Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : SleepFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SleepFetchResponse
            Returned upon successful data request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.sleep.fetch(
            user_id="user_id",
            start_date=1,
        )
        """
        _response = self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data


class AsyncSleepClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawSleepClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawSleepClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawSleepClient
        """
        return self._raw_client

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: SleepFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SleepFetchResponse:
        """
        Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : SleepFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SleepFetchResponse
            Returned upon successful data request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sleep.fetch(
                user_id="user_id",
                start_date=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.fetch(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            to_webhook=to_webhook,
            with_samples=with_samples,
            request_options=request_options,
        )
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/sleep/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from .types.sleep_fetch_request_start_date import SleepFetchRequestStartDate
from .types.sleep_fetch_response import SleepFetchResponse


class RawSleepClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def fetch(
        self,
        *,
        user_id: str,
        start_date: SleepFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SleepFetchResponse]:
        """
        Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : SleepFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SleepFetchResponse]
            Returned upon successful data request
        """
        _response = self._client_wrapper.httpx_client.request(
            "sleep",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SleepFetchResponse,
                    construct_type(
                        type_=SleepFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSleepClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def fetch(
        self,
        *,
        user_id: str,
        start_date: SleepFetchRequestStartDate,
        end_date: typing.Optional[int] = None,
        to_webhook: typing.Optional[bool] = None,
        with_samples: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SleepFetchResponse]:
        """
        Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time

        Parameters
        ----------
        user_id : str
            Terra user ID (UUID format) to retrieve data for

        start_date : SleepFetchRequestStartDate
            Start date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        end_date : typing.Optional[int]
            End date for data query - either ISO8601 date (YYYY-MM-DD) or unix timestamp in seconds (10-digit)

        to_webhook : typing.Optional[bool]
            Boolean flag specifying whether to send the data retrieved to the webhook instead of in the response (default: false)

        with_samples : typing.Optional[bool]
            Boolean flag specifying whether to include detailed samples in the returned payload (default: false)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SleepFetchResponse]
            Returned upon successful data request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sleep",
            method="GET",
            params={
                "user_id": user_id,
                "start_date": start_date,
                "end_date": end_date,
                "to_webhook": to_webhook,
                "with_samples": with_samples,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SleepFetchResponse,
                    construct_type(
                        type_=SleepFetchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/sleep/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/sleep/types/sleep_fetch_request_start_date.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

SleepFetchRequestStartDate = typing.Union[int, str]

```
</file>
<file path="terra-client-python/src/terra/sleep/types/sleep_fetch_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.data_sent_to_webhook import DataSentToWebhook
from ...types.large_request_processing_event import LargeRequestProcessingEvent
from ...types.no_data_returned import NoDataReturned
from ...types.rate_limit_request_processing import RateLimitRequestProcessing
from ...types.request_processing import RequestProcessing
from .sleep_fetch_response_data import SleepFetchResponseData

SleepFetchResponse = typing.Union[
    SleepFetchResponseData,
    NoDataReturned,
    DataSentToWebhook,
    RequestProcessing,
    RateLimitRequestProcessing,
    LargeRequestProcessingEvent,
]

```
</file>
<file path="terra-client-python/src/terra/sleep/types/sleep_fetch_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.sleep import Sleep
from ...types.terra_user import TerraUser


class SleepFetchResponseData(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    data: typing.Optional[typing.List[Sleep]] = None
    type: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/types/a_fib_classification_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .inconclusive import Inconclusive


class AFibClassificationSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    afib_classification: typing.Optional[Inconclusive] = pydantic.Field(default=None)
    """
    Flag indicating the atrial fibrillation classification of the individual
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/access_revoked_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class AccessRevokedEvent(UncheckedBaseModel):
    """
    Access revoked event when a user revokes access through the provider
    """

    type: typing.Literal["access_revoked"] = "access_revoked"
    user: TerraUser = pydantic.Field()
    """
    User who revoked access
    """

    status: typing.Literal["warning"] = pydantic.Field(default="warning")
    """
    Status of the event
    """

    message: str = pydantic.Field()
    """
    Information about the access revocation
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/access_revoked_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .access_revoked_event import AccessRevokedEvent

AccessRevokedWebhook = AccessRevokedEvent

```
</file>
<file path="terra-client-python/src/terra/types/active_durations_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .activity_level_sample import ActivityLevelSample


class ActiveDurationsData(UncheckedBaseModel):
    activity_levels_samples: typing.Optional[typing.List[ActivityLevelSample]] = pydantic.Field(default=None)
    """
    Array of detailed samples of the intensity the user was in at various points during the workout.
    """

    activity_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in an active state during the workout.
    """

    inactivity_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in an inactive state during the workout.
    """

    low_intensity_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a low intensity state during the workout.
    """

    moderate_intensity_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a moderate intensity state during the workout.
    """

    num_continuous_inactive_periods: typing.Optional[int] = pydantic.Field(default=None)
    """
    Maximum number of continuous periods spent in an inactive state during the workout.
    """

    rest_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent resting during the workout.
    """

    vigorous_intensity_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a state of vigorous intensity during the workout.
    """

    standing_hours_count: typing.Optional[float] = None
    standing_seconds: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/activity.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .active_durations_data import ActiveDurationsData
from .activity_metadata import ActivityMetadata
from .calories_data import CaloriesData
from .data_enrichment import DataEnrichment
from .device_data import DeviceData
from .distance_data import DistanceData
from .energy_data import EnergyData
from .heart_rate_data import HeartRateData
from .lap_data import LapData
from .met_data import MetData
from .movement_data import MovementData
from .oxygen_data import OxygenData
from .polyline_map_data import PolylineMapData
from .position_data import PositionData
from .power_data import PowerData
from .strain_data import StrainData
from .tss_data import TssData
from .work_data import WorkData


class Activity(UncheckedBaseModel):
    active_durations_data: typing.Optional[ActiveDurationsData] = pydantic.Field(default=None)
    """
    Number of minutes spent at various intensities during the workout, as reported by the Fitness Data provider.
    """

    calories_data: typing.Optional[CaloriesData] = pydantic.Field(default=None)
    """
    Object containing calorie-related information for the user during the specific workout.
    """

    cheat_detection: typing.Optional[float] = pydantic.Field(default=None)
    """
    Cheat detection flag.
    """

    data_enrichment: typing.Optional[DataEnrichment] = pydantic.Field(default=None)
    """
    Object containing Terra Scores.
    """

    device_data: typing.Optional[DeviceData] = pydantic.Field(default=None)
    """
    Object containing information on the device which recorded the specific workout.
    """

    distance_data: typing.Optional[DistanceData] = pydantic.Field(default=None)
    """
    Object containing information related to distance covered during the associated workout.
    """

    energy_data: typing.Optional[EnergyData] = pydantic.Field(default=None)
    """
    Object containing information on the energy expended by the user during the workout.
    """

    heart_rate_data: typing.Optional[HeartRateData] = pydantic.Field(default=None)
    """
    Object containing heartrate-related information for the workout.
    """

    lap_data: typing.Optional[LapData] = pydantic.Field(default=None)
    """
    Object containing information on data for each lap performed by the user - mostly relates to track & field running activities, and swimming activities.
    """

    met_data: typing_extensions.Annotated[typing.Optional[MetData], FieldMetadata(alias="MET_data")] = pydantic.Field(
        default=None
    )
    """
    Object containing information on the Metabolic Equivalent of Task for the workout.
    """

    metadata: ActivityMetadata = pydantic.Field()
    """
    Object containing workout metadata.
    """

    movement_data: typing.Optional[MovementData] = pydantic.Field(default=None)
    """
    Object containing information on the user's movement throughout the workout.
    """

    oxygen_data: typing.Optional[OxygenData] = pydantic.Field(default=None)
    """
    Object containing information on oxygen-related metrics for the workout.
    """

    polyline_map_data: typing.Optional[PolylineMapData] = pydantic.Field(default=None)
    """
    Object containing polyline-representation map data, plotting the user's trajectory throughout the workout.
    """

    position_data: typing.Optional[PositionData] = pydantic.Field(default=None)
    """
    Object containing information on the user's position throughout the workout.
    """

    power_data: typing.Optional[PowerData] = pydantic.Field(default=None)
    """
    Object containing information on the power generated by the user during the workout.
    """

    strain_data: typing.Optional[StrainData] = pydantic.Field(default=None)
    """
    Object containing information on the cardiovascular strain imposed on the user during the workout.
    """

    tss_data: typing_extensions.Annotated[typing.Optional[TssData], FieldMetadata(alias="TSS_data")] = pydantic.Field(
        default=None
    )
    """
    Object containing information on the stress put on the user's body from a workout.
    """

    work_data: typing.Optional[WorkData] = pydantic.Field(default=None)
    """
    Object containing information on the work output of the user during the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/activity_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .activity import Activity
from .terra_user import TerraUser


class ActivityEvent(UncheckedBaseModel):
    """
    Activity data event
    """

    type: typing.Literal["activity"] = "activity"
    data: typing.List[Activity] = pydantic.Field()
    """
    Array of activity data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/activity_level.py">
```py
# This file was auto-generated by Fern from our API Definition.

ActivityLevel = float

```
</file>
<file path="terra-client-python/src/terra/types/activity_level_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .activity_level import ActivityLevel


class ActivityLevelSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    level: typing.Optional[ActivityLevel] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/activity_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .hurling import Hurling
from .timestamp_localization import TimestampLocalization
from .upload_type import UploadType


class ActivityMetadata(UncheckedBaseModel):
    city: typing.Optional[str] = pydantic.Field(default=None)
    """
    The City in which the workout was performed.
    """

    country: typing.Optional[str] = pydantic.Field(default=None)
    """
    The Country in which the workout was performed.
    """

    end_time: str = pydantic.Field()
    """
    The end time of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    The name - either user-entered or given by the fitness data provider - of the associated workout.
    """

    start_time: str = pydantic.Field()
    """
    The start time of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    state: typing.Optional[str] = pydantic.Field(default=None)
    """
    The State in which the workout was performed.
    """

    summary_id: str = pydantic.Field()
    """
    A unique identifier for the workout - note that this is unique for the given user, and may not be globally unique.
    """

    timestamp_localization: typing.Optional[TimestampLocalization] = None
    type: Hurling = pydantic.Field()
    """
    The type of activity performed for the associated workout.
    """

    upload_type: UploadType = pydantic.Field()
    """
    The upload type for the associated workout, providing information on whether this was an automatic workout or user-entered.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/activity_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .activity_event import ActivityEvent

ActivityWebhook = ActivityEvent

```
</file>
<file path="terra-client-python/src/terra/types/asleep_durations.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel


class AsleepDurations(UncheckedBaseModel):
    duration_asleep_state_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was asleep, in any state.
    """

    duration_deep_sleep_state_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was in a state of deep sleep.
    """

    duration_light_sleep_state_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was in a state of light sleep.
    """

    duration_rem_sleep_state_seconds: typing_extensions.Annotated[
        typing.Optional[float], FieldMetadata(alias="duration_REM_sleep_state_seconds")
    ] = pydantic.Field(default=None)
    """
    Total duration for which the user was in a state of REM sleep.
    """

    num_rem_events: typing_extensions.Annotated[typing.Optional[int], FieldMetadata(alias="num_REM_events")] = (
        pydantic.Field(default=None)
    )
    """
    Number of periods of REM sleep captured during the sleep session.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/athlete.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .device_data import DeviceData


class Athlete(UncheckedBaseModel):
    age: typing.Optional[int] = pydantic.Field(default=None)
    """
    User's age.
    """

    country: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's country of residence.
    """

    bio: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's bio - a short description they display on their profile.
    """

    state: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's state of residence.
    """

    last_name: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's last name.
    """

    sex: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's sex.
    """

    city: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's city of residence.
    """

    email: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's email.
    """

    date_of_birth: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's date of birth, in ISO8601 format.
    """

    first_name: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's first name.
    """

    gender: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's gender.
    """

    joined_provider: typing.Optional[str] = pydantic.Field(default=None)
    """
    User's account creation date.
    """

    devices: typing.Optional[typing.List[DeviceData]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/athlete_collection.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .athlete import Athlete
from .terra_user import TerraUser


class AthleteCollection(UncheckedBaseModel):
    athlete: typing.Optional[Athlete] = pydantic.Field(default=None)
    """
    Object containing the user's information
    """

    user: typing.Optional[TerraUser] = pydantic.Field(default=None)
    """
    Terra User object
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/athlete_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .athlete import Athlete
from .terra_user import TerraUser


class AthleteEvent(UncheckedBaseModel):
    """
    Athlete data event
    """

    type: typing.Literal["athlete"] = "athlete"
    athlete: Athlete = pydantic.Field()
    """
    Athlete data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/athlete_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .athlete_event import AthleteEvent

AthleteWebhook = AthleteEvent

```
</file>
<file path="terra-client-python/src/terra/types/auth_error_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from .auth_event import AuthEvent
from .terra_user import TerraUser


class AuthErrorEvent(AuthEvent):
    """
    Authentication error event
    """

    user: TerraUser = pydantic.Field()
    """
    User who attempted to authenticate
    """

    provider: str = pydantic.Field()
    """
    Provider information
    """

    message: str = pydantic.Field()
    """
    Error message
    """

    reason: str = pydantic.Field()
    """
    Reason for the error
    """

    reference_id: str = pydantic.Field()
    """
    Client-provided reference ID
    """

    widget_session_id: str = pydantic.Field()
    """
    Widget session identifier
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/auth_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class AuthEvent(UncheckedBaseModel):
    """
    Authentication event
    """

    type: typing.Literal["auth"] = "auth"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/auth_success_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from .auth_event import AuthEvent
from .terra_user import TerraUser


class AuthSuccessEvent(AuthEvent):
    """
    Authentication success event
    """

    user: TerraUser = pydantic.Field()
    """
    User who authenticated
    """

    reference_id: str = pydantic.Field()
    """
    Client-provided reference ID
    """

    widget_session_id: str = pydantic.Field()
    """
    Widget session identifier
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/authentication_failed_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .auth_error_event import AuthErrorEvent

AuthenticationFailedWebhook = AuthErrorEvent

```
</file>
<file path="terra-client-python/src/terra/types/awake_durations.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class AwakeDurations(UncheckedBaseModel):
    duration_awake_state_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was awake during the sleep session.
    """

    duration_long_interruption_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was awake during the sleep session, when the interruption of their sleep was greater than 90 seconds.
    """

    duration_short_interruption_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was awake during the sleep session, when the interruption of their sleep was less than 90 seconds.
    """

    num_out_of_bed_events: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of times the user got out of bed during the sleep session.
    """

    num_wakeup_events: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of times the user woke up during the sleep session.
    """

    sleep_latency_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Sleep latency, defined as time between the moment the user lays in bed with the intention to sleep and the moment they actually fall asleep.
    """

    wake_up_latency_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Wake up latency, defined as time between the moment the user wakes up and the moment they get out of bed.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/bad_request_error_body.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class BadRequestErrorBody(UncheckedBaseModel):
    message: typing.Optional[str] = pydantic.Field(default=None)
    """
    a detailed message describing the error
    """

    status: typing.Optional[typing.Literal["error"]] = pydantic.Field(default=None)
    """
    indicates that an error happened (value is error)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/bad_request_error_body_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

BadRequestErrorBodyStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/types/blood_pressure_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .blood_pressure_sample import BloodPressureSample


class BloodPressureData(UncheckedBaseModel):
    blood_pressure_samples: typing.Optional[typing.List[BloodPressureSample]] = pydantic.Field(default=None)
    """
    List of Blood Pressure measurements sampled throughout the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/blood_pressure_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class BloodPressureSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    diastolic_bp: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's diastolic blood pressure, in mmHg
    """

    systolic_bp: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's systolic blood pressure, in mmHg
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/body.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .blood_pressure_data import BloodPressureData
from .body_metadata import BodyMetadata
from .device_data import DeviceData
from .glucose_data import GlucoseData
from .heart_data import HeartData
from .hydration_data import HydrationData
from .ketone_data import KetoneData
from .measurements_data import MeasurementsData
from .oxygen_data import OxygenData
from .temperature_data import TemperatureData


class Body(UncheckedBaseModel):
    blood_pressure_data: typing.Optional[BloodPressureData] = pydantic.Field(default=None)
    """
    Object containing information on user's Blood Pressure.
    """

    device_data: typing.Optional[DeviceData] = pydantic.Field(default=None)
    """
    Object containing information on the device which recorded data for the payload.
    """

    heart_data: typing.Optional[HeartData] = pydantic.Field(default=None)
    """
    Object containing information on user's heart metrics.
    """

    hydration_data: typing.Optional[HydrationData] = pydantic.Field(default=None)
    """
    Object containing information on user's hydration (both internal & consumption of water) for the day.
    """

    ketone_data: typing.Optional[KetoneData] = pydantic.Field(default=None)
    """
    Object containing information on user's ketone data for the day.
    """

    measurements_data: typing.Optional[MeasurementsData] = pydantic.Field(default=None)
    """
    Object containing information on body measurements for the day.
    """

    metadata: BodyMetadata = pydantic.Field()
    """
    Object containing daily summary metadata.
    """

    oxygen_data: typing.Optional[OxygenData] = pydantic.Field(default=None)
    """
    Object containing information on user's oxygen-related data.
    """

    temperature_data: typing.Optional[TemperatureData] = pydantic.Field(default=None)
    """
    Object containing temperature information (core, skin, ambient) during the day.
    """

    glucose_data: typing.Optional[GlucoseData] = pydantic.Field(default=None)
    """
    Object containing information on user's blood glucose for the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/body_battery_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class BodyBatterySample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    level: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/body_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .body import Body
from .terra_user import TerraUser


class BodyEvent(UncheckedBaseModel):
    """
    Body data event
    """

    type: typing.Literal["body"] = "body"
    data: typing.List[Body] = pydantic.Field()
    """
    Array of body data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/body_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .timestamp_localization import TimestampLocalization


class BodyMetadata(UncheckedBaseModel):
    end_time: str = pydantic.Field()
    """
    The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    start_time: str = pydantic.Field()
    """
    The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    timestamp_localization: typing.Optional[TimestampLocalization] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/body_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .body_event import BodyEvent

BodyWebhook = BodyEvent

```
</file>
<file path="terra-client-python/src/terra/types/breath.py">
```py
# This file was auto-generated by Fern from our API Definition.

Breath = float

```
</file>
<file path="terra-client-python/src/terra/types/breath_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class BreathSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    breaths_per_min: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's respiration rate
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/breaths_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .breath_sample import BreathSample


class BreathsData(UncheckedBaseModel):
    avg_breaths_per_min: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average breathing rate of the user during the sleep session.
    """

    max_breaths_per_min: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum breathing rate of the user during the sleep session.
    """

    min_breaths_per_min: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum breathing rate of the user during the sleep session.
    """

    on_demand_reading: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Flag indicating if the reading was performed on demand, or if it was automatically captured by the device.
    """

    samples: typing.Optional[typing.List[BreathSample]] = pydantic.Field(default=None)
    """
    List of breathing rate information sampled throughout the sleep session.
    """

    start_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The start time of the recording of breathing rate data, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    end_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The end time of the recording of breathing rate data, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/cadence_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .cadence_planned_workout_step_target_target_type import CadencePlannedWorkoutStepTargetTargetType


class CadencePlannedWorkoutStepTarget(UncheckedBaseModel):
    cadence: typing.Optional[int] = pydantic.Field(default=None)
    """
    Ideal cadence value to be maintained for the workout step
    """

    target_type: typing.Optional[CadencePlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    cadence_low: typing.Optional[int] = pydantic.Field(default=None)
    """
    Minimum cadence threshold for the workout step - i.e. the user is to stay above this value during the workout
    """

    cadence_high: typing.Optional[int] = pydantic.Field(default=None)
    """
    Maximum cadence threshold for the workout step - i.e. the user is to stay under this value during the workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/cadence_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

CadencePlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/cadence_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class CadenceSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    cadence_rpm: typing.Optional[float] = None
    timer_duration_seconds: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/calorie_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class CalorieSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    calories: typing.Optional[float] = None
    timer_duration_seconds: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/calories_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .calorie_sample import CalorieSample


class CaloriesData(UncheckedBaseModel):
    bmr_calories: typing_extensions.Annotated[typing.Optional[int], FieldMetadata(alias="BMR_calories")] = None
    calorie_samples: typing.Optional[typing.List[CalorieSample]] = None
    net_activity_calories: typing.Optional[int] = None
    net_intake_calories: typing.Optional[int] = None
    total_burned_calories: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/calories_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .calories_planned_workout_step_duration_duration_type import CaloriesPlannedWorkoutStepDurationDurationType


class CaloriesPlannedWorkoutStepDuration(UncheckedBaseModel):
    calories: typing.Optional[int] = pydantic.Field(default=None)
    """
    Calorie burn target for the workout step - once the user reaches the target, the step will be completed
    """

    duration_type: typing.Optional[CaloriesPlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/calories_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

CaloriesPlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/cardio_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .cardio_planned_workout_step_exercise_category import CardioPlannedWorkoutStepExerciseCategory
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget


class CardioPlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    exercise_name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of exercise to be performed for the workout step
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    exercise_category: typing.Optional[CardioPlannedWorkoutStepExerciseCategory] = pydantic.Field(default=None)
    """
    Type of exercise to be performed for the workout step
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/cardio_planned_workout_step_exercise_category.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

CardioPlannedWorkoutStepExerciseCategory = typing.Union[
    typing.Literal[
        "UNKNOWN",
        "BENCH_PRESS",
        "CALF_RAISE",
        "CARDIO",
        "CARRY",
        "CHOP",
        "CORE",
        "CRUNCH",
        "CURL",
        "DEADLIFT",
        "FLYE",
        "HIP_RAISE",
        "HIP_STABILITY",
        "HIP_SWING",
        "HYPEREXTENSION",
        "LATERAL_RAISE",
        "LEG_CURL",
        "LEG_RAISE",
        "LUNGE",
        "OLYMPIC_LIFT",
        "PLANK",
        "PLYO",
        "PULL_UP",
        "PUSH_UP",
        "ROW",
        "SHOULDER_PRESS",
        "SHOULDER_STABILITY",
        "SHRUG",
        "SIT_UP",
        "SQUAT",
        "TOTAL_BODY",
        "TRICEPS_EXTENSION",
        "WARM_UP",
        "RUN",
        "BIKE",
        "CARDIO_SENSORS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/connection_error_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class ConnectionErrorEvent(UncheckedBaseModel):
    """
    Connection error event
    """

    type: typing.Literal["connection_error"] = "connection_error"
    user: TerraUser = pydantic.Field()
    """
    User with connection issues
    """

    status: typing.Literal["warning"] = pydantic.Field(default="warning")
    """
    Status of the event
    """

    message: str = pydantic.Field()
    """
    Information about the connection issue
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/connection_error_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .connection_error_event import ConnectionErrorEvent

ConnectionErrorWebhook = ConnectionErrorEvent

```
</file>
<file path="terra-client-python/src/terra/types/cycling_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget


class CyclingPlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .active_durations_data import ActiveDurationsData
from .calories_data import CaloriesData
from .daily_data_enrichment import DailyDataEnrichment
from .daily_distance_data import DailyDistanceData
from .daily_metadata import DailyMetadata
from .device_data import DeviceData
from .heart_rate_data import HeartRateData
from .met_data import MetData
from .oxygen_data import OxygenData
from .scores_data import ScoresData
from .strain_data import StrainData
from .stress_data import StressData
from .tag_data import TagData


class Daily(UncheckedBaseModel):
    active_durations_data: typing.Optional[ActiveDurationsData] = pydantic.Field(default=None)
    """
    Object containing information related to the time spent in different activity intensities during over the day.
    """

    calories_data: typing.Optional[CaloriesData] = pydantic.Field(default=None)
    """
    Object containing calorie-related information for the user during the specific day.
    """

    data_enrichment: typing.Optional[DailyDataEnrichment] = pydantic.Field(default=None)
    """
    Object containing additional enrichment data for the day.
    """

    device_data: typing.Optional[DeviceData] = pydantic.Field(default=None)
    """
    Object containing information on the device which recorded data for the day.
    """

    distance_data: typing.Optional[DailyDistanceData] = pydantic.Field(default=None)
    """
    Object containing information related to distance covered during the associated day.
    """

    heart_rate_data: typing.Optional[HeartRateData] = pydantic.Field(default=None)
    """
    Object containing heartrate-related information for the day.
    """

    met_data: typing_extensions.Annotated[typing.Optional[MetData], FieldMetadata(alias="MET_data")] = pydantic.Field(
        default=None
    )
    """
    Object containing information on the Metabolic Equivalent of Task for the day.
    """

    metadata: DailyMetadata = pydantic.Field()
    """
    Object containing daily summary metadata.
    """

    oxygen_data: typing.Optional[OxygenData] = pydantic.Field(default=None)
    """
    Object containing information on oxygen-related metrics for the day.
    """

    scores: typing.Optional[ScoresData] = pydantic.Field(default=None)
    """
    Scores for the user's performance on different metrics for the given day, as calculated by the fitness data provider.
    """

    strain_data: typing.Optional[StrainData] = pydantic.Field(default=None)
    """
    Object containing information on the strain put on the user's body over a day.
    """

    stress_data: typing.Optional[StressData] = pydantic.Field(default=None)
    """
    Object containing information on the stress put on the user over a day.
    """

    tag_data: typing.Optional[TagData] = pydantic.Field(default=None)
    """
    Object containing all user-entered or automatically tagged events in the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily_data_enrichment.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .data_contributor import DataContributor


class DailyDataEnrichment(UncheckedBaseModel):
    cardiovascular_contributors: typing.Optional[typing.List[DataContributor]] = None
    cardiovascular_score: typing.Optional[float] = None
    immune_contributors: typing.Optional[typing.List[DataContributor]] = None
    immune_index: typing.Optional[float] = None
    readiness_contributors: typing.Optional[typing.List[DataContributor]] = None
    readiness_score: typing.Optional[float] = None
    respiratory_contributors: typing.Optional[typing.List[DataContributor]] = None
    respiratory_score: typing.Optional[float] = None
    start_time: typing.Optional[str] = None
    stress_contributors: typing.Optional[typing.List[DataContributor]] = None
    total_stress_score: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily_distance_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .distance_data_detailed import DistanceDataDetailed
from .elevation_data import ElevationData
from .swimming_data import SwimmingData


class DailyDistanceData(UncheckedBaseModel):
    detailed: typing.Optional[DistanceDataDetailed] = pydantic.Field(default=None)
    """
    Object containing detailed distance information - this may include second-by-second samples.
    """

    distance_meters: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total distance covered by the user throughout the day.
    """

    elevation: typing.Optional[ElevationData] = pydantic.Field(default=None)
    """
    Average elevation of the user throughout the day.
    """

    floors_climbed: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of elevation gain in floors climbed equivalent throughout the day, as determined by the fitness data provider.
    """

    steps: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of steps performed during the day.
    """

    swimming: typing.Optional[SwimmingData] = pydantic.Field(default=None)
    """
    Summary information of the user's swimming statistics for the day, if applicable.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .daily import Daily
from .terra_user import TerraUser


class DailyEvent(UncheckedBaseModel):
    """
    Daily data event
    """

    type: typing.Literal["daily"] = "daily"
    data: typing.List[Daily] = pydantic.Field()
    """
    Array of daily data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .timestamp_localization import TimestampLocalization
from .upload_type import UploadType


class DailyMetadata(UncheckedBaseModel):
    end_time: str = pydantic.Field()
    """
    The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    start_time: str = pydantic.Field()
    """
    The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    timestamp_localization: typing.Optional[TimestampLocalization] = None
    upload_type: UploadType = pydantic.Field()
    """
    The upload type for data in the associated day, providing information on whether data was automatically uploaded or user-entered. If any data point in a day is altered, the day should be classed as manual.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily_pattern_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class DailyPatternSample(UncheckedBaseModel):
    time_from_midnight: typing.Optional[int] = pydantic.Field(default=None)
    """
    Hour of the day, represented as an integer from 0 to 23, where 0 is midnight and 23 is the hour before the next midnight.
    """

    percentile_5: typing.Optional[int] = pydantic.Field(default=None)
    """
    Percentile 5 of the glucose level at the given time of day.
    """

    percentile_25: typing.Optional[int] = pydantic.Field(default=None)
    """
    Percentile 25 of the glucose level at the given time of day.
    """

    percentile_50: typing.Optional[int] = pydantic.Field(default=None)
    """
    Percentile 50 of the glucose level at the given time of day.
    """

    percentile_75: typing.Optional[int] = pydantic.Field(default=None)
    """
    Percentile 75 of the glucose level at the given time of day.
    """

    percentile_95: typing.Optional[int] = pydantic.Field(default=None)
    """
    Percentile 95 of the glucose level at the given time of day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/daily_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .daily_event import DailyEvent

DailyWebhook = DailyEvent

```
</file>
<file path="terra-client-python/src/terra/types/data_contributor.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class DataContributor(UncheckedBaseModel):
    contributor_name: str
    contributor_score: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/data_enrichment.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class DataEnrichment(UncheckedBaseModel):
    stress_score: typing.Optional[int] = pydantic.Field(default=None)
    """
    User's stress score.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/data_processing_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .processing_event import ProcessingEvent

DataProcessingWebhook = ProcessingEvent

```
</file>
<file path="terra-client-python/src/terra/types/data_sent_to_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class DataSentToWebhook(UncheckedBaseModel):
    reference: typing.Optional[str] = pydantic.Field(default=None)
    """
    Payload reference, tying the request to the webhook payload which will be received
    """

    message: typing.Optional[str] = None
    user: typing.Optional[TerraUser] = pydantic.Field(default=None)
    """
    Terra User object
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/deauth_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class DeauthEvent(UncheckedBaseModel):
    """
    User deauthentication event
    """

    type: typing.Literal["deauth"] = "deauth"
    user: TerraUser = pydantic.Field()
    """
    User who deauthenticated
    """

    status: typing.Literal["success"] = pydantic.Field(default="success")
    """
    Status of deauthentication
    """

    message: str = pydantic.Field()
    """
    Confirmation message
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/device_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .device_data_type import DeviceDataType
from .other_device_data import OtherDeviceData


class DeviceData(UncheckedBaseModel):
    activation_timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Activation timestamp of the device, if applicable.
    """

    data_provided: typing.Optional[typing.List[DeviceDataType]] = pydantic.Field(default=None)
    """
    Data provided by the device, as enumerated types.
    """

    hardware_version: typing.Optional[str] = pydantic.Field(default=None)
    """
    Hardware version of the device.
    """

    last_upload_date: typing.Optional[str] = pydantic.Field(default=None)
    """
    Last upload date from the device.
    """

    manufacturer: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device manufacturer name.
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device name - note that this can also be the name of the application/package which the data comes from, if coming from a data aggregator such as Google Fit.
    """

    other_devices: typing.Optional[typing.List[OtherDeviceData]] = pydantic.Field(default=None)
    """
    Data pertaining to other devices which may have contributed data for this workout.
    """

    sensor_state: typing.Optional[str] = pydantic.Field(default=None)
    """
    Sensor state of the device.
    """

    serial_number: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device Serial Number.
    """

    software_version: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device Software Version.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/device_data_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

DeviceDataType = typing.Union[
    typing.Literal[
        "STEPS",
        "ACTIVE_MINUTES",
        "BMR",
        "CALORIES",
        "DISTANCE",
        "HEART_RATE",
        "OXYGEN_SATURATION",
        "SLEEP_TYPE",
        "SPEED",
        "CADENCE",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/distance_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .distance_data_detailed import DistanceDataDetailed
from .distance_data_summary import DistanceDataSummary


class DistanceData(UncheckedBaseModel):
    detailed: typing.Optional[DistanceDataDetailed] = pydantic.Field(default=None)
    """
    Object containing detailed distance information - this may included second-by-second samples.
    """

    summary: typing.Optional[DistanceDataSummary] = pydantic.Field(default=None)
    """
    Object containing summary information related to distance covered throughout the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/distance_data_detailed.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .distance_sample import DistanceSample
from .elevation_sample import ElevationSample
from .floors_climbed_sample import FloorsClimbedSample
from .step_sample import StepSample


class DistanceDataDetailed(UncheckedBaseModel):
    distance_samples: typing.Optional[typing.List[DistanceSample]] = pydantic.Field(default=None)
    """
    Array of detailed samples of distance covered throughout the workout.
    """

    elevation_samples: typing.Optional[typing.List[ElevationSample]] = pydantic.Field(default=None)
    """
    Array of detailed samples of elevation throughout the workout.
    """

    floors_climbed_samples: typing.Optional[typing.List[FloorsClimbedSample]] = pydantic.Field(default=None)
    """
    Array of detailed samples of floors climbed throughout the workout, as determined by the fitness data provider.
    """

    step_samples: typing.Optional[typing.List[StepSample]] = pydantic.Field(default=None)
    """
    Array of detailed samples of steps performed throughout the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/distance_data_summary.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .elevation_data import ElevationData
from .swimming_data import SwimmingData


class DistanceDataSummary(UncheckedBaseModel):
    distance_meters: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total distance covered by the user throughout the workout.
    """

    elevation: typing.Optional[ElevationData] = pydantic.Field(default=None)
    """
    Average elevation of the user throughout the workout.
    """

    floors_climbed: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of elevation gain in floors climbed equivalent throughout the workout, as determined by the fitness data provider.
    """

    steps: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of steps performed during the workout.
    """

    swimming: typing.Optional[SwimmingData] = pydantic.Field(default=None)
    """
    Summary information of the user's swimming statistics for the workout, if applicable.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/distance_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .distance_planned_workout_step_duration_duration_type import DistancePlannedWorkoutStepDurationDurationType


class DistancePlannedWorkoutStepDuration(UncheckedBaseModel):
    duration_type: typing.Optional[DistancePlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    distance_meters: typing.Optional[int] = pydantic.Field(default=None)
    """
    Target distance for the workout step - once the user covers this distance, the step will be completed
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/distance_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

DistancePlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/distance_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class DistanceSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    distance_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Cumulative distance covered up to associated timestamp, since the start of the payload
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/drink_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class DrinkSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    drink_volume: typing.Optional[float] = pydantic.Field(default=None)
    """
    Volume of drink consumed
    """

    drink_unit: typing.Optional[str] = pydantic.Field(default=None)
    """
    Unit of measurement for the drink
    """

    drink_name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of drink consumed.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/ecg_reading.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .inconclusive import Inconclusive
from .raw_ecg_sample import RawEcgSample


class EcgReading(UncheckedBaseModel):
    start_timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    avg_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's average heart rate throughout the day, in beats per minute (bpm).
    """

    afib_classification: typing.Optional[Inconclusive] = pydantic.Field(default=None)
    """
    User's afib classification throught the day.
    """

    raw_signal: typing.Optional[typing.List[RawEcgSample]] = pydantic.Field(default=None)
    """
    List of raw ECG readings sampled through the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/elevation_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class ElevationData(UncheckedBaseModel):
    avg_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average elevation of the user throughout the workout.
    """

    gain_actual_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Planned elevation gain for the workout.
    """

    gain_planned_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Elevation gain of the user throughout the workout - this includes all elevation gain, and does _not_ represent net gain.
    """

    loss_actual_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Elevation loss of the user throughout the workout.
    """

    max_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum elevation of the user during the workout.
    """

    min_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum elevation of the user during the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/elevation_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class ElevationSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    elev_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's altitude at a given point in time, in meters above sea level.
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/energy_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class EnergyData(UncheckedBaseModel):
    energy_kilojoules: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of kiloJoules planned to be expended during the workout - represents the user's predefined goal for the workout
    """

    energy_planned_kilojoules: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of kiloJoules expended during the workout
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/fixed_rest_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .fixed_rest_planned_workout_step_duration_duration_type import FixedRestPlannedWorkoutStepDurationDurationType


class FixedRestPlannedWorkoutStepDuration(UncheckedBaseModel):
    duration_type: typing.Optional[FixedRestPlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    rest_seconds: typing.Optional[int] = pydantic.Field(default=None)
    """
    Time duration to be elapsed for the rest period
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/fixed_rest_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

FixedRestPlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/floors_climbed_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class FloorsClimbedSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    floors_climbed: typing.Optional[int] = pydantic.Field(default=None)
    """
    Cumulative number of elevation gain measured in floors climbed up to associated timestamp, since the start of the payload
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/glucose_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .daily_pattern_sample import DailyPatternSample
from .glucose_data_sample import GlucoseDataSample


class GlucoseData(UncheckedBaseModel):
    blood_glucose_samples: typing.Optional[typing.List[GlucoseDataSample]] = pydantic.Field(default=None)
    """
    List of blood glucose readings sampled throughout the day.
    """

    detailed_blood_glucose_samples: typing.Optional[typing.List[GlucoseDataSample]] = pydantic.Field(default=None)
    """
    List of blood glucose readings sampled throughout the day - this represents additional data points, potentially at higher frequency from the ones in blood_glucose_samples, which may come at a cost of reduced accuracy.
    """

    day_avg_blood_glucose_mg_per_d_l: typing_extensions.Annotated[
        typing.Optional[float], FieldMetadata(alias="day_avg_blood_glucose_mg_per_dL")
    ] = pydantic.Field(default=None)
    """
    User's average glucose level throughout the day.
    """

    gmi: typing.Optional[float] = pydantic.Field(default=None)
    """
    GMI (Glucose Management Indicator) is a metric derived from continuous glucose monitoring (CGM) data that estimates average glucose levels to help guide diabetes management, without implying a precise match to laboratory A1C.
    """

    time_in_range: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time that the user's glucose is within acceptable range (not hyper or hypoglycemic).
    """

    sensor_usage: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of data points recorded by the sensor throughout the day.
    """

    daily_patterns: typing.Optional[typing.List[DailyPatternSample]] = pydantic.Field(default=None)
    """
    List of glucose percentile samples throughout the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/glucose_data_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .low import Low
from .trend_arrow import TrendArrow


class GlucoseDataSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    blood_glucose_mg_per_d_l: typing_extensions.Annotated[
        typing.Optional[int], FieldMetadata(alias="blood_glucose_mg_per_dL")
    ] = pydantic.Field(default=None)
    """
    User's blood glucose reading
    """

    glucose_level_flag: typing.Optional[Low] = pydantic.Field(default=None)
    """
    Flag indicating state of user's blood glucose level
    """

    trend_arrow: typing.Optional[TrendArrow] = pydantic.Field(default=None)
    """
    Flag indicating the current trend in the user's blood glucose level (e.g. rising, constant, falling)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/google_no_data_source_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .google_no_datasource_event import GoogleNoDatasourceEvent

GoogleNoDataSourceWebhook = GoogleNoDatasourceEvent

```
</file>
<file path="terra-client-python/src/terra/types/google_no_datasource_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class GoogleNoDatasourceEvent(UncheckedBaseModel):
    """
    Google no datasource event
    """

    type: typing.Literal["google_no_datasource"] = "google_no_datasource"
    user: TerraUser = pydantic.Field()
    """
    Affected user
    """

    status: typing.Literal["warning"] = pydantic.Field(default="warning")
    """
    Status of the event
    """

    message: str = pydantic.Field()
    """
    Information about the issue
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/had.py">
```py
# This file was auto-generated by Fern from our API Definition.

Had = float

```
</file>
<file path="terra-client-python/src/terra/types/health_check_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .healthcheck_event import HealthcheckEvent

HealthCheckWebhook = HealthcheckEvent

```
</file>
<file path="terra-client-python/src/terra/types/healthcheck_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class HealthcheckEvent(UncheckedBaseModel):
    """
    Healthcheck event sent periodically to verify your webhook endpoint is functional
    """

    type: typing.Literal["healthcheck"] = "healthcheck"
    creation_timestamp: str = pydantic.Field()
    """
    Timestamp when the event was created
    """

    trend_percentage: int = pydantic.Field()
    """
    Percentage change in trends
    """

    sent_webhooks_last_hour: int = pydantic.Field()
    """
    Number of webhooks sent in the last hour
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .a_fib_classification_sample import AFibClassificationSample
from .ecg_reading import EcgReading
from .heart_rate_data import HeartRateData
from .pulse_velocity_sample import PulseVelocitySample
from .rr_interval_sample import RrIntervalSample


class HeartData(UncheckedBaseModel):
    afib_classification_samples: typing.Optional[typing.List[AFibClassificationSample]] = pydantic.Field(default=None)
    """
    List of Atrial Fibrillation classification measurements sampled through the day.
    """

    ecg_signal: typing.Optional[typing.List[EcgReading]] = pydantic.Field(default=None)
    """
    List of ECGReadings sampled through the day.
    """

    heart_rate_data: typing.Optional[HeartRateData] = pydantic.Field(default=None)
    """
    Object containing heart rate data.
    """

    pulse_wave_velocity_samples: typing.Optional[typing.List[PulseVelocitySample]] = pydantic.Field(default=None)
    """
    List of Pulse Wave Velocity measurements sampled throughout the day. This represents a measurement of arterial stiffness that is an independent predictor of cardiovascular risk.
    """

    rr_interval_samples: typing.Optional[typing.List[RrIntervalSample]] = pydantic.Field(default=None)
    """
    List of RR Interval samples throughout the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_context.py">
```py
# This file was auto-generated by Fern from our API Definition.

HeartRateContext = float

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .heart_rate_data_detailed import HeartRateDataDetailed
from .heart_rate_data_summary import HeartRateDataSummary


class HeartRateData(UncheckedBaseModel):
    detailed: typing.Optional[HeartRateDataDetailed] = pydantic.Field(default=None)
    """
    Object containing detailed heart rate information for the associated workout.
    """

    summary: typing.Optional[HeartRateDataSummary] = pydantic.Field(default=None)
    """
    Object containing summary heart rate information for the associated workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_data_detailed.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .heart_rate_data_sample import HeartRateDataSample
from .heart_rate_variability_data_sample_rmssd import HeartRateVariabilityDataSampleRmssd
from .heart_rate_variability_data_sample_sdnn import HeartRateVariabilityDataSampleSdnn


class HeartRateDataDetailed(UncheckedBaseModel):
    hr_samples: typing.Optional[typing.List[HeartRateDataSample]] = pydantic.Field(default=None)
    """
    Array of HeartRate data samples recorded for the user during the workout.
    """

    hrv_samples_rmssd: typing.Optional[typing.List[HeartRateVariabilityDataSampleRmssd]] = pydantic.Field(default=None)
    """
    Array of HeartRate Variability data samples recorded for the user during the workout, computed using RMSSD.
    """

    hrv_samples_sdnn: typing.Optional[typing.List[HeartRateVariabilityDataSampleSdnn]] = pydantic.Field(default=None)
    """
    Array of HeartRate Variability data samples recorded for the user during the workout, computed using SDNN.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_data_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .heart_rate_context import HeartRateContext


class HeartRateDataSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's heart rate in bpm
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    context: typing.Optional[HeartRateContext] = pydantic.Field(default=None)
    """
    Represents the context in which heart rate was measured.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_data_summary.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .heart_rate_zone_data import HeartRateZoneData


class HeartRateDataSummary(UncheckedBaseModel):
    avg_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average HeartRate of the user during the workout.
    """

    avg_hrv_rmssd: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average HeartRate Variability of the user during the workout, computed using RMSSD.
    """

    avg_hrv_sdnn: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average HeartRate Variability of the user during the workout, computed using SDNN.
    """

    hr_zone_data: typing.Optional[typing.List[HeartRateZoneData]] = pydantic.Field(default=None)
    """
    Array of time spent in various HR zones throughout the workout.
    """

    max_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum HeartRate of the user during the workout.
    """

    min_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum HeartRate of the user during the workout.
    """

    resting_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Resting HeartRate of the user, as determined by the fitness data provider.
    """

    user_max_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's maximum HeartRate based on their age, and other factors as determined by the fitness data provider.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_variability_data_sample_rmssd.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class HeartRateVariabilityDataSampleRmssd(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    hrv_rmssd: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's Heart Rate Variability, computed using RMSSD
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_variability_data_sample_sdnn.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class HeartRateVariabilityDataSampleSdnn(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    hrv_sdnn: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's Heart Rate Variability, computed using SDNN
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/heart_rate_zone_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .other import Other


class HeartRateZoneData(UncheckedBaseModel):
    zone: typing.Optional[Other] = pydantic.Field(default=None)
    """
    Heart rate zone designation
    """

    start_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Start percentage (based off user's max HR) of the HR zone
    """

    end_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    End percentage (based off user's max HR) of the HR zone
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of the associated heart rate zone
    """

    duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Duration spent in the heart rate zone
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/high.py">
```py
# This file was auto-generated by Fern from our API Definition.

High = float

```
</file>
<file path="terra-client-python/src/terra/types/hr_above_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .hr_above_planned_workout_step_duration_duration_type import HrAbovePlannedWorkoutStepDurationDurationType


class HrAbovePlannedWorkoutStepDuration(UncheckedBaseModel):
    duration_type: typing.Optional[HrAbovePlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    hr_above_bpm: typing.Optional[int] = pydantic.Field(default=None)
    """
    Threshold heart rate goal to complete the workout step - once the user's heart rate reaches above below this value, the step will be completed
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/hr_above_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

HrAbovePlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/hr_below_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .hr_below_planned_workout_step_duration_duration_type import HrBelowPlannedWorkoutStepDurationDurationType


class HrBelowPlannedWorkoutStepDuration(UncheckedBaseModel):
    hr_below_bpm: typing.Optional[int] = pydantic.Field(default=None)
    """
    Threshold heart rate goal to complete the workout step - once the user's heart rate reaches below this value, the step will be completed
    """

    duration_type: typing.Optional[HrBelowPlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/hr_below_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

HrBelowPlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/hr_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .hr_planned_workout_step_target_target_type import HrPlannedWorkoutStepTargetTargetType


class HrPlannedWorkoutStepTarget(UncheckedBaseModel):
    hr_percentage_low: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum max heart rate percentage threshold for the workout step - i.e. the user is to stay under this value during the workout step
    """

    target_type: typing.Optional[HrPlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    hr_percentage_high: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum heart rate percentage threshold for the workout step - i.e. the user is to stay above this value during the workout
    """

    hr_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Ideal percentage of user's maximum HR to be maintained workout step
    """

    hr_bpm_high: typing.Optional[int] = pydantic.Field(default=None)
    """
    Maximum heart rate threshold for the workout step - i.e. the user is to stay under this value during the workout step
    """

    hr_bpm_low: typing.Optional[int] = pydantic.Field(default=None)
    """
    Minimum heart rate threshold for the workout step - i.e. the user is to stay above this value during the workout
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/hr_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

HrPlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/hurling.py">
```py
# This file was auto-generated by Fern from our API Definition.

Hurling = float

```
</file>
<file path="terra-client-python/src/terra/types/hydration_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .hydration_measurement_sample import HydrationMeasurementSample


class HydrationData(UncheckedBaseModel):
    day_total_water_consumption_ml: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's total water consumption throughout the day.
    """

    hydration_amount_samples: typing.Optional[typing.List[HydrationMeasurementSample]] = pydantic.Field(default=None)
    """
    User's hydration level samples throughout the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/hydration_measurement_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class HydrationMeasurementSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    hydration_kg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total body water composition of the user, in kilograms.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/if_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .if_planned_workout_step_target_target_type import IfPlannedWorkoutStepTargetTargetType


class IfPlannedWorkoutStepTarget(UncheckedBaseModel):
    if_high: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum Intensity Factor to be achieved for the workout step
    """

    target_type: typing.Optional[IfPlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    if_low: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum Intensity Factor to be achieved for the workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/if_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

IfPlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/inconclusive.py">
```py
# This file was auto-generated by Fern from our API Definition.

Inconclusive = float

```
</file>
<file path="terra-client-python/src/terra/types/indeterminate.py">
```py
# This file was auto-generated by Fern from our API Definition.

Indeterminate = float

```
</file>
<file path="terra-client-python/src/terra/types/integration_provider.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .integration_provider_types import IntegrationProviderTypes


class IntegrationProvider(UncheckedBaseModel):
    provider: typing.Optional[str] = pydantic.Field(default=None)
    """
    Identifier for the provider
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Display name of the integration
    """

    icon: typing.Optional[str] = pydantic.Field(default=None)
    """
    URL for the provider's icon image
    """

    setup: typing.Optional[str] = pydantic.Field(default=None)
    """
    Indicates how the integration is set up
    """

    enabled: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Whether the integration is enabled
    """

    types: typing.Optional[IntegrationProviderTypes] = pydantic.Field(default=None)
    """
    Indicates the types of data available through the provider
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/integration_provider_types.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class IntegrationProviderTypes(UncheckedBaseModel):
    """
    Indicates the types of data available through the provider
    """

    activity: typing.Optional[bool] = None
    body: typing.Optional[bool] = None
    nutrition: typing.Optional[bool] = None
    daily: typing.Optional[bool] = None
    sleep: typing.Optional[bool] = None
    menstruation: typing.Optional[bool] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/integrations_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .integration_provider import IntegrationProvider


class IntegrationsResponse(UncheckedBaseModel):
    status: typing.Optional[str] = pydantic.Field(default=None)
    """
    Status of the API response
    """

    providers: typing.Optional[typing.List[IntegrationProvider]] = pydantic.Field(default=None)
    """
    List of integration providers with their details
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/ketone_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .ketone_sample import KetoneSample


class KetoneData(UncheckedBaseModel):
    ketone_samples: typing.Optional[typing.List[KetoneSample]] = pydantic.Field(default=None)
    """
    List of ketone data sampled through the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/ketone_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .breath import Breath


class KetoneSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    ketone_mg_per_d_l: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="ketone_mg_per_dL")] = (
        pydantic.Field(default=None)
    )
    """
    Ketone in mg per dL
    """

    sample_type: typing.Optional[Breath] = pydantic.Field(default=None)
    """
    Flag indicating the ketone sample type (e.g. blood, breath, urine)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/lap_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .lap_sample import LapSample


class LapData(UncheckedBaseModel):
    laps: typing.Optional[typing.List[LapSample]] = pydantic.Field(default=None)
    """
    Array of datapoints for each lap performed by the user during the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/lap_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .stroke_type import StrokeType


class LapSample(UncheckedBaseModel):
    calories: typing.Optional[float] = pydantic.Field(default=None)
    """
    Calories burned during the lap
    """

    avg_hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average heart rate in bpm, for the Lap sample
    """

    start_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The start time of the associated lap, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    avg_speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average speed of the user during the lap
    """

    distance_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Distance covered during the lap
    """

    total_strokes: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total strokes performed during the lap - only relevant for swimming activities
    """

    end_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The end time of the associated lap, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    stroke_type: typing.Optional[StrokeType] = pydantic.Field(default=None)
    """
    Stroke type - only relevant for swimming activities
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/large_request_processing_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class LargeRequestProcessingEvent(UncheckedBaseModel):
    """
    Large request processing event
    """

    type: typing.Literal["large_request_processing"] = "large_request_processing"
    status: typing.Literal["processing"] = pydantic.Field(default="processing")
    """
    Status of the processing
    """

    message: str = pydantic.Field()
    """
    Information about the processing
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being processed
    """

    reference: str = pydantic.Field()
    """
    Reference ID for tracking this request
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/large_request_processing_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .large_request_processing_event import LargeRequestProcessingEvent

LargeRequestProcessingResponse = LargeRequestProcessingEvent

```
</file>
<file path="terra-client-python/src/terra/types/large_request_sending_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class LargeRequestSendingEvent(UncheckedBaseModel):
    """
    Large request sending event
    """

    type: typing.Literal["large_request_sending"] = "large_request_sending"
    user: TerraUser = pydantic.Field()
    """
    User whose data is being sent
    """

    reference: str = pydantic.Field()
    """
    Reference ID for tracking this request
    """

    message: str = pydantic.Field()
    """
    Information about the request
    """

    expected_payloads: int = pydantic.Field()
    """
    Number of expected payload events
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/large_request_sending_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .large_request_sending_event import LargeRequestSendingEvent

LargeRequestSendingWebhook = LargeRequestSendingEvent

```
</file>
<file path="terra-client-python/src/terra/types/low.py">
```py
# This file was auto-generated by Fern from our API Definition.

Low = float

```
</file>
<file path="terra-client-python/src/terra/types/meal.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .nutrition_macros import NutritionMacros
from .nutrition_micros import NutritionMicros
from .nutrition_quantity import NutritionQuantity
from .snack import Snack


class Meal(UncheckedBaseModel):
    micros: NutritionMicros = pydantic.Field()
    """
    Micronutrient information for associated food.
    """

    type: Snack = pydantic.Field()
    """
    Enum representing the category the consumed food/meal falls under (i.e. Breakfast/Lunch/Dinner etc).
    """

    id: str = pydantic.Field()
    """
    Identifier for food logged by the user.
    """

    timestamp: str = pydantic.Field()
    """
    Timestamp the food is associated with, in ISO8601 format, with microsecond precision.
    """

    quantity: NutritionQuantity = pydantic.Field()
    """
    Quantity of the food that was consumed, containing information on amount & units in which this was recorded.
    """

    name: str = pydantic.Field()
    """
    Name of food logged by the user.
    """

    macros: NutritionMacros = pydantic.Field()
    """
    Macronutrient information for associated food.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/measurement_data_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel


class MeasurementDataSample(UncheckedBaseModel):
    measurement_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    bmi: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="BMI")] = pydantic.Field(default=None)
    """
    User's Body Mass Index (BMI).
    """

    bmr: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="BMR")] = pydantic.Field(default=None)
    """
    User's Basal Metabolic Rate - minimum amount of calories that a person's body needs to perform necessary functions.
    """

    rmr: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="RMR")] = pydantic.Field(default=None)
    """
    User's Resting Metabolic Rate - amount of energy that a person's body needs to function while at rest. RMR accounts for additional low-effort daily activities on top of basic body functions.
    """

    estimated_fitness_age: typing.Optional[str] = pydantic.Field(default=None)
    """
    Estimate of how fit the user is compared to their actual age, as measured by the device.
    """

    skin_fold_mm: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's skin fold measurement.
    """

    bodyfat_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's body fat percentage.
    """

    weight_kg: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's body weight.
    """

    height_cm: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's height.
    """

    bone_mass_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's total bone mass.
    """

    muscle_mass_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's total muscle mass (i.e. skeletal muscle mass).
    """

    lean_mass_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total lean mass of the user - calculated as the difference between total body weight and body fat weight.
    """

    water_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total amount of fluid in the user's body.
    """

    insulin_units: typing.Optional[float] = pydantic.Field(default=None)
    """
    Quantity of insulin administered to the user.
    """

    insulin_type: typing.Optional[str] = pydantic.Field(default=None)
    """
    Type of insulin administered to the user.
    """

    urine_color: typing.Optional[str] = pydantic.Field(default=None)
    """
    Color of the user's urine.
    """

    user_notes: typing.Optional[str] = pydantic.Field(default=None)
    """
    User notes associated with the measurement.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/measurements_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .measurement_data_sample import MeasurementDataSample


class MeasurementsData(UncheckedBaseModel):
    measurements: typing.Optional[typing.List[MeasurementDataSample]] = pydantic.Field(default=None)
    """
    List of body metrics & measurements taken throughout the associated day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/menstrual_phase.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

MenstrualPhase = typing.Union[
    typing.Literal[
        "menstrual",
        "follicular",
        "ovulation",
        "luteal",
        "pms",
        "fertile",
        "first_trimester",
        "second_trimester",
        "third_trimester",
        "unknown",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/menstruation.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .menstruation_data import MenstruationData
from .menstruation_metadata import MenstruationMetadata


class Menstruation(UncheckedBaseModel):
    metadata: MenstruationMetadata = pydantic.Field()
    """
    Object containing daily summary metadata.
    """

    menstruation_data: typing.Optional[MenstruationData] = pydantic.Field(default=None)
    """
    Object containing information on user's menstruation for a given day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/menstruation_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .menstrual_phase import MenstrualPhase
from .menstruation_flow_sample import MenstruationFlowSample


class MenstruationData(UncheckedBaseModel):
    period_length_days: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total length of period (i.e. menstrual bleeding).
    """

    current_phase: typing.Optional[MenstrualPhase] = pydantic.Field(default=None)
    """
    Phase in associated cycle, (i.e. menstruation, fertile etc).
    """

    length_of_current_phase_days: typing.Optional[int] = pydantic.Field(default=None)
    """
    Length of current phase.
    """

    days_until_next_phase: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of days to reach the next phase (predicted).
    """

    period_start_date: typing.Optional[str] = pydantic.Field(default=None)
    """
    Start date of menstrual cycle, in ISO8601 format.
    """

    predicted_cycle_length_days: typing.Optional[int] = pydantic.Field(default=None)
    """
    Prediction of the cycle's total length.
    """

    day_in_cycle: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of day in cycle this object is associated with.
    """

    last_updated_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    Last time when the user recorded information regarding their cycle, in ISO8601 format, with microseconds precision.
    """

    cycle_length_days: typing.Optional[str] = pydantic.Field(default=None)
    """
    Total cycle length.
    """

    is_predicted_cycle: typing.Optional[str] = pydantic.Field(default=None)
    """
    Flag indicating whether associated object is a prediction or user-logged information.
    """

    menstruation_flow: typing.Optional[typing.List[MenstruationFlowSample]] = pydantic.Field(default=None)
    """
    List of user logs of information related to the strength of user's menstrual flow.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/menstruation_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .menstruation import Menstruation
from .terra_user import TerraUser


class MenstruationEvent(UncheckedBaseModel):
    """
    Menstruation data event
    """

    type: typing.Literal["menstruation"] = "menstruation"
    data: typing.List[Menstruation] = pydantic.Field()
    """
    Array of menstruation data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/menstruation_flow_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .had import Had


class MenstruationFlowSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    flow: typing.Optional[Had] = pydantic.Field(default=None)
    """
    Flag indicating the strength of the user's menstrual flow.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/menstruation_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .timestamp_localization import TimestampLocalization


class MenstruationMetadata(UncheckedBaseModel):
    end_time: str = pydantic.Field()
    """
    The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    start_time: str = pydantic.Field()
    """
    The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    timestamp_localization: typing.Optional[TimestampLocalization] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/menstruation_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .menstruation_event import MenstruationEvent

MenstruationWebhook = MenstruationEvent

```
</file>
<file path="terra-client-python/src/terra/types/met_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .met_sample import MetSample


class MetData(UncheckedBaseModel):
    met_samples: typing_extensions.Annotated[
        typing.Optional[typing.List[MetSample]], FieldMetadata(alias="MET_samples")
    ] = pydantic.Field(default=None)
    """
    An array of Metabolic Equivalent Time samples, as calculated by the user's wearable.
    """

    avg_level: typing.Optional[float] = pydantic.Field(default=None)
    """
    The average MET level of the activity.
    """

    num_high_intensity_minutes: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number of minutes spent in High Intensity during the workout - based off MET scale.
    """

    num_inactive_minutes: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number of minutes spent in state of Inactivity during the workout - based off MET scale.
    """

    num_low_intensity_minutes: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number of minutes spent in Low Intensity during the workout - based off MET scale.
    """

    num_moderate_intensity_minutes: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number of minutes spent in Moderate Intensity during the workout - based off MET scale.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/met_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class MetSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    level: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/movement_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .cadence_sample import CadenceSample
from .speed_sample import SpeedSample
from .torque_sample import TorqueSample


class MovementData(UncheckedBaseModel):
    adjusted_max_speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Adjusted max speed of the user during the workout - generated using Terra's algorithms to remove potential affecting the user's actual max speed measurement.
    """

    avg_cadence_rpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average cadence of the user during the workout, in RPM.
    """

    avg_pace_minutes_per_kilometer: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average pace of the user during the workout.
    """

    avg_speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average speed of the user during the workout.
    """

    avg_torque_newton_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average torque generated by the user during the workout - mainly relevant for cycling activities.
    """

    avg_velocity_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average velocity of the user during the workout - only calculated by certain providers, representing a separate quantity from speed.
    """

    cadence_samples: typing.Optional[typing.List[CadenceSample]] = pydantic.Field(default=None)
    """
    Array of cadence values recorded throughout the workout, sampled at intervals determined by the fitness data provider.
    """

    max_cadence_rpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum cadence of the user during the workout - mainly relevant for cycling activities.
    """

    max_pace_minutes_per_kilometer: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum pace of the user during the workout.
    """

    max_speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum speed of the user during the workout.
    """

    max_torque_newton_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum torque generated by the user during the workout - mainly relevant for cycling activities.
    """

    max_velocity_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum velocity of the user during the workout - only calculated by certain providers, representing a separate quantity from speed.
    """

    normalized_speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average normalized speed of the user during the workout - only calculated by certain providers, representing a separate quantity from speed.
    """

    speed_samples: typing.Optional[typing.List[SpeedSample]] = pydantic.Field(default=None)
    """
    Array of the datapoints for the user's speed sampled throughout the workout.
    """

    torque_samples: typing.Optional[typing.List[TorqueSample]] = pydantic.Field(default=None)
    """
    Array of the datapoints for the user's torque sampled throughout the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/muscle.py">
```py
# This file was auto-generated by Fern from our API Definition.

Muscle = float

```
</file>
<file path="terra-client-python/src/terra/types/no_data_returned.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .no_data_returned_status import NoDataReturnedStatus
from .terra_user import TerraUser


class NoDataReturned(UncheckedBaseModel):
    status: typing.Optional[NoDataReturnedStatus] = None
    message: typing.Optional[str] = None
    user: typing.Optional[TerraUser] = pydantic.Field(default=None)
    """
    Terra User object
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/no_data_returned_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

NoDataReturnedStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/types/not_found_error_body.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class NotFoundErrorBody(UncheckedBaseModel):
    message: typing.Optional[str] = pydantic.Field(default=None)
    """
    a detailed message describing the error
    """

    status: typing.Optional[typing.Literal["error"]] = pydantic.Field(default=None)
    """
    indicates that an error happened (value is error)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/not_found_error_body_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

NotFoundErrorBodyStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/types/nutrition.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .drink_sample import DrinkSample
from .meal import Meal
from .nutrition_metadata import NutritionMetadata
from .nutrition_summary import NutritionSummary


class Nutrition(UncheckedBaseModel):
    drink_samples: typing.Optional[typing.List[DrinkSample]] = pydantic.Field(default=None)
    """
    Information on drinks the user consumed throughout the day.
    """

    meals: typing.Optional[typing.List[Meal]] = pydantic.Field(default=None)
    """
    Information on individual foods consumed throughout a given day.
    """

    metadata: NutritionMetadata = pydantic.Field()
    """
    Object containing daily summary metadata.
    """

    summary: typing.Optional[NutritionSummary] = pydantic.Field(default=None)
    """
    Summative nutritional information for a given day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .nutrition import Nutrition
from .terra_user import TerraUser


class NutritionEvent(UncheckedBaseModel):
    """
    Nutrition data event
    """

    type: typing.Literal["nutrition"] = "nutrition"
    data: typing.List[Nutrition] = pydantic.Field()
    """
    Array of nutrition data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_macros.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class NutritionMacros(UncheckedBaseModel):
    alcohol_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Alcohol content of the associated food(s).
    """

    calories: typing.Optional[float] = pydantic.Field(default=None)
    """
    Calorie content of the associated food(s).
    """

    carbohydrates_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Carbohydrates content of the associated food(s).
    """

    cholesterol_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Cholesterol content of the associated food(s).
    """

    fat_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Fat content of the associated food(s).
    """

    fiber_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Fiber content of the associated food(s).
    """

    net_carbohydrates_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Net carbs content of the associated food(s).
    """

    protein_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Protein content of the associated food(s).
    """

    saturated_fat_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Saturated fat content of the associated food(s).
    """

    sodium_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Sodium content of the associated food(s).
    """

    sugar_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Sugar content of the associated food(s).
    """

    trans_fat_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Trans fat content of the associated food(s).
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .timestamp_localization import TimestampLocalization


class NutritionMetadata(UncheckedBaseModel):
    end_time: str = pydantic.Field()
    """
    The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    start_time: str = pydantic.Field()
    """
    The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    timestamp_localization: typing.Optional[TimestampLocalization] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_micros.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel


class NutritionMicros(UncheckedBaseModel):
    biotin_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Biotin content of the associated food(s).
    """

    caffeine_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Caffeine content of the associated food(s).
    """

    calcium_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Calcium content of the associated food(s).
    """

    chloride_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Chloride content of the associated food(s).
    """

    chromium_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Chromium content of the associated food(s).
    """

    copper_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Copper content of the associated food(s).
    """

    folate_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Folate content of the associated food(s).
    """

    folic_acid_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Folic Acid content of the associated food(s).
    """

    iodine_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Iodine content of the associated food(s).
    """

    iron_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Iron content of the associated food(s).
    """

    magnesium_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Magnesium content of the associated food(s).
    """

    manganese_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Manganese content of the associated food(s).
    """

    molybdenum_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Molybdenum content of the associated food(s).
    """

    niacin_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Niacin content of the associated food(s).
    """

    pantothenic_acid_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Pantothenic content of the associated food(s).
    """

    phosphorus_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Phosphorus content of the associated food(s).
    """

    potassium_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Potassium content of the associated food(s).
    """

    riboflavin_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Riboflavin content of the associated food(s).
    """

    selenium_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Selenium content of the associated food(s).
    """

    thiamin_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Thiamin content of the associated food(s).
    """

    vitamin_a_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_A_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin A content of the associated food(s).
    """

    vitamin_b_12_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_B12_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin B12 content of the associated food(s).
    """

    vitamin_b_6_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_B6_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin B6 content of the associated food(s).
    """

    vitamin_c_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_C_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin C content of the associated food(s).
    """

    vitamin_d_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_D_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin D content of the associated food(s).
    """

    vitamin_d_2_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_D2_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin D2 content of the associated food(s).
    """

    vitamin_d_3_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_D3_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin D3 content of the associated food(s).
    """

    vitamin_e_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_E_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin E content of the associated food(s).
    """

    vitamin_k_mg: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="vitamin_K_mg")] = (
        pydantic.Field(default=None)
    )
    """
    Vitamin K content of the associated food(s).
    """

    zinc_mg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Zinc content of the associated food(s).
    """

    cystine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Cystine content of the associated food(s).
    """

    histidine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Histidine content of the associated food(s).
    """

    isoleucine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Isoleucine content of the associated food(s).
    """

    leucine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Leucine content of the associated food(s).
    """

    lysine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Lysine content of the associated food(s).
    """

    methionine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Methionine content of the associated food(s).
    """

    phenylalanine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Phenylalanine content of the associated food(s).
    """

    threonine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Threonine content of the associated food(s).
    """

    tryptophan_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Tryptophan content of the associated food(s).
    """

    tyrosine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Tyrosine content of the associated food(s).
    """

    valine_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Valine content of the associated food(s).
    """

    monounsaturated_fat_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Monounsaturated fat content of the associated food(s).
    """

    polyunsaturated_fat_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Polyunsaturated fat content of the associated food(s).
    """

    omega_3_g: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="omega3_g")] = pydantic.Field(
        default=None
    )
    """
    Omega3 content of the associated food(s).
    """

    omega_6_g: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="omega6_g")] = pydantic.Field(
        default=None
    )
    """
    Omega6 content of the associated food(s).
    """

    starch_g: typing.Optional[float] = pydantic.Field(default=None)
    """
    Starch content of the associated food(s).
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_quantity.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .nutrition_units import NutritionUnits


class NutritionQuantity(UncheckedBaseModel):
    unit: NutritionUnits
    amount: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_summary.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .nutrition_macros import NutritionMacros
from .nutrition_micros import NutritionMicros


class NutritionSummary(UncheckedBaseModel):
    macros: typing.Optional[NutritionMacros] = pydantic.Field(default=None)
    """
    Summary of macronutrient information for a given day.
    """

    micros: typing.Optional[NutritionMicros] = pydantic.Field(default=None)
    """
    Summary of micronutrient information for a given day.
    """

    water_ml: typing.Optional[float] = pydantic.Field(default=None)
    """
    Water consumption of the user for a given day.
    """

    drink_ml: typing.Optional[float] = pydantic.Field(default=None)
    """
    Non-water drink consumption of the user for a given day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_units.py">
```py
# This file was auto-generated by Fern from our API Definition.

NutritionUnits = float

```
</file>
<file path="terra-client-python/src/terra/types/nutrition_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .nutrition_event import NutritionEvent

NutritionWebhook = NutritionEvent

```
</file>
<file path="terra-client-python/src/terra/types/other.py">
```py
# This file was auto-generated by Fern from our API Definition.

Other = float

```
</file>
<file path="terra-client-python/src/terra/types/other_device_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .device_data_type import DeviceDataType


class OtherDeviceData(UncheckedBaseModel):
    manufacturer: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device manufacturer name.
    """

    hardware_version: typing.Optional[str] = pydantic.Field(default=None)
    """
    Hardware version of the device.
    """

    serial_number: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device Serial Number.
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device name - note that this can also be the name of the application/package which the data comes from, if coming from a data aggregator such as Google Fit.
    """

    software_version: typing.Optional[str] = pydantic.Field(default=None)
    """
    Device Software Version.
    """

    activation_timestamp: typing.Optional[str] = None
    data_provided: typing.Optional[typing.List[DeviceDataType]] = None
    last_upload_date: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/other_sleep_durations.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class OtherSleepDurations(UncheckedBaseModel):
    duration_in_bed_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration of time spent in bed.
    """

    duration_unmeasurable_sleep_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration during which the user's state (awake, asleep, REM, etc) was unmeasurable during the sleep session.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/oxygen_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .oxygen_saturation_sample import OxygenSaturationSample
from .vo_2_max_sample import Vo2MaxSample


class OxygenData(UncheckedBaseModel):
    avg_saturation_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average Oxygen Saturation percentage of the user during the day (SpO2 or SmO2).
    """

    saturation_samples: typing.Optional[typing.List[OxygenSaturationSample]] = pydantic.Field(default=None)
    """
    Array of Oxygen Saturation percentage datapoints sampled throughout the day.
    """

    vo_2_samples: typing_extensions.Annotated[
        typing.Optional[typing.List[Vo2MaxSample]], FieldMetadata(alias="vo2_samples")
    ] = pydantic.Field(default=None)
    """
    Array of VO2 datapoints sampled throughout the day.
    """

    vo_2_max_ml_per_min_per_kg: typing_extensions.Annotated[
        typing.Optional[float], FieldMetadata(alias="vo2max_ml_per_min_per_kg")
    ] = pydantic.Field(default=None)
    """
    VO2Max for the given user.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/oxygen_saturation_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .oxygen_saturation_sample import OxygenSaturationSample


class OxygenSaturationData(UncheckedBaseModel):
    avg_saturation_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average Oxygen Saturation percentage of the user during the sleep session.
    """

    end_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The end time of the recording of oxygen saturation, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    samples: typing.Optional[typing.List[OxygenSaturationSample]] = pydantic.Field(default=None)
    """
    Array of Oxygen Saturation percentage datapoints sampled throughout the sleep session.
    """

    start_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The start time of the recording of oxygen saturation, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/oxygen_saturation_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .muscle import Muscle


class OxygenSaturationSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's oxygen saturation percentage - referring to either SpO2 or SmO2, based on the `type` field
    """

    type: typing.Optional[Muscle] = pydantic.Field(default=None)
    """
    Type of oxygen saturation measurement (i.e. blood vs muscle)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/pace_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .pace_planned_workout_step_target_target_type import PacePlannedWorkoutStepTargetTargetType


class PacePlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[PacePlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    pace_minutes_per_kilometer: typing.Optional[float] = pydantic.Field(default=None)
    """
    Ideal pace value to be maintained for the workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/pace_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PacePlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/permission_change_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class PermissionChangeEvent(UncheckedBaseModel):
    """
    Permission change event
    """

    type: typing.Literal["permission_change"] = "permission_change"
    user: TerraUser = pydantic.Field()
    """
    User who changed permissions
    """

    status: typing.Literal["warning"] = pydantic.Field(default="warning")
    """
    Status of the event
    """

    message: str = pydantic.Field()
    """
    Information about the permission change
    """

    version: str = pydantic.Field()
    """
    API version
    """

    scopes_added: str = pydantic.Field()
    """
    Newly added scopes
    """

    scopes_removed: str = pydantic.Field()
    """
    Removed scopes
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/permission_change_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .permission_change_event import PermissionChangeEvent

PermissionChangeWebhook = PermissionChangeEvent

```
</file>
<file path="terra-client-python/src/terra/types/pilates_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget


class PilatesPlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_metadata import PlannedWorkoutMetadata
from .planned_workout_steps import PlannedWorkoutSteps


class PlannedWorkout(UncheckedBaseModel):
    steps: typing.Optional[typing.List[PlannedWorkoutSteps]] = pydantic.Field(default=None)
    """
    List of exercises/steps/intervals for the workout plan
    """

    metadata: typing.Optional[PlannedWorkoutMetadata] = pydantic.Field(default=None)
    """
    Metadata for the workout plan
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_metadata_type import PlannedWorkoutMetadataType


class PlannedWorkoutMetadata(UncheckedBaseModel):
    estimated_energy_kj: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated energy expenditure for the workout
    """

    estimated_speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated speed for the workout
    """

    estimated_elevation_gain_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated elevation gain for the workout
    """

    estimated_tss: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated Training Stress Score for the workout
    """

    estimated_calories: typing.Optional[int] = pydantic.Field(default=None)
    """
    Estimated calorie burn for the workout
    """

    created_date: typing.Optional[dt.datetime] = pydantic.Field(default=None)
    """
    The creation datetime of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    planned_date: typing.Optional[dt.datetime] = pydantic.Field(default=None)
    """
    The planned start datetime, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    type: typing.Optional[PlannedWorkoutMetadataType] = pydantic.Field(default=None)
    """
    The name - either user-entered or given by the fitness data provider - of the associated workout plan
    """

    id: typing.Optional[str] = None
    estimated_duration_seconds: typing.Optional[int] = pydantic.Field(default=None)
    """
    Estimated workout duration
    """

    estimated_pace_minutes_per_kilometer: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated pace for the workout
    """

    provider: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of the original source of the workout plan
    """

    estimated_tscore: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated training stress score for the workout (normalized power-based metric)
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of the workout
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of the workout plan
    """

    estimated_distance_meters: typing.Optional[int] = pydantic.Field(default=None)
    """
    Estimated distance for the workout
    """

    estimated_if: typing.Optional[float] = pydantic.Field(default=None)
    """
    Estimated Intensity Factor for the workout
    """

    pool_length_meters: typing.Optional[int] = pydantic.Field(default=None)
    """
    Pool length of the pool used for the workout - only relevant for swimming activity types
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_metadata_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PlannedWorkoutMetadataType = typing.Union[
    typing.Literal[
        "IN_VEHICLE",
        "BIKING",
        "STILL",
        "UNKNOWN",
        "TILTING",
        "WALKING",
        "RUNNING",
        "AEROBICS",
        "BADMINTON",
        "BASEBALL",
        "BASKETBALL",
        "BIATHLON",
        "HANDBIKING",
        "MOUNTAIN_BIKING",
        "ROAD_BIKING",
        "SPINNING",
        "STATIONARY_BIKING",
        "UTILITY_BIKING",
        "BOXING",
        "CALISTHENICS",
        "CIRCUIT_TRAINING",
        "CRICKET",
        "DANCING",
        "ELLIPTICAL",
        "FENCING",
        "AMERICAN_FOOTBALL",
        "AUSTRALIAN_FOOTBALL",
        "ENGLISH_FOOTBALL",
        "FRISBEE",
        "GARDENING",
        "GOLF",
        "GYMNASTICS",
        "HANDBALL",
        "HIKING",
        "HOCKEY",
        "HORSEBACK_RIDING",
        "HOUSEWORK",
        "JUMPING_ROPE",
        "KAYAKING",
        "KETTLEBELL_TRAINING",
        "KICKBOXING",
        "KITESURFING",
        "MARTIAL_ARTS",
        "MEDITATION",
        "MIXED_MARTIAL_ARTS",
        "P90X_EXERCISES",
        "PARAGLIDING",
        "PILATES",
        "POLO",
        "RACQUETBALL",
        "ROCK_CLIMBING",
        "ROWING",
        "ROWING_MACHINE",
        "RUGBY",
        "JOGGING",
        "RUNNING_ON_SAND",
        "TREADMILL_RUNNING",
        "SAILING",
        "SCUBA_DIVING",
        "SKATEBOARDING",
        "SKATING",
        "CROSS_SKATING",
        "INDOOR_ROLLERBLADING",
        "SKIING",
        "BACK_COUNTRY_SKIING",
        "CROSS_COUNTRY_SKIING",
        "DOWNHILL_SKIING",
        "KITE_SKIING",
        "ROLLER_SKIING",
        "SLEDDING",
        "SNOWBOARDING",
        "SNOWMOBILE",
        "SNOWSHOEING",
        "SQUASH",
        "STAIR_CLIMBING",
        "STAIR_CLIMBING_MACHINE",
        "STAND_UP_PADDLEBOARDING",
        "STRENGTH_TRAINING",
        "SURFING",
        "SWIMMING",
        "SWIMMING_SWIMMING_POOL",
        "SWIMMING_OPEN_WATER",
        "TABLE_TENNIS",
        "TEAM_SPORTS",
        "TENNIS",
        "TREADMILL",
        "VOLLEYBALL",
        "VOLLEYBALL_BEACH",
        "VOLLEYBALL_INDOOR",
        "WAKEBOARDING",
        "WALKING_FITNESS",
        "NORDIC_WALKING",
        "WALKING_TREADMILL",
        "WATERPOLO",
        "WEIGHTLIFTING",
        "WHEELCHAIR",
        "WINDSURFING",
        "YOGA",
        "ZUMBA",
        "DIVING",
        "ERGOMETER",
        "ICE_SKATING",
        "INDOOR_SKATING",
        "CURLING",
        "OTHER",
        "CROSSFIT",
        "HIIT",
        "INTERVAL_TRAINING",
        "WALKING_STROLLER",
        "ELEVATOR",
        "ESCALATOR",
        "ARCHERY",
        "SOFTBALL",
        "GUIDED_BREATHING",
        "CARDIO_TRAINING",
        "LACROSSE",
        "STRETCHING",
        "TRIATHLON",
        "INLINE_SKATING",
        "SKY_DIVING",
        "PADDLING",
        "MOUNTAINEERING",
        "FISHING",
        "WATER_SKIING",
        "INDOOR_RUNNING",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_repeat_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step import PlannedWorkoutStep
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget


class PlannedWorkoutRepeatStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    steps: typing.Optional[typing.List[PlannedWorkoutStep]] = pydantic.Field(default=None)
    """
    List of steps to be repeated for this workout step - e.g. if a user wants to schedule 5 repetitions of 100m sprints plus 20s rest in between
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_durations import PlannedWorkoutStepDurations
from .planned_workout_step_intensity import PlannedWorkoutStepIntensity
from .planned_workout_step_targets import PlannedWorkoutStepTargets


class PlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTargets]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[PlannedWorkoutStepIntensity] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDurations]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration_duration_type import PlannedWorkoutStepDurationDurationType


class PlannedWorkoutStepDuration(UncheckedBaseModel):
    duration_type: typing.Optional[PlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_durations.py">
```py
# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from .calories_planned_workout_step_duration_duration_type import CaloriesPlannedWorkoutStepDurationDurationType
from .distance_planned_workout_step_duration_duration_type import DistancePlannedWorkoutStepDurationDurationType
from .fixed_rest_planned_workout_step_duration_duration_type import FixedRestPlannedWorkoutStepDurationDurationType
from .hr_above_planned_workout_step_duration_duration_type import HrAbovePlannedWorkoutStepDurationDurationType
from .hr_below_planned_workout_step_duration_duration_type import HrBelowPlannedWorkoutStepDurationDurationType
from .planned_workout_step_duration_duration_type import PlannedWorkoutStepDurationDurationType
from .power_above_planned_workout_step_duration_duration_type import PowerAbovePlannedWorkoutStepDurationDurationType
from .power_below_planned_workout_step_duration_duration_type import PowerBelowPlannedWorkoutStepDurationDurationType
from .reps_planned_workout_step_duration_duration_type import RepsPlannedWorkoutStepDurationDurationType
from .steps_planned_workout_step_duration_duration_type import StepsPlannedWorkoutStepDurationDurationType
from .time_planned_workout_step_duration_duration_type import TimePlannedWorkoutStepDurationDurationType


class PlannedWorkoutStepDurations_PlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["PlannedWorkoutStepDuration"] = "PlannedWorkoutStepDuration"
    duration_type: typing.Optional[PlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_TimePlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["TimePlannedWorkoutStepDuration"] = "TimePlannedWorkoutStepDuration"
    seconds: typing.Optional[int] = None
    duration_type: typing.Optional[TimePlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_PowerAbovePlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["PowerAbovePlannedWorkoutStepDuration"] = "PowerAbovePlannedWorkoutStepDuration"
    power_above_watts: typing.Optional[int] = None
    duration_type: typing.Optional[PowerAbovePlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_PowerBelowPlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["PowerBelowPlannedWorkoutStepDuration"] = "PowerBelowPlannedWorkoutStepDuration"
    power_below_watts: typing.Optional[int] = None
    duration_type: typing.Optional[PowerBelowPlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_FixedRestPlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["FixedRestPlannedWorkoutStepDuration"] = "FixedRestPlannedWorkoutStepDuration"
    duration_type: typing.Optional[FixedRestPlannedWorkoutStepDurationDurationType] = None
    rest_seconds: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_CaloriesPlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["CaloriesPlannedWorkoutStepDuration"] = "CaloriesPlannedWorkoutStepDuration"
    calories: typing.Optional[int] = None
    duration_type: typing.Optional[CaloriesPlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_HrAbovePlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["HRAbovePlannedWorkoutStepDuration"] = "HRAbovePlannedWorkoutStepDuration"
    duration_type: typing.Optional[HrAbovePlannedWorkoutStepDurationDurationType] = None
    hr_above_bpm: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_HrBelowPlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["HRBelowPlannedWorkoutStepDuration"] = "HRBelowPlannedWorkoutStepDuration"
    hr_below_bpm: typing.Optional[int] = None
    duration_type: typing.Optional[HrBelowPlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_RepsPlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["RepsPlannedWorkoutStepDuration"] = "RepsPlannedWorkoutStepDuration"
    reps: typing.Optional[int] = None
    duration_type: typing.Optional[RepsPlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_DistancePlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["DistancePlannedWorkoutStepDuration"] = "DistancePlannedWorkoutStepDuration"
    duration_type: typing.Optional[DistancePlannedWorkoutStepDurationDurationType] = None
    distance_meters: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepDurations_StepsPlannedWorkoutStepDuration(UncheckedBaseModel):
    type: typing.Literal["StepsPlannedWorkoutStepDuration"] = "StepsPlannedWorkoutStepDuration"
    steps: typing.Optional[int] = None
    duration_type: typing.Optional[StepsPlannedWorkoutStepDurationDurationType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


PlannedWorkoutStepDurations = typing_extensions.Annotated[
    typing.Union[
        PlannedWorkoutStepDurations_PlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_TimePlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_PowerAbovePlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_PowerBelowPlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_FixedRestPlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_CaloriesPlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_HrAbovePlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_HrBelowPlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_RepsPlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_DistancePlannedWorkoutStepDuration,
        PlannedWorkoutStepDurations_StepsPlannedWorkoutStepDuration,
    ],
    UnionMetadata(discriminant="type"),
]

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_intensity.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PlannedWorkoutStepIntensity = typing.Union[
    typing.Literal["REST", "WARMUP", "COOLDOWN", "RECOVERY", "INTERVAL", "ACTIVE"], typing.Any
]

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_target_target_type import PlannedWorkoutStepTargetTargetType


class PlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[PlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_step_targets.py">
```py
# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from .cadence_planned_workout_step_target_target_type import CadencePlannedWorkoutStepTargetTargetType
from .hr_planned_workout_step_target_target_type import HrPlannedWorkoutStepTargetTargetType
from .if_planned_workout_step_target_target_type import IfPlannedWorkoutStepTargetTargetType
from .pace_planned_workout_step_target_target_type import PacePlannedWorkoutStepTargetTargetType
from .planned_workout_step_target_target_type import PlannedWorkoutStepTargetTargetType
from .power_planned_workout_step_target_target_type import PowerPlannedWorkoutStepTargetTargetType
from .repetition_planned_workout_step_target_target_type import RepetitionPlannedWorkoutStepTargetTargetType
from .speed_planned_workout_step_target_target_type import SpeedPlannedWorkoutStepTargetTargetType
from .swim_stroke_planned_workout_step_target_target_type import SwimStrokePlannedWorkoutStepTargetTargetType
from .tss_planned_workout_step_target_target_type import TssPlannedWorkoutStepTargetTargetType


class PlannedWorkoutStepTargets_PlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["PlannedWorkoutStepTarget"] = "PlannedWorkoutStepTarget"
    target_type: typing.Optional[PlannedWorkoutStepTargetTargetType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_CadencePlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["CadencePlannedWorkoutStepTarget"] = "CadencePlannedWorkoutStepTarget"
    cadence: typing.Optional[int] = None
    target_type: typing.Optional[CadencePlannedWorkoutStepTargetTargetType] = None
    cadence_low: typing.Optional[int] = None
    cadence_high: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_HrPlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["HRPlannedWorkoutStepTarget"] = "HRPlannedWorkoutStepTarget"
    hr_percentage_low: typing.Optional[float] = None
    target_type: typing.Optional[HrPlannedWorkoutStepTargetTargetType] = None
    hr_percentage_high: typing.Optional[float] = None
    hr_percentage: typing.Optional[float] = None
    hr_bpm_high: typing.Optional[int] = None
    hr_bpm_low: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_PowerPlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["PowerPlannedWorkoutStepTarget"] = "PowerPlannedWorkoutStepTarget"
    target_type: typing.Optional[PowerPlannedWorkoutStepTargetTargetType] = None
    power_percentage_low: typing.Optional[float] = None
    power_percentage_high: typing.Optional[float] = None
    power_watt_high: typing.Optional[int] = None
    power_watt_low: typing.Optional[int] = None
    power_watt: typing.Optional[int] = None
    power_percentage: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_SpeedPlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["SpeedPlannedWorkoutStepTarget"] = "SpeedPlannedWorkoutStepTarget"
    target_type: typing.Optional[SpeedPlannedWorkoutStepTargetTargetType] = None
    speed_percentage_high: typing.Optional[float] = None
    speed_percentage_low: typing.Optional[float] = None
    speed_percentage: typing.Optional[float] = None
    speed_meters_per_second: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_PacePlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["PacePlannedWorkoutStepTarget"] = "PacePlannedWorkoutStepTarget"
    target_type: typing.Optional[PacePlannedWorkoutStepTargetTargetType] = None
    pace_minutes_per_kilometer: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_TssPlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["TSSPlannedWorkoutStepTarget"] = "TSSPlannedWorkoutStepTarget"
    target_type: typing.Optional[TssPlannedWorkoutStepTargetTargetType] = None
    tss: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_IfPlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["IFPlannedWorkoutStepTarget"] = "IFPlannedWorkoutStepTarget"
    if_high: typing.Optional[float] = None
    target_type: typing.Optional[IfPlannedWorkoutStepTargetTargetType] = None
    if_low: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_RepetitionPlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["RepetitionPlannedWorkoutStepTarget"] = "RepetitionPlannedWorkoutStepTarget"
    target_type: typing.Optional[RepetitionPlannedWorkoutStepTargetTargetType] = None
    repetitions: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutStepTargets_SwimStrokePlannedWorkoutStepTarget(UncheckedBaseModel):
    type: typing.Literal["SwimStrokePlannedWorkoutStepTarget"] = "SwimStrokePlannedWorkoutStepTarget"
    target_type: typing.Optional[SwimStrokePlannedWorkoutStepTargetTargetType] = None
    swim_strokes: typing.Optional[int] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


PlannedWorkoutStepTargets = typing_extensions.Annotated[
    typing.Union[
        PlannedWorkoutStepTargets_PlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_CadencePlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_HrPlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_PowerPlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_SpeedPlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_PacePlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_TssPlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_IfPlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_RepetitionPlannedWorkoutStepTarget,
        PlannedWorkoutStepTargets_SwimStrokePlannedWorkoutStepTarget,
    ],
    UnionMetadata(discriminant="type"),
]

```
</file>
<file path="terra-client-python/src/terra/types/planned_workout_steps.py">
```py
# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from .cardio_planned_workout_step_exercise_category import CardioPlannedWorkoutStepExerciseCategory
from .planned_workout_step import PlannedWorkoutStep
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_durations import PlannedWorkoutStepDurations
from .planned_workout_step_intensity import PlannedWorkoutStepIntensity
from .planned_workout_step_target import PlannedWorkoutStepTarget
from .planned_workout_step_targets import PlannedWorkoutStepTargets
from .strength_planned_workout_step_exercise_category import StrengthPlannedWorkoutStepExerciseCategory
from .swimming_planned_workout_step_equipment_type import SwimmingPlannedWorkoutStepEquipmentType
from .swimming_planned_workout_step_stroke_type import SwimmingPlannedWorkoutStepStrokeType


class PlannedWorkoutSteps_PlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["PlannedWorkoutStep"] = "PlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTargets]] = None
    intensity: typing.Optional[PlannedWorkoutStepIntensity] = None
    order: typing.Optional[int] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDurations]] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_PlannedWorkoutRepeatStep(UncheckedBaseModel):
    type: typing.Literal["PlannedWorkoutRepeatStep"] = "PlannedWorkoutRepeatStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    steps: typing.Optional[typing.List[PlannedWorkoutStep]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_SwimmingPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["SwimmingPlannedWorkoutStep"] = "SwimmingPlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    equipment_type: typing.Optional[SwimmingPlannedWorkoutStepEquipmentType] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    name: typing.Optional[str] = None
    stroke_type: typing.Optional[SwimmingPlannedWorkoutStepStrokeType] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_CardioPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["CardioPlannedWorkoutStep"] = "CardioPlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    exercise_name: typing.Optional[str] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    exercise_category: typing.Optional[CardioPlannedWorkoutStepExerciseCategory] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_StrengthPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["StrengthPlannedWorkoutStep"] = "StrengthPlannedWorkoutStep"
    weight_kg: typing.Optional[float] = None
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    exercise_name: typing.Optional[str] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    exercise_category: typing.Optional[StrengthPlannedWorkoutStepExerciseCategory] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_YogaPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["YogaPlannedWorkoutStep"] = "YogaPlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_PilatesPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["PilatesPlannedWorkoutStep"] = "PilatesPlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_RunningPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["RunningPlannedWorkoutStep"] = "RunningPlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PlannedWorkoutSteps_CyclingPlannedWorkoutStep(UncheckedBaseModel):
    type: typing.Literal["CyclingPlannedWorkoutStep"] = "CyclingPlannedWorkoutStep"
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = None
    intensity: typing.Optional[int] = None
    order: typing.Optional[int] = None
    description: typing.Optional[str] = None
    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = None
    name: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


PlannedWorkoutSteps = typing_extensions.Annotated[
    typing.Union[
        PlannedWorkoutSteps_PlannedWorkoutStep,
        PlannedWorkoutSteps_PlannedWorkoutRepeatStep,
        PlannedWorkoutSteps_SwimmingPlannedWorkoutStep,
        PlannedWorkoutSteps_CardioPlannedWorkoutStep,
        PlannedWorkoutSteps_StrengthPlannedWorkoutStep,
        PlannedWorkoutSteps_YogaPlannedWorkoutStep,
        PlannedWorkoutSteps_PilatesPlannedWorkoutStep,
        PlannedWorkoutSteps_RunningPlannedWorkoutStep,
        PlannedWorkoutSteps_CyclingPlannedWorkoutStep,
    ],
    UnionMetadata(discriminant="type"),
]

```
</file>
<file path="terra-client-python/src/terra/types/polyline_map_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class PolylineMapData(UncheckedBaseModel):
    summary_polyline: typing.Optional[str] = pydantic.Field(default=None)
    """
    The polyline representation of the user's trajectory throughout the workout
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/position_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .position_sample import PositionSample


class PositionData(UncheckedBaseModel):
    center_pos_lat_lng_deg: typing.Optional[typing.List[float]] = pydantic.Field(default=None)
    """
    Position of the user at the midway point of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable.
    """

    end_pos_lat_lng_deg: typing.Optional[typing.List[float]] = pydantic.Field(default=None)
    """
    Position of the user at the end of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable.
    """

    position_samples: typing.Optional[typing.List[PositionSample]] = pydantic.Field(default=None)
    """
    Array of datapoints of the position of the user, sampled throughout the workout.
    """

    start_pos_lat_lng_deg: typing.Optional[typing.List[float]] = pydantic.Field(default=None)
    """
    Position of the user at the start of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/position_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class PositionSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    coords_lat_lng_deg: typing.Optional[typing.List[typing.Optional[typing.Any]]] = pydantic.Field(default=None)
    """
    Position of the user a given point in time, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/power_above_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .power_above_planned_workout_step_duration_duration_type import PowerAbovePlannedWorkoutStepDurationDurationType


class PowerAbovePlannedWorkoutStepDuration(UncheckedBaseModel):
    power_above_watts: typing.Optional[int] = pydantic.Field(default=None)
    """
    Threshold power goal to complete the workout step - once the user reaches above this power level, the step will be completed
    """

    duration_type: typing.Optional[PowerAbovePlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/power_above_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PowerAbovePlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/power_below_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .power_below_planned_workout_step_duration_duration_type import PowerBelowPlannedWorkoutStepDurationDurationType


class PowerBelowPlannedWorkoutStepDuration(UncheckedBaseModel):
    power_below_watts: typing.Optional[int] = pydantic.Field(default=None)
    """
    Threshold power goal to complete the workout step - once the user reaches below this power level, the step will be completed
    """

    duration_type: typing.Optional[PowerBelowPlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/power_below_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PowerBelowPlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/power_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .power_sample import PowerSample


class PowerData(UncheckedBaseModel):
    avg_watts: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average power output of the user during the workout.
    """

    max_watts: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum power output of the user during the workout.
    """

    power_samples: typing.Optional[typing.List[PowerSample]] = pydantic.Field(default=None)
    """
    Array containing datapoints of the power output of the user sampled throughout the workout.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/power_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .power_planned_workout_step_target_target_type import PowerPlannedWorkoutStepTargetTargetType


class PowerPlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[PowerPlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    power_percentage_low: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum percentage of Functional Threshold Power for the workout step - i.e. the user is to stay under this value during the workout step
    """

    power_percentage_high: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum percentage of Functional Threshold Power for the workout step - i.e. the user is to stay above this value during the workout
    """

    power_watt_high: typing.Optional[int] = pydantic.Field(default=None)
    """
    Maximum power threshold for the workout step - i.e. the user is to stay under this value during the workout step
    """

    power_watt_low: typing.Optional[int] = pydantic.Field(default=None)
    """
    Minimum power threshold for the workout step - i.e. the user is to stay above this value during the workout
    """

    power_watt: typing.Optional[int] = None
    power_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Ideal percentage of user's Functional Threshold Power to be maintained workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/power_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

PowerPlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/power_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class PowerSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    watts: typing.Optional[float] = pydantic.Field(default=None)
    """
    Power generated at a given instant in time, in Watts
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/processing_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class ProcessingEvent(UncheckedBaseModel):
    """
    Processing event returned when data is being fetched asynchronously
    """

    type: typing.Literal["processing"] = "processing"
    status: typing.Literal["success"] = pydantic.Field(default="success")
    """
    Status of the processing
    """

    message: str = pydantic.Field()
    """
    Information about the processing
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being processed
    """

    retry_after_seconds: int = pydantic.Field()
    """
    Seconds to wait before retrying
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/pulse_velocity_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class PulseVelocitySample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    pulse_wave_velocity_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's Pulse Wave Velocity measurement - velocity at which the blood pressure pulse propagates through the circulatory system
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/rate_limit_hit_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class RateLimitHitEvent(UncheckedBaseModel):
    """
    Rate limit hit event
    """

    type: typing.Literal["rate_limit_hit"] = "rate_limit_hit"
    user: TerraUser = pydantic.Field()
    """
    User whose request hit rate limits
    """

    start_date: str = pydantic.Field()
    """
    Start date of the requested data range
    """

    end_date: str = pydantic.Field()
    """
    End date of the requested data range
    """

    retrying_at: str = pydantic.Field()
    """
    When the request will be retried
    """

    message: str = pydantic.Field()
    """
    Information about the rate limit
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/rate_limit_hit_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .rate_limit_hit_event import RateLimitHitEvent

RateLimitHitWebhook = RateLimitHitEvent

```
</file>
<file path="terra-client-python/src/terra/types/rate_limit_request_processing.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class RateLimitRequestProcessing(UncheckedBaseModel):
    message: typing.Optional[str] = None
    type: typing.Optional[str] = None
    user: TerraUser

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/raw_ecg_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel


class RawEcgSample(UncheckedBaseModel):
    potential_u_v: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="potential_uV")] = (
        pydantic.Field(default=None)
    )
    """
    Potential uV in the RawECG Sample
    """

    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/readiness_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .recovery_level import RecoveryLevel


class ReadinessData(UncheckedBaseModel):
    readiness: typing.Optional[int] = pydantic.Field(default=None)
    """
    User's readiness score for a given day, resulting from the sleep session.
    """

    recovery_level: typing.Optional[RecoveryLevel] = pydantic.Field(default=None)
    """
    User's recovery score for a given day, resulting from the sleep session - takes Enum value.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/recovery_level.py">
```py
# This file was auto-generated by Fern from our API Definition.

RecoveryLevel = float

```
</file>
<file path="terra-client-python/src/terra/types/repetition_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .repetition_planned_workout_step_target_target_type import RepetitionPlannedWorkoutStepTargetTargetType


class RepetitionPlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[RepetitionPlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    repetitions: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number of repetitions of the workout step to be performed
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/repetition_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

RepetitionPlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/reps_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .reps_planned_workout_step_duration_duration_type import RepsPlannedWorkoutStepDurationDurationType


class RepsPlannedWorkoutStepDuration(UncheckedBaseModel):
    reps: typing.Optional[int] = pydantic.Field(default=None)
    """
    Target number of reps for the workout step - once the user completes this rep target, the step will be completed
    """

    duration_type: typing.Optional[RepsPlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/reps_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

RepsPlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/request_processing.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class RequestProcessing(UncheckedBaseModel):
    retry_after_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Recommended time after which the request may be retried
    """

    message: typing.Optional[str] = None
    type: typing.Optional[str] = None
    user: typing.Optional[TerraUser] = pydantic.Field(default=None)
    """
    Terra User object
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/respiration_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .breaths_data import BreathsData
from .oxygen_saturation_data import OxygenSaturationData
from .snoring_data import SnoringData


class RespirationData(UncheckedBaseModel):
    breaths_data: typing.Optional[BreathsData] = pydantic.Field(default=None)
    """
    Object containing information on breathing rate for the sleep session.
    """

    oxygen_saturation_data: typing.Optional[OxygenSaturationData] = pydantic.Field(default=None)
    """
    Object containing information on saturation metrics for the sleep session.
    """

    snoring_data: typing.Optional[SnoringData] = pydantic.Field(default=None)
    """
    Object containing information on snoring metrics for the sleep session.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/rr_interval_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class RrIntervalSample(UncheckedBaseModel):
    rr_interval_ms: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's RR Interval for a specific heart beat in milliseconds.
    """

    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    hr_bpm: typing.Optional[float] = pydantic.Field(default=None)
    """
    The heart beat value at that specific instance.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/running_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget


class RunningPlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/s_3_payload_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class S3PayloadEvent(UncheckedBaseModel):
    """
    S3 Upload event with data download URL
    """

    type: typing.Literal["s3_payload"] = "s3_payload"
    status: typing.Literal["success"] = pydantic.Field(default="success")
    """
    Status of the upload
    """

    url: str = pydantic.Field()
    """
    URL to download the data
    """

    expires_in: int = pydantic.Field()
    """
    Time in seconds until URL expiration
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/s_3_upload_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .s_3_payload_event import S3PayloadEvent

S3UploadWebhook = S3PayloadEvent

```
</file>
<file path="terra-client-python/src/terra/types/scores_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class ScoresData(UncheckedBaseModel):
    activity: typing.Optional[float] = pydantic.Field(default=None)
    """
    Activity score for the given day.
    """

    recovery: typing.Optional[float] = pydantic.Field(default=None)
    """
    Recovery score for the given day.
    """

    sleep: typing.Optional[float] = pydantic.Field(default=None)
    """
    Sleep score for the given day, pertaining to the previous night's sleep.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .device_data import DeviceData
from .heart_rate_data import HeartRateData
from .readiness_data import ReadinessData
from .respiration_data import RespirationData
from .sleep_data_enrichment import SleepDataEnrichment
from .sleep_durations_data import SleepDurationsData
from .sleep_metadata import SleepMetadata
from .sleep_scores import SleepScores
from .sleep_temperature_data import SleepTemperatureData


class Sleep(UncheckedBaseModel):
    data_enrichment: typing.Optional[SleepDataEnrichment] = pydantic.Field(default=None)
    """
    Object containing additional enrichment data for the sleep session.
    """

    device_data: typing.Optional[DeviceData] = pydantic.Field(default=None)
    """
    Object containing information on the device which recorded data for the payload.
    """

    heart_rate_data: typing.Optional[HeartRateData] = pydantic.Field(default=None)
    """
    Object containing information on the user's heart rate during the sleep session.
    """

    metadata: SleepMetadata = pydantic.Field()
    """
    Object containing daily summary metadata.
    """

    readiness_data: typing.Optional[ReadinessData] = pydantic.Field(default=None)
    """
    Object containing information on the user's readiness for the day, based off the quality and duration of their sleep.
    """

    respiration_data: typing.Optional[RespirationData] = pydantic.Field(default=None)
    """
    Object containing information on the user's respiration throughout the sleep session.
    """

    scores: typing.Optional[SleepScores] = pydantic.Field(default=None)
    """
    User's sleep score
    """

    sleep_durations_data: typing.Optional[SleepDurationsData] = pydantic.Field(default=None)
    """
    Object containing information on the user's duration spent in various sleep stages.
    """

    temperature_data: typing.Optional[SleepTemperatureData] = pydantic.Field(default=None)
    """
    Object containing body temperature information of the user during the sleep recording session.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_data_enrichment.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .data_contributor import DataContributor


class SleepDataEnrichment(UncheckedBaseModel):
    sleep_contributors: typing.Optional[typing.List[DataContributor]] = None
    sleep_score: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_durations_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .asleep_durations import AsleepDurations
from .awake_durations import AwakeDurations
from .other_sleep_durations import OtherSleepDurations
from .sleep_hypnogram_sample import SleepHypnogramSample


class SleepDurationsData(UncheckedBaseModel):
    asleep: typing.Optional[AsleepDurations] = pydantic.Field(default=None)
    """
    Object containing information on the duration the user spent asleep during the sleep recording session.
    """

    awake: typing.Optional[AwakeDurations] = pydantic.Field(default=None)
    """
    Object containing information on the duration the user spent awake during the sleep recording session.
    """

    hypnogram_samples: typing.Optional[typing.List[SleepHypnogramSample]] = pydantic.Field(default=None)
    """
    List of sleep stage (Hypnogram) samples recorded during the user's sleep session.
    """

    other: typing.Optional[OtherSleepDurations] = pydantic.Field(default=None)
    """
    Object containing information on the miscellaneous duration data for the sleep recording session.
    """

    sleep_efficiency: typing.Optional[float] = pydantic.Field(default=None)
    """
    Sleep efficiency of the user given as a percentage, measured as time spent asleep divided by time spent in bed.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .sleep import Sleep
from .terra_user import TerraUser


class SleepEvent(UncheckedBaseModel):
    """
    Sleep data event
    """

    type: typing.Literal["sleep"] = "sleep"
    data: typing.List[Sleep] = pydantic.Field()
    """
    Array of sleep data
    """

    user: TerraUser = pydantic.Field()
    """
    User whose data is being provided
    """

    version: str = pydantic.Field()
    """
    API version
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_hypnogram_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .sleep_level import SleepLevel


class SleepHypnogramSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    level: typing.Optional[SleepLevel] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_level.py">
```py
# This file was auto-generated by Fern from our API Definition.

SleepLevel = float

```
</file>
<file path="terra-client-python/src/terra/types/sleep_metadata.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .indeterminate import Indeterminate
from .timestamp_localization import TimestampLocalization


class SleepMetadata(UncheckedBaseModel):
    end_time: str = pydantic.Field()
    """
    The end time of the associated sleep session, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    is_nap: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Flag indicating whether the sleep session was a nap, or the user's main sleep session for the day.
    """

    start_time: str = pydantic.Field()
    """
    The start time of the associated sleep session, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    summary_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    A unique identifier for the sleep session.
    """

    timestamp_localization: typing.Optional[TimestampLocalization] = None
    upload_type: Indeterminate = pydantic.Field()
    """
    The upload type for the associated sleep session, providing information on whether this was an automatic sleep or user-entered.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_scores.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class SleepScores(UncheckedBaseModel):
    """
    User's sleep score
    """

    sleep_score: typing.Optional[float] = pydantic.Field(default=None)
    """
    User's sleep score.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_temperature_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class SleepTemperatureData(UncheckedBaseModel):
    delta: typing.Optional[float] = pydantic.Field(default=None)
    """
    Variation in user's skin temperature from their baseline.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/sleep_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .sleep_event import SleepEvent

SleepWebhook = SleepEvent

```
</file>
<file path="terra-client-python/src/terra/types/snack.py">
```py
# This file was auto-generated by Fern from our API Definition.

Snack = float

```
</file>
<file path="terra-client-python/src/terra/types/snoring_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .snoring_sample import SnoringSample


class SnoringData(UncheckedBaseModel):
    start_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The start time of the recording of snoring data, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    end_time: typing.Optional[str] = pydantic.Field(default=None)
    """
    The end time of the recording of snoring data, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    num_snoring_events: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of times over the sleep period when the user started snoring, as determined by the device.
    """

    samples: typing.Optional[typing.List[SnoringSample]] = pydantic.Field(default=None)
    """
    List of snoring information data points sampled throughout the sleep session.
    """

    total_snoring_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total duration for which the user was snoring.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/snoring_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class SnoringSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Duration of snoring episode, in seconds
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/speed_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .speed_planned_workout_step_target_target_type import SpeedPlannedWorkoutStepTargetTargetType


class SpeedPlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[SpeedPlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    speed_percentage_high: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum speed threshold for the workout step - i.e. the user is to stay under this value during the workout step
    """

    speed_percentage_low: typing.Optional[float] = pydantic.Field(default=None)
    """
    Minimum speed threshold for the workout step - i.e. the user is to stay above this value during the workout step
    """

    speed_percentage: typing.Optional[float] = pydantic.Field(default=None)
    """
    Ideal percentage of user's Threshold Speed, based off their Threshold Pace, to be maintained workout step. Usually, the Threshold Pace is defined as the pace one could race at for 50 to 60 minutes
    """

    speed_meters_per_second: typing.Optional[float] = pydantic.Field(default=None)
    """
    Ideal speed value to be maintained for the workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/speed_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

SpeedPlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/speed_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class SpeedSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    speed_meters_per_second: typing.Optional[float] = None
    timer_duration_seconds: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/step_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class StepSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    steps: typing.Optional[int] = None
    timer_duration_seconds: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/steps_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .steps_planned_workout_step_duration_duration_type import StepsPlannedWorkoutStepDurationDurationType


class StepsPlannedWorkoutStepDuration(UncheckedBaseModel):
    steps: typing.Optional[int] = pydantic.Field(default=None)
    """
    Target number of steps for the workout step - once the user performs this number of steps, the step will be completed
    """

    duration_type: typing.Optional[StepsPlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/steps_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

StepsPlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/strain_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class StrainData(UncheckedBaseModel):
    strain_level: typing.Optional[float] = pydantic.Field(default=None)
    """
    Level of cardiovascular strain imposed on the user during the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/strength_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget
from .strength_planned_workout_step_exercise_category import StrengthPlannedWorkoutStepExerciseCategory


class StrengthPlannedWorkoutStep(UncheckedBaseModel):
    weight_kg: typing.Optional[float] = pydantic.Field(default=None)
    """
    Weight to be lifted for the exercise
    """

    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    exercise_name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of strength exercise to be performed for the workout step
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    exercise_category: typing.Optional[StrengthPlannedWorkoutStepExerciseCategory] = pydantic.Field(default=None)
    """
    Type of strength exercise to be performed for the workout step
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/strength_planned_workout_step_exercise_category.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

StrengthPlannedWorkoutStepExerciseCategory = typing.Union[
    typing.Literal[
        "UNKNOWN",
        "BENCH_PRESS",
        "CALF_RAISE",
        "CARDIO",
        "CARRY",
        "CHOP",
        "CORE",
        "CRUNCH",
        "CURL",
        "DEADLIFT",
        "FLYE",
        "HIP_RAISE",
        "HIP_STABILITY",
        "HIP_SWING",
        "HYPEREXTENSION",
        "LATERAL_RAISE",
        "LEG_CURL",
        "LEG_RAISE",
        "LUNGE",
        "OLYMPIC_LIFT",
        "PLANK",
        "PLYO",
        "PULL_UP",
        "PUSH_UP",
        "ROW",
        "SHOULDER_PRESS",
        "SHOULDER_STABILITY",
        "SHRUG",
        "SIT_UP",
        "SQUAT",
        "TOTAL_BODY",
        "TRICEPS_EXTENSION",
        "WARM_UP",
        "RUN",
        "BIKE",
        "CARDIO_SENSORS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/stress_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .body_battery_sample import BodyBatterySample
from .high import High
from .stress_sample import StressSample


class StressData(UncheckedBaseModel):
    avg_stress_level: typing.Optional[float] = pydantic.Field(default=None)
    """
    Average stress level for the day.
    """

    activity_stress_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a stressed state while active during the day.
    """

    low_stress_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a state of low stress during the day.
    """

    max_stress_level: typing.Optional[float] = pydantic.Field(default=None)
    """
    Maximum stress level recorded during the day.
    """

    medium_stress_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a state of medium stress during the day.
    """

    samples: typing.Optional[typing.List[StressSample]] = pydantic.Field(default=None)
    """
    Array of stress level data points sampled throughout the day.
    """

    rest_stress_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a stressed state while at rest during the day.
    """

    high_stress_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a state of high stress during the day.
    """

    stress_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total number of seconds spent in a stressed state while at rest during the day.
    """

    stress_rating: typing.Optional[High] = pydantic.Field(default=None)
    """
    Stress rating for the day.
    """

    body_battery_samples: typing.Optional[typing.List[BodyBatterySample]] = pydantic.Field(default=None)
    """
    Array of Body Battery data points sampled throughout the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/stress_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class StressSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    level: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/stroke_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

StrokeType = typing.Union[typing.Literal["other", "freestyle", "backstroke", "breaststroke", "butterfly"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/types/swim_stroke_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .swim_stroke_planned_workout_step_target_target_type import SwimStrokePlannedWorkoutStepTargetTargetType


class SwimStrokePlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[SwimStrokePlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    swim_strokes: typing.Optional[int] = pydantic.Field(default=None)
    """
    Number of swim strokes to be performed during the workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/swim_stroke_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

SwimStrokePlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/swimming_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class SwimmingData(UncheckedBaseModel):
    num_laps: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of swimming laps performed during the day.
    """

    num_strokes: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of swimming strokes performed during the day.
    """

    pool_length_meters: typing.Optional[int] = pydantic.Field(default=None)
    """
    Pool length for associated with the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/swimming_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget
from .swimming_planned_workout_step_equipment_type import SwimmingPlannedWorkoutStepEquipmentType
from .swimming_planned_workout_step_stroke_type import SwimmingPlannedWorkoutStepStrokeType


class SwimmingPlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    equipment_type: typing.Optional[SwimmingPlannedWorkoutStepEquipmentType] = pydantic.Field(default=None)
    """
    Workout equipment to be used during the workout step
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    stroke_type: typing.Optional[SwimmingPlannedWorkoutStepStrokeType] = pydantic.Field(default=None)
    """
    Stroke type used for the workout step (e.g. breaststroke)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/swimming_planned_workout_step_equipment_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

SwimmingPlannedWorkoutStepEquipmentType = typing.Union[
    typing.Literal["NONE", "SWIM_FINS", "SWIM_KICKBOARD", "SWIM_PADDLES", "SWIM_PULL_BUOY", "SWIM_SNORKEL"], typing.Any
]

```
</file>
<file path="terra-client-python/src/terra/types/swimming_planned_workout_step_stroke_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

SwimmingPlannedWorkoutStepStrokeType = typing.Union[
    typing.Literal["OTHER", "FREESTYLE", "BACKSTROKE", "BREASTSTROKE", "BUTTERFLY", "REST"], typing.Any
]

```
</file>
<file path="terra-client-python/src/terra/types/tag_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .tag_entry import TagEntry


class TagData(UncheckedBaseModel):
    tags: typing.Optional[typing.List[TagEntry]] = pydantic.Field(default=None)
    """
    Array of user-entered tags for the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/tag_entry.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class TagEntry(UncheckedBaseModel):
    timestamp: str = pydantic.Field()
    """
    Time with which the tag is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    tag_name: str = pydantic.Field()
    """
    Tag name, representing a certain event associated with the user's day.
    """

    notes: str = pydantic.Field()
    """
    User-input notes associated with the given tag.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/temperature_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .temperature_sample import TemperatureSample


class TemperatureData(UncheckedBaseModel):
    ambient_temperature_samples: typing.Optional[typing.List[TemperatureSample]] = pydantic.Field(default=None)
    """
    List of ambient temperature measurements sampled throughout the day.
    """

    body_temperature_samples: typing.Optional[typing.List[TemperatureSample]] = pydantic.Field(default=None)
    """
    List of body temperature measurements sampled throughout the day.
    """

    skin_temperature_samples: typing.Optional[typing.List[TemperatureSample]] = pydantic.Field(default=None)
    """
    List of skin temperature measurements sampled throughout the day.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/temperature_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class TemperatureSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    temperature_celsius: typing.Optional[float] = pydantic.Field(default=None)
    """
    Temperature value in degrees Celsius.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/terra_user.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class TerraUser(UncheckedBaseModel):
    user_id: str = pydantic.Field()
    """
    Terra identifier for the wearable connection
    """

    provider: str = pydantic.Field()
    """
    Connection data source
    """

    last_webhook_update: typing.Optional[str] = pydantic.Field(default=None)
    """
    Last time at which a webhook update was sent for the connection
    """

    scopes: typing.Optional[str] = pydantic.Field(default=None)
    """
    (when available) Permissions granted by the user during authentication - to be used as debugging metadata
    """

    reference_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Connection identifier on the developer's end, used to tie connection back to a user on the developer's platform
    """

    active: typing.Optional[bool] = pydantic.Field(default=None)
    """
    whether the user is active or not (inactive users will not receive any data updates and are in considered 
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/time_planned_workout_step_duration.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .time_planned_workout_step_duration_duration_type import TimePlannedWorkoutStepDurationDurationType


class TimePlannedWorkoutStepDuration(UncheckedBaseModel):
    seconds: typing.Optional[int] = pydantic.Field(default=None)
    """
    Time duration to be elapsed for the workout step
    """

    duration_type: typing.Optional[TimePlannedWorkoutStepDurationDurationType] = pydantic.Field(default=None)
    """
    Type of condition that must be fulfilled to consider the workout step complete
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/time_planned_workout_step_duration_duration_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

TimePlannedWorkoutStepDurationDurationType = typing.Union[
    typing.Literal[
        "TIME",
        "DISTANCE_METERS",
        "HR_LESS_THAN",
        "HR_GREATER_THAN",
        "CALORIES",
        "OPEN",
        "POWER_LESS_THAN",
        "POWER_GREATER_THAN",
        "REPETITION_TIME",
        "REPS",
        "FIXED_REST",
        "TIME_AT_VALID_CDA",
        "STEPS",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/timestamp_localization.py">
```py
# This file was auto-generated by Fern from our API Definition.

TimestampLocalization = float

```
</file>
<file path="terra-client-python/src/terra/types/torque_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class TorqueSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time
    """

    timer_duration_seconds: typing.Optional[float] = pydantic.Field(default=None)
    """
    Time elapsed since the start of the workout, subtracting time during which the recording was paused
    """

    torque_newton_meters: typing.Optional[float] = pydantic.Field(default=None)
    """
    Torque generated at a given instant in time, in Newton-meters
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/trend_arrow.py">
```py
# This file was auto-generated by Fern from our API Definition.

TrendArrow = float

```
</file>
<file path="terra-client-python/src/terra/types/tss_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .tss_sample import TssSample


class TssData(UncheckedBaseModel):
    tss_samples: typing_extensions.Annotated[
        typing.Optional[typing.List[TssSample]], FieldMetadata(alias="TSS_samples")
    ] = pydantic.Field(default=None)
    """
    Array of TSS information sampled throughout the workout
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/tss_planned_workout_step_target.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .tss_planned_workout_step_target_target_type import TssPlannedWorkoutStepTargetTargetType


class TssPlannedWorkoutStepTarget(UncheckedBaseModel):
    target_type: typing.Optional[TssPlannedWorkoutStepTargetTargetType] = pydantic.Field(default=None)
    """
    Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
    """

    tss: typing.Optional[float] = pydantic.Field(default=None)
    """
    Planned Training Stress Score to be achieved for the workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/tss_planned_workout_step_target_target_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

TssPlannedWorkoutStepTargetTargetType = typing.Union[
    typing.Literal[
        "SPEED",
        "HEART_RATE",
        "OPEN",
        "CADENCE",
        "POWER",
        "GRADE",
        "RESISTANCE",
        "POWER_LAP",
        "SWIM_STROKE",
        "SPEED_LAP",
        "HEART_RATE_LAP",
        "PACE",
        "HEART_RATE_THRESHOLD_PERCENTAGE",
        "HEART_RATE_MAX_PERCENTAGE",
        "SPEED_PERCENTAGE",
        "POWER_PERCENTAGE",
        "REPETITION",
        "TSS",
        "IF",
    ],
    typing.Any,
]

```
</file>
<file path="terra-client-python/src/terra/types/tss_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class TssSample(UncheckedBaseModel):
    planned: typing.Optional[float] = None
    actual: typing.Optional[float] = None
    method: typing.Optional[str] = None
    intensity_factor_planned: typing.Optional[float] = None
    intensity_factor_actual: typing.Optional[float] = None
    normalized_power_watts: typing.Optional[float] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/unauthorized_error_body.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .unauthorized_error_body_status import UnauthorizedErrorBodyStatus


class UnauthorizedErrorBody(UncheckedBaseModel):
    message: typing.Optional[str] = pydantic.Field(default=None)
    """
    a detailed message describing the error
    """

    status: typing.Optional[UnauthorizedErrorBodyStatus] = pydantic.Field(default=None)
    """
    indicates that an error happened (value is error)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/unauthorized_error_body_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

UnauthorizedErrorBodyStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/types/upload_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

UploadType = float

```
</file>
<file path="terra-client-python/src/terra/types/user.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .terra_user import TerraUser

User = TerraUser

```
</file>
<file path="terra-client-python/src/terra/types/user_auth_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .auth_success_event import AuthSuccessEvent

UserAuthWebhook = AuthSuccessEvent

```
</file>
<file path="terra-client-python/src/terra/types/user_auth_webhook_error.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .auth_error_event import AuthErrorEvent

UserAuthWebhookError = AuthErrorEvent

```
</file>
<file path="terra-client-python/src/terra/types/user_auth_webhook_payload.py">
```py
# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from .terra_user import TerraUser


class UserAuthWebhookPayload_Success(UncheckedBaseModel):
    status: typing.Literal["success"] = "success"
    user: TerraUser
    reference_id: str
    widget_session_id: str
    type: typing.Literal["auth"] = "auth"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class UserAuthWebhookPayload_Error(UncheckedBaseModel):
    status: typing.Literal["error"] = "error"
    user: TerraUser
    provider: str
    message: str
    reason: str
    reference_id: str
    widget_session_id: str
    type: typing.Literal["auth"] = "auth"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


UserAuthWebhookPayload = typing_extensions.Annotated[
    typing.Union[UserAuthWebhookPayload_Success, UserAuthWebhookPayload_Error], UnionMetadata(discriminant="status")
]

```
</file>
<file path="terra-client-python/src/terra/types/user_deauth_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .deauth_event import DeauthEvent

UserDeauthWebhook = DeauthEvent

```
</file>
<file path="terra-client-python/src/terra/types/user_reauth_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .terra_user import TerraUser


class UserReauthEvent(UncheckedBaseModel):
    """
    User re-authentication event
    """

    type: typing.Literal["user_reauth"] = "user_reauth"
    new_user: TerraUser = pydantic.Field()
    """
    The new user record
    """

    old_user: TerraUser = pydantic.Field()
    """
    The old user record that will be deleted
    """

    status: typing.Literal["warning"] = pydantic.Field(default="warning")
    """
    Status of the re-authentication
    """

    message: str = pydantic.Field()
    """
    Information about the re-authentication
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/user_reauth_webhook.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .user_reauth_event import UserReauthEvent

UserReauthWebhook = UserReauthEvent

```
</file>
<file path="terra-client-python/src/terra/types/vo_2_max_sample.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel


class Vo2MaxSample(UncheckedBaseModel):
    timestamp: typing.Optional[str] = pydantic.Field(default=None)
    """
    Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time.
    """

    vo_2_max_ml_per_min_per_kg: typing_extensions.Annotated[
        typing.Optional[float], FieldMetadata(alias="vo2max_ml_per_min_per_kg")
    ] = pydantic.Field(default=None)
    """
    User's VO2Max - maximum amount of oxygen the user's body can utilize during exercise
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/webhook_event.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class WebhookEvent(UncheckedBaseModel):
    """
    Base webhook event structure that all events extend from
    """

    type: str = pydantic.Field()
    """
    The type of event
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/webhook_event_type.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from .access_revoked_event import AccessRevokedEvent
from .activity_event import ActivityEvent
from .athlete_event import AthleteEvent
from .auth_error_event import AuthErrorEvent
from .auth_success_event import AuthSuccessEvent
from .body_event import BodyEvent
from .connection_error_event import ConnectionErrorEvent
from .daily_event import DailyEvent
from .deauth_event import DeauthEvent
from .google_no_datasource_event import GoogleNoDatasourceEvent
from .healthcheck_event import HealthcheckEvent
from .large_request_processing_event import LargeRequestProcessingEvent
from .large_request_sending_event import LargeRequestSendingEvent
from .menstruation_event import MenstruationEvent
from .nutrition_event import NutritionEvent
from .permission_change_event import PermissionChangeEvent
from .processing_event import ProcessingEvent
from .rate_limit_hit_event import RateLimitHitEvent
from .s_3_payload_event import S3PayloadEvent
from .sleep_event import SleepEvent
from .user_reauth_event import UserReauthEvent

WebhookEventType = typing.Union[
    HealthcheckEvent,
    AuthSuccessEvent,
    AuthErrorEvent,
    DeauthEvent,
    UserReauthEvent,
    AccessRevokedEvent,
    ConnectionErrorEvent,
    GoogleNoDatasourceEvent,
    PermissionChangeEvent,
    ProcessingEvent,
    LargeRequestProcessingEvent,
    LargeRequestSendingEvent,
    RateLimitHitEvent,
    ActivityEvent,
    AthleteEvent,
    BodyEvent,
    DailyEvent,
    MenstruationEvent,
    NutritionEvent,
    SleepEvent,
    S3PayloadEvent,
]

```
</file>
<file path="terra-client-python/src/terra/types/webhook_events.py">
```py
# This file was auto-generated by Fern from our API Definition.

from .webhook_event_type import WebhookEventType

WebhookEvents = WebhookEventType

```
</file>
<file path="terra-client-python/src/terra/types/work_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel


class WorkData(UncheckedBaseModel):
    work_kilojoules: typing.Optional[float] = pydantic.Field(default=None)
    """
    Total work output of the user for the workout, in kilojoules.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/types/yoga_planned_workout_step.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .planned_workout_step_duration import PlannedWorkoutStepDuration
from .planned_workout_step_target import PlannedWorkoutStepTarget


class YogaPlannedWorkoutStep(UncheckedBaseModel):
    targets: typing.Optional[typing.List[PlannedWorkoutStepTarget]] = pydantic.Field(default=None)
    """
    List of targets for the workout
    """

    intensity: typing.Optional[int] = pydantic.Field(default=None)
    """
    Planned intensity for the workout step
    """

    order: typing.Optional[int] = pydantic.Field(default=None)
    """
    Position of the workout step in the overall workout
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of workout step
    """

    durations: typing.Optional[typing.List[PlannedWorkoutStepDuration]] = pydantic.Field(default=None)
    """
    List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of workout step
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/user/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/user/client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.terra_user import TerraUser
from .raw_client import AsyncRawUserClient, RawUserClient
from .types.user_get_all_user_i_ds_response import UserGetAllUserIDsResponse
from .types.user_get_info_for_user_id_response import UserGetInfoForUserIdResponse
from .types.user_modify_user_response import UserModifyUserResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class UserClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawUserClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawUserClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawUserClient
        """
        return self._raw_client

    def modifyuser(
        self,
        user_id: str,
        *,
        reference_id: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserModifyUserResponse:
        """
        Update a Terra user's reference_id or active status

        Parameters
        ----------
        user_id : str
            Terra user ID to update

        reference_id : typing.Optional[str]
            Identifier on your system to associate with this user

        active : typing.Optional[bool]
            Whether the user should remain active

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserModifyUserResponse
            Returned upon successful user modification

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.user.modifyuser(
            user_id="user_id",
        )
        """
        _response = self._raw_client.modifyuser(
            user_id, reference_id=reference_id, active=active, request_options=request_options
        )
        return _response.data

    def getinfoforuserid(
        self,
        *,
        user_id: typing.Optional[str] = None,
        reference_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserGetInfoForUserIdResponse:
        """
        Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID

        Parameters
        ----------
        user_id : typing.Optional[str]
            user ID to query for

        reference_id : typing.Optional[str]
            reference ID to query for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserGetInfoForUserIdResponse
            Returned when the provided resources are found

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.user.getinfoforuserid()
        """
        _response = self._raw_client.getinfoforuserid(
            user_id=user_id, reference_id=reference_id, request_options=request_options
        )
        return _response.data

    def getalluserids(
        self,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserGetAllUserIDsResponse:
        """
        Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).

        Parameters
        ----------
        page : typing.Optional[int]
            Zero-based page number. If omitted, results are not paginated.

        per_page : typing.Optional[int]
            Number of results per page (default is 500).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserGetAllUserIDsResponse
            Returned upon a successful request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.user.getalluserids()
        """
        _response = self._raw_client.getalluserids(page=page, per_page=per_page, request_options=request_options)
        return _response.data

    def getinfoformultipleuserids(
        self, *, request: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[TerraUser]:
        """
        Used to query for information for multiple Terra User IDs

        Parameters
        ----------
        request : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TerraUser]
            Returned upon successful request

        Examples
        --------
        from terra import Terra

        client = Terra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )
        client.user.getinfoformultipleuserids(
            request=["string"],
        )
        """
        _response = self._raw_client.getinfoformultipleuserids(request=request, request_options=request_options)
        return _response.data


class AsyncUserClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawUserClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawUserClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawUserClient
        """
        return self._raw_client

    async def modifyuser(
        self,
        user_id: str,
        *,
        reference_id: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserModifyUserResponse:
        """
        Update a Terra user's reference_id or active status

        Parameters
        ----------
        user_id : str
            Terra user ID to update

        reference_id : typing.Optional[str]
            Identifier on your system to associate with this user

        active : typing.Optional[bool]
            Whether the user should remain active

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserModifyUserResponse
            Returned upon successful user modification

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user.modifyuser(
                user_id="user_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.modifyuser(
            user_id, reference_id=reference_id, active=active, request_options=request_options
        )
        return _response.data

    async def getinfoforuserid(
        self,
        *,
        user_id: typing.Optional[str] = None,
        reference_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserGetInfoForUserIdResponse:
        """
        Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID

        Parameters
        ----------
        user_id : typing.Optional[str]
            user ID to query for

        reference_id : typing.Optional[str]
            reference ID to query for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserGetInfoForUserIdResponse
            Returned when the provided resources are found

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user.getinfoforuserid()


        asyncio.run(main())
        """
        _response = await self._raw_client.getinfoforuserid(
            user_id=user_id, reference_id=reference_id, request_options=request_options
        )
        return _response.data

    async def getalluserids(
        self,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserGetAllUserIDsResponse:
        """
        Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).

        Parameters
        ----------
        page : typing.Optional[int]
            Zero-based page number. If omitted, results are not paginated.

        per_page : typing.Optional[int]
            Number of results per page (default is 500).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserGetAllUserIDsResponse
            Returned upon a successful request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user.getalluserids()


        asyncio.run(main())
        """
        _response = await self._raw_client.getalluserids(page=page, per_page=per_page, request_options=request_options)
        return _response.data

    async def getinfoformultipleuserids(
        self, *, request: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[TerraUser]:
        """
        Used to query for information for multiple Terra User IDs

        Parameters
        ----------
        request : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TerraUser]
            Returned upon successful request

        Examples
        --------
        import asyncio

        from terra import AsyncTerra

        client = AsyncTerra(
            dev_id="YOUR_DEV_ID",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user.getinfoformultipleuserids(
                request=["string"],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.getinfoformultipleuserids(request=request, request_options=request_options)
        return _response.data

```
</file>
<file path="terra-client-python/src/terra/user/raw_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..types.terra_user import TerraUser
from .types.user_get_all_user_i_ds_response import UserGetAllUserIDsResponse
from .types.user_get_info_for_user_id_response import UserGetInfoForUserIdResponse
from .types.user_modify_user_response import UserModifyUserResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawUserClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def modifyuser(
        self,
        user_id: str,
        *,
        reference_id: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UserModifyUserResponse]:
        """
        Update a Terra user's reference_id or active status

        Parameters
        ----------
        user_id : str
            Terra user ID to update

        reference_id : typing.Optional[str]
            Identifier on your system to associate with this user

        active : typing.Optional[bool]
            Whether the user should remain active

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UserModifyUserResponse]
            Returned upon successful user modification
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="PATCH",
            json={
                "reference_id": reference_id,
                "active": active,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UserModifyUserResponse,
                    construct_type(
                        type_=UserModifyUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def getinfoforuserid(
        self,
        *,
        user_id: typing.Optional[str] = None,
        reference_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UserGetInfoForUserIdResponse]:
        """
        Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID

        Parameters
        ----------
        user_id : typing.Optional[str]
            user ID to query for

        reference_id : typing.Optional[str]
            reference ID to query for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UserGetInfoForUserIdResponse]
            Returned when the provided resources are found
        """
        _response = self._client_wrapper.httpx_client.request(
            "userInfo",
            method="GET",
            params={
                "user_id": user_id,
                "reference_id": reference_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UserGetInfoForUserIdResponse,
                    construct_type(
                        type_=UserGetInfoForUserIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def getalluserids(
        self,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UserGetAllUserIDsResponse]:
        """
        Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).

        Parameters
        ----------
        page : typing.Optional[int]
            Zero-based page number. If omitted, results are not paginated.

        per_page : typing.Optional[int]
            Number of results per page (default is 500).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UserGetAllUserIDsResponse]
            Returned upon a successful request
        """
        _response = self._client_wrapper.httpx_client.request(
            "subscriptions",
            method="GET",
            params={
                "page": page,
                "per_page": per_page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UserGetAllUserIDsResponse,
                    construct_type(
                        type_=UserGetAllUserIDsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def getinfoformultipleuserids(
        self, *, request: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[TerraUser]]:
        """
        Used to query for information for multiple Terra User IDs

        Parameters
        ----------
        request : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TerraUser]]
            Returned upon successful request
        """
        _response = self._client_wrapper.httpx_client.request(
            "bulkUserInfo",
            method="POST",
            json=request,
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TerraUser],
                    construct_type(
                        type_=typing.List[TerraUser],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawUserClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def modifyuser(
        self,
        user_id: str,
        *,
        reference_id: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UserModifyUserResponse]:
        """
        Update a Terra user's reference_id or active status

        Parameters
        ----------
        user_id : str
            Terra user ID to update

        reference_id : typing.Optional[str]
            Identifier on your system to associate with this user

        active : typing.Optional[bool]
            Whether the user should remain active

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UserModifyUserResponse]
            Returned upon successful user modification
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="PATCH",
            json={
                "reference_id": reference_id,
                "active": active,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UserModifyUserResponse,
                    construct_type(
                        type_=UserModifyUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def getinfoforuserid(
        self,
        *,
        user_id: typing.Optional[str] = None,
        reference_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UserGetInfoForUserIdResponse]:
        """
        Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID

        Parameters
        ----------
        user_id : typing.Optional[str]
            user ID to query for

        reference_id : typing.Optional[str]
            reference ID to query for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UserGetInfoForUserIdResponse]
            Returned when the provided resources are found
        """
        _response = await self._client_wrapper.httpx_client.request(
            "userInfo",
            method="GET",
            params={
                "user_id": user_id,
                "reference_id": reference_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UserGetInfoForUserIdResponse,
                    construct_type(
                        type_=UserGetInfoForUserIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def getalluserids(
        self,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UserGetAllUserIDsResponse]:
        """
        Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).

        Parameters
        ----------
        page : typing.Optional[int]
            Zero-based page number. If omitted, results are not paginated.

        per_page : typing.Optional[int]
            Number of results per page (default is 500).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UserGetAllUserIDsResponse]
            Returned upon a successful request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "subscriptions",
            method="GET",
            params={
                "page": page,
                "per_page": per_page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UserGetAllUserIDsResponse,
                    construct_type(
                        type_=UserGetAllUserIDsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def getinfoformultipleuserids(
        self, *, request: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[TerraUser]]:
        """
        Used to query for information for multiple Terra User IDs

        Parameters
        ----------
        request : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TerraUser]]
            Returned upon successful request
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bulkUserInfo",
            method="POST",
            json=request,
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TerraUser],
                    construct_type(
                        type_=typing.List[TerraUser],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

```
</file>
<file path="terra-client-python/src/terra/user/types/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# isort: skip_file


```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_all_user_i_ds_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from .user_get_all_user_i_ds_response_data import UserGetAllUserIDsResponseData
from .user_get_all_user_i_ds_response_users import UserGetAllUserIDsResponseUsers

UserGetAllUserIDsResponse = typing.Union[UserGetAllUserIDsResponseUsers, UserGetAllUserIDsResponseData]

```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_all_user_i_ds_response_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from .user_get_all_user_i_ds_response_data_data import UserGetAllUserIDsResponseDataData


class UserGetAllUserIDsResponseData(UncheckedBaseModel):
    data: typing.Optional[UserGetAllUserIDsResponseDataData] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_all_user_i_ds_response_data_data.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser


class UserGetAllUserIDsResponseDataData(UncheckedBaseModel):
    next: typing.Optional[int] = pydantic.Field(default=None)
    """
    The next page number, or null if there is no next page
    """

    max_page: typing.Optional[int] = pydantic.Field(default=None)
    """
    The maximum page index
    """

    results: typing.Optional[typing.List[TerraUser]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_all_user_i_ds_response_users.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser


class UserGetAllUserIDsResponseUsers(UncheckedBaseModel):
    users: typing.Optional[typing.List[TerraUser]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_info_for_user_id_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

from ...types.terra_user import TerraUser
from .user_get_info_for_user_id_response_is_authenticated import UserGetInfoForUserIdResponseIsAuthenticated

UserGetInfoForUserIdResponse = typing.Union[UserGetInfoForUserIdResponseIsAuthenticated, typing.List[TerraUser]]

```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_info_for_user_id_response_is_authenticated.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser
from .user_get_info_for_user_id_response_is_authenticated_status import (
    UserGetInfoForUserIdResponseIsAuthenticatedStatus,
)


class UserGetInfoForUserIdResponseIsAuthenticated(UncheckedBaseModel):
    """
    User information for one connection (single User object)
    """

    user: typing.Optional[TerraUser] = None
    status: typing.Optional[UserGetInfoForUserIdResponseIsAuthenticatedStatus] = None
    is_authenticated: typing.Optional[bool] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/user/types/user_get_info_for_user_id_response_is_authenticated_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

UserGetInfoForUserIdResponseIsAuthenticatedStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/user/types/user_modify_user_response.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.terra_user import TerraUser
from .user_modify_user_response_status import UserModifyUserResponseStatus


class UserModifyUserResponse(UncheckedBaseModel):
    user: typing.Optional[TerraUser] = None
    status: typing.Optional[UserModifyUserResponseStatus] = pydantic.Field(default=None)
    """
    Indicates that the request was successful
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

```
</file>
<file path="terra-client-python/src/terra/user/types/user_modify_user_response_status.py">
```py
# This file was auto-generated by Fern from our API Definition.

import typing

UserModifyUserResponseStatus = typing.Union[typing.Literal["success", "error"], typing.Any]

```
</file>
<file path="terra-client-python/src/terra/version.py">
```py
from importlib import metadata

__version__ = metadata.version("terra-python")

```
</file>
<file path="terra-client-python/tests/custom/test_client.py">
```py
import pytest


# Get started with writing tests with pytest at https://docs.pytest.org
@pytest.mark.skip(reason="Unimplemented")
def test_client() -> None:
    assert True

```
</file>
<file path="terra-client-python/tests/utils/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.


```
</file>
<file path="terra-client-python/tests/utils/assets/models/__init__.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

from .circle import CircleParams
from .object_with_defaults import ObjectWithDefaultsParams
from .object_with_optional_field import ObjectWithOptionalFieldParams
from .shape import Shape_CircleParams, Shape_SquareParams, ShapeParams
from .square import SquareParams
from .undiscriminated_shape import UndiscriminatedShapeParams

__all__ = [
    "CircleParams",
    "ObjectWithDefaultsParams",
    "ObjectWithOptionalFieldParams",
    "ShapeParams",
    "Shape_CircleParams",
    "Shape_SquareParams",
    "SquareParams",
    "UndiscriminatedShapeParams",
]

```
</file>
<file path="terra-client-python/tests/utils/assets/models/circle.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

import typing_extensions

from terra.core.serialization import FieldMetadata


class CircleParams(typing_extensions.TypedDict):
    radius_measurement: typing_extensions.Annotated[float, FieldMetadata(alias="radiusMeasurement")]

```
</file>
<file path="terra-client-python/tests/utils/assets/models/color.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

import typing

Color = typing.Union[typing.Literal["red", "blue"], typing.Any]

```
</file>
<file path="terra-client-python/tests/utils/assets/models/object_with_defaults.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

import typing_extensions


class ObjectWithDefaultsParams(typing_extensions.TypedDict):
    """
    Defines properties with default values and validation rules.
    """

    decimal: typing_extensions.NotRequired[float]
    string: typing_extensions.NotRequired[str]
    required_string: str

```
</file>
<file path="terra-client-python/tests/utils/assets/models/object_with_optional_field.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import uuid

import typing_extensions
from .color import Color
from .shape import ShapeParams
from .undiscriminated_shape import UndiscriminatedShapeParams

from terra.core.serialization import FieldMetadata


class ObjectWithOptionalFieldParams(typing_extensions.TypedDict):
    literal: typing.Literal["lit_one"]
    string: typing_extensions.NotRequired[str]
    integer: typing_extensions.NotRequired[int]
    long_: typing_extensions.NotRequired[typing_extensions.Annotated[int, FieldMetadata(alias="long")]]
    double: typing_extensions.NotRequired[float]
    bool_: typing_extensions.NotRequired[typing_extensions.Annotated[bool, FieldMetadata(alias="bool")]]
    datetime: typing_extensions.NotRequired[dt.datetime]
    date: typing_extensions.NotRequired[dt.date]
    uuid_: typing_extensions.NotRequired[typing_extensions.Annotated[uuid.UUID, FieldMetadata(alias="uuid")]]
    base_64: typing_extensions.NotRequired[typing_extensions.Annotated[str, FieldMetadata(alias="base64")]]
    list_: typing_extensions.NotRequired[typing_extensions.Annotated[typing.Sequence[str], FieldMetadata(alias="list")]]
    set_: typing_extensions.NotRequired[typing_extensions.Annotated[typing.Set[str], FieldMetadata(alias="set")]]
    map_: typing_extensions.NotRequired[typing_extensions.Annotated[typing.Dict[int, str], FieldMetadata(alias="map")]]
    enum: typing_extensions.NotRequired[Color]
    union: typing_extensions.NotRequired[ShapeParams]
    second_union: typing_extensions.NotRequired[ShapeParams]
    undiscriminated_union: typing_extensions.NotRequired[UndiscriminatedShapeParams]
    any: typing.Optional[typing.Any]

```
</file>
<file path="terra-client-python/tests/utils/assets/models/shape.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import typing_extensions

from terra.core.serialization import FieldMetadata


class Base(typing_extensions.TypedDict):
    id: str


class Shape_CircleParams(Base):
    shape_type: typing_extensions.Annotated[typing.Literal["circle"], FieldMetadata(alias="shapeType")]
    radius_measurement: typing_extensions.Annotated[float, FieldMetadata(alias="radiusMeasurement")]


class Shape_SquareParams(Base):
    shape_type: typing_extensions.Annotated[typing.Literal["square"], FieldMetadata(alias="shapeType")]
    length_measurement: typing_extensions.Annotated[float, FieldMetadata(alias="lengthMeasurement")]


ShapeParams = typing.Union[Shape_CircleParams, Shape_SquareParams]

```
</file>
<file path="terra-client-python/tests/utils/assets/models/square.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

import typing_extensions

from terra.core.serialization import FieldMetadata


class SquareParams(typing_extensions.TypedDict):
    length_measurement: typing_extensions.Annotated[float, FieldMetadata(alias="lengthMeasurement")]

```
</file>
<file path="terra-client-python/tests/utils/assets/models/undiscriminated_shape.py">
```py
# This file was auto-generated by Fern from our API Definition.

# This file was auto-generated by Fern from our API Definition.

import typing

from .circle import CircleParams
from .square import SquareParams

UndiscriminatedShapeParams = typing.Union[CircleParams, SquareParams]

```
</file>
<file path="terra-client-python/tests/utils/test_http_client.py">
```py
# This file was auto-generated by Fern from our API Definition.

from terra.core.http_client import get_request_body
from terra.core.request_options import RequestOptions


def get_request_options() -> RequestOptions:
    return {"additional_body_parameters": {"see you": "later"}}


def test_get_json_request_body() -> None:
    json_body, data_body = get_request_body(json={"hello": "world"}, data=None, request_options=None, omit=None)
    assert json_body == {"hello": "world"}
    assert data_body is None

    json_body_extras, data_body_extras = get_request_body(
        json={"goodbye": "world"}, data=None, request_options=get_request_options(), omit=None
    )

    assert json_body_extras == {"goodbye": "world", "see you": "later"}
    assert data_body_extras is None


def test_get_files_request_body() -> None:
    json_body, data_body = get_request_body(json=None, data={"hello": "world"}, request_options=None, omit=None)
    assert data_body == {"hello": "world"}
    assert json_body is None

    json_body_extras, data_body_extras = get_request_body(
        json=None, data={"goodbye": "world"}, request_options=get_request_options(), omit=None
    )

    assert data_body_extras == {"goodbye": "world", "see you": "later"}
    assert json_body_extras is None


def test_get_none_request_body() -> None:
    json_body, data_body = get_request_body(json=None, data=None, request_options=None, omit=None)
    assert data_body is None
    assert json_body is None

    json_body_extras, data_body_extras = get_request_body(
        json=None, data=None, request_options=get_request_options(), omit=None
    )

    assert json_body_extras == {"see you": "later"}
    assert data_body_extras is None


def test_get_empty_json_request_body() -> None:
    unrelated_request_options: RequestOptions = {"max_retries": 3}
    json_body, data_body = get_request_body(json=None, data=None, request_options=unrelated_request_options, omit=None)
    assert json_body is None
    assert data_body is None

    json_body_extras, data_body_extras = get_request_body(
        json={}, data=None, request_options=unrelated_request_options, omit=None
    )

    assert json_body_extras is None
    assert data_body_extras is None

```
</file>
<file path="terra-client-python/tests/utils/test_query_encoding.py">
```py
# This file was auto-generated by Fern from our API Definition.


from terra.core.query_encoder import encode_query


def test_query_encoding_deep_objects() -> None:
    assert encode_query({"hello world": "hello world"}) == [("hello world", "hello world")]
    assert encode_query({"hello_world": {"hello": "world"}}) == [("hello_world[hello]", "world")]
    assert encode_query({"hello_world": {"hello": {"world": "today"}, "test": "this"}, "hi": "there"}) == [
        ("hello_world[hello][world]", "today"),
        ("hello_world[test]", "this"),
        ("hi", "there"),
    ]


def test_query_encoding_deep_object_arrays() -> None:
    assert encode_query({"objects": [{"key": "hello", "value": "world"}, {"key": "foo", "value": "bar"}]}) == [
        ("objects[key]", "hello"),
        ("objects[value]", "world"),
        ("objects[key]", "foo"),
        ("objects[value]", "bar"),
    ]
    assert encode_query(
        {"users": [{"name": "string", "tags": ["string"]}, {"name": "string2", "tags": ["string2", "string3"]}]}
    ) == [
        ("users[name]", "string"),
        ("users[tags]", "string"),
        ("users[name]", "string2"),
        ("users[tags]", "string2"),
        ("users[tags]", "string3"),
    ]


def test_encode_query_with_none() -> None:
    encoded = encode_query(None)
    assert encoded is None

```
</file>
<file path="terra-client-python/tests/utils/test_serialization.py">
```py
# This file was auto-generated by Fern from our API Definition.

from typing import Any, List

from .assets.models import ObjectWithOptionalFieldParams, ShapeParams

from terra.core.serialization import convert_and_respect_annotation_metadata

UNION_TEST: ShapeParams = {"radius_measurement": 1.0, "shape_type": "circle", "id": "1"}
UNION_TEST_CONVERTED = {"shapeType": "circle", "radiusMeasurement": 1.0, "id": "1"}


def test_convert_and_respect_annotation_metadata() -> None:
    data: ObjectWithOptionalFieldParams = {
        "string": "string",
        "long_": 12345,
        "bool_": True,
        "literal": "lit_one",
        "any": "any",
    }
    converted = convert_and_respect_annotation_metadata(
        object_=data, annotation=ObjectWithOptionalFieldParams, direction="write"
    )
    assert converted == {"string": "string", "long": 12345, "bool": True, "literal": "lit_one", "any": "any"}


def test_convert_and_respect_annotation_metadata_in_list() -> None:
    data: List[ObjectWithOptionalFieldParams] = [
        {"string": "string", "long_": 12345, "bool_": True, "literal": "lit_one", "any": "any"},
        {"string": "another string", "long_": 67890, "list_": [], "literal": "lit_one", "any": "any"},
    ]
    converted = convert_and_respect_annotation_metadata(
        object_=data, annotation=List[ObjectWithOptionalFieldParams], direction="write"
    )

    assert converted == [
        {"string": "string", "long": 12345, "bool": True, "literal": "lit_one", "any": "any"},
        {"string": "another string", "long": 67890, "list": [], "literal": "lit_one", "any": "any"},
    ]


def test_convert_and_respect_annotation_metadata_in_nested_object() -> None:
    data: ObjectWithOptionalFieldParams = {
        "string": "string",
        "long_": 12345,
        "union": UNION_TEST,
        "literal": "lit_one",
        "any": "any",
    }
    converted = convert_and_respect_annotation_metadata(
        object_=data, annotation=ObjectWithOptionalFieldParams, direction="write"
    )

    assert converted == {
        "string": "string",
        "long": 12345,
        "union": UNION_TEST_CONVERTED,
        "literal": "lit_one",
        "any": "any",
    }


def test_convert_and_respect_annotation_metadata_in_union() -> None:
    converted = convert_and_respect_annotation_metadata(object_=UNION_TEST, annotation=ShapeParams, direction="write")

    assert converted == UNION_TEST_CONVERTED


def test_convert_and_respect_annotation_metadata_with_empty_object() -> None:
    data: Any = {}
    converted = convert_and_respect_annotation_metadata(object_=data, annotation=ShapeParams, direction="write")
    assert converted == data

```
</file>
</files>