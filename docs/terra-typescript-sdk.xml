<directory>terra-client-js</directory>

<source-tree>
terra-client-js
â”œâ”€â”€ README.md
â”œâ”€â”€ jest.config.mjs
â”œâ”€â”€ package.json
â”œâ”€â”€ reference.md
â”œâ”€â”€ scripts
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ Client.ts
â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”œâ”€â”€ errors
â”‚   â”‚   â”‚   â”œâ”€â”€ BadRequestError.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ NotFoundError.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ UnauthorizedError.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ resources
â”‚   â”‚   â”‚   â”œâ”€â”€ activity
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ActivityFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ActivityWriteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ActivityFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ActivityFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ActivityWriteResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ athlete
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AthleteFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AthleteFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authentication
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AuthenticationAuthenticateUserRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AuthenticationDeauthenticateUserRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ WidgetSessionParams.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AuthenticationAuthenticateUserResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AuthenticationDeauthenticateUserResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AuthenticationGenerateAuthTokenResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ AuthenticationGenerateWidgetSessionResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ body
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyDeleteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyWriteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyDeleteResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BodyWriteResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ daily
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ DailyFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ DailyFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ DailyFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ integrations
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ IntegrationsDetailedFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ IntegrationsFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ menstruation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ MenstruationFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ MenstruationFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ MenstruationFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ nutrition
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionDeleteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionWriteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionDeleteResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ NutritionWriteResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ plannedworkout
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutDeleteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutWriteRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutDeleteResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutWriteResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ sleep
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ SleepFetchRequest.ts
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ SleepFetchRequestStartDate.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ SleepFetchResponse.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â””â”€â”€ user
â”‚   â”‚   â”‚       â”œâ”€â”€ client
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Client.ts
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ requests
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ UserGetAllUserIDsRequest.ts
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ UserGetInfoForUserIdRequest.ts
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ UserModifyUserRequest.ts
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ index.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚       â””â”€â”€ types
â”‚   â”‚   â”‚           â”œâ”€â”€ UserGetAllUserIDsResponse.ts
â”‚   â”‚   â”‚           â”œâ”€â”€ UserGetInfoForUserIdResponse.ts
â”‚   â”‚   â”‚           â”œâ”€â”€ UserModifyUserResponse.ts
â”‚   â”‚   â”‚           â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚       â”œâ”€â”€ AFibClassificationSample.ts
â”‚   â”‚       â”œâ”€â”€ AccessRevokedEvent.ts
â”‚   â”‚       â”œâ”€â”€ AccessRevokedWebhook.ts
â”‚   â”‚       â”œâ”€â”€ ActiveDurationsData.ts
â”‚   â”‚       â”œâ”€â”€ Activity.ts
â”‚   â”‚       â”œâ”€â”€ ActivityEvent.ts
â”‚   â”‚       â”œâ”€â”€ ActivityLevel.ts
â”‚   â”‚       â”œâ”€â”€ ActivityLevelSample.ts
â”‚   â”‚       â”œâ”€â”€ ActivityMetadata.ts
â”‚   â”‚       â”œâ”€â”€ ActivityWebhook.ts
â”‚   â”‚       â”œâ”€â”€ AsleepDurations.ts
â”‚   â”‚       â”œâ”€â”€ Athlete.ts
â”‚   â”‚       â”œâ”€â”€ AthleteCollection.ts
â”‚   â”‚       â”œâ”€â”€ AthleteEvent.ts
â”‚   â”‚       â”œâ”€â”€ AthleteWebhook.ts
â”‚   â”‚       â”œâ”€â”€ AuthErrorEvent.ts
â”‚   â”‚       â”œâ”€â”€ AuthEvent.ts
â”‚   â”‚       â”œâ”€â”€ AuthSuccessEvent.ts
â”‚   â”‚       â”œâ”€â”€ AuthenticationFailedWebhook.ts
â”‚   â”‚       â”œâ”€â”€ AwakeDurations.ts
â”‚   â”‚       â”œâ”€â”€ BadRequestErrorBody.ts
â”‚   â”‚       â”œâ”€â”€ BloodPressureData.ts
â”‚   â”‚       â”œâ”€â”€ BloodPressureSample.ts
â”‚   â”‚       â”œâ”€â”€ Body.ts
â”‚   â”‚       â”œâ”€â”€ BodyBatterySample.ts
â”‚   â”‚       â”œâ”€â”€ BodyEvent.ts
â”‚   â”‚       â”œâ”€â”€ BodyMetadata.ts
â”‚   â”‚       â”œâ”€â”€ BodyWebhook.ts
â”‚   â”‚       â”œâ”€â”€ Breath.ts
â”‚   â”‚       â”œâ”€â”€ BreathSample.ts
â”‚   â”‚       â”œâ”€â”€ BreathsData.ts
â”‚   â”‚       â”œâ”€â”€ CadencePlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ CadenceSample.ts
â”‚   â”‚       â”œâ”€â”€ CalorieSample.ts
â”‚   â”‚       â”œâ”€â”€ CaloriesData.ts
â”‚   â”‚       â”œâ”€â”€ CaloriesPlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ CardioPlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ ConnectionErrorEvent.ts
â”‚   â”‚       â”œâ”€â”€ ConnectionErrorWebhook.ts
â”‚   â”‚       â”œâ”€â”€ CyclingPlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ Daily.ts
â”‚   â”‚       â”œâ”€â”€ DailyDataEnrichment.ts
â”‚   â”‚       â”œâ”€â”€ DailyDistanceData.ts
â”‚   â”‚       â”œâ”€â”€ DailyEvent.ts
â”‚   â”‚       â”œâ”€â”€ DailyMetadata.ts
â”‚   â”‚       â”œâ”€â”€ DailyPatternSample.ts
â”‚   â”‚       â”œâ”€â”€ DailyWebhook.ts
â”‚   â”‚       â”œâ”€â”€ DataContributor.ts
â”‚   â”‚       â”œâ”€â”€ DataEnrichment.ts
â”‚   â”‚       â”œâ”€â”€ DataProcessingWebhook.ts
â”‚   â”‚       â”œâ”€â”€ DataSentToWebhook.ts
â”‚   â”‚       â”œâ”€â”€ DeauthEvent.ts
â”‚   â”‚       â”œâ”€â”€ DeviceData.ts
â”‚   â”‚       â”œâ”€â”€ DeviceDataType.ts
â”‚   â”‚       â”œâ”€â”€ DistanceData.ts
â”‚   â”‚       â”œâ”€â”€ DistanceDataDetailed.ts
â”‚   â”‚       â”œâ”€â”€ DistanceDataSummary.ts
â”‚   â”‚       â”œâ”€â”€ DistancePlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ DistanceSample.ts
â”‚   â”‚       â”œâ”€â”€ DrinkSample.ts
â”‚   â”‚       â”œâ”€â”€ EcgReading.ts
â”‚   â”‚       â”œâ”€â”€ ElevationData.ts
â”‚   â”‚       â”œâ”€â”€ ElevationSample.ts
â”‚   â”‚       â”œâ”€â”€ EnergyData.ts
â”‚   â”‚       â”œâ”€â”€ FixedRestPlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ FloorsClimbedSample.ts
â”‚   â”‚       â”œâ”€â”€ GlucoseData.ts
â”‚   â”‚       â”œâ”€â”€ GlucoseDataSample.ts
â”‚   â”‚       â”œâ”€â”€ GoogleNoDataSourceWebhook.ts
â”‚   â”‚       â”œâ”€â”€ GoogleNoDatasourceEvent.ts
â”‚   â”‚       â”œâ”€â”€ Had.ts
â”‚   â”‚       â”œâ”€â”€ HealthCheckWebhook.ts
â”‚   â”‚       â”œâ”€â”€ HealthcheckEvent.ts
â”‚   â”‚       â”œâ”€â”€ HeartData.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateContext.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateData.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateDataDetailed.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateDataSample.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateDataSummary.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateVariabilityDataSampleRmssd.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateVariabilityDataSampleSdnn.ts
â”‚   â”‚       â”œâ”€â”€ HeartRateZoneData.ts
â”‚   â”‚       â”œâ”€â”€ High.ts
â”‚   â”‚       â”œâ”€â”€ HrAbovePlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ HrBelowPlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ HrPlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ Hurling.ts
â”‚   â”‚       â”œâ”€â”€ HydrationData.ts
â”‚   â”‚       â”œâ”€â”€ HydrationMeasurementSample.ts
â”‚   â”‚       â”œâ”€â”€ IfPlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ Inconclusive.ts
â”‚   â”‚       â”œâ”€â”€ Indeterminate.ts
â”‚   â”‚       â”œâ”€â”€ IntegrationProvider.ts
â”‚   â”‚       â”œâ”€â”€ IntegrationsResponse.ts
â”‚   â”‚       â”œâ”€â”€ KetoneData.ts
â”‚   â”‚       â”œâ”€â”€ KetoneSample.ts
â”‚   â”‚       â”œâ”€â”€ LapData.ts
â”‚   â”‚       â”œâ”€â”€ LapSample.ts
â”‚   â”‚       â”œâ”€â”€ LargeRequestProcessingEvent.ts
â”‚   â”‚       â”œâ”€â”€ LargeRequestProcessingResponse.ts
â”‚   â”‚       â”œâ”€â”€ LargeRequestSendingEvent.ts
â”‚   â”‚       â”œâ”€â”€ LargeRequestSendingWebhook.ts
â”‚   â”‚       â”œâ”€â”€ Low.ts
â”‚   â”‚       â”œâ”€â”€ Meal.ts
â”‚   â”‚       â”œâ”€â”€ MeasurementDataSample.ts
â”‚   â”‚       â”œâ”€â”€ MeasurementsData.ts
â”‚   â”‚       â”œâ”€â”€ MenstrualPhase.ts
â”‚   â”‚       â”œâ”€â”€ Menstruation.ts
â”‚   â”‚       â”œâ”€â”€ MenstruationData.ts
â”‚   â”‚       â”œâ”€â”€ MenstruationEvent.ts
â”‚   â”‚       â”œâ”€â”€ MenstruationFlowSample.ts
â”‚   â”‚       â”œâ”€â”€ MenstruationMetadata.ts
â”‚   â”‚       â”œâ”€â”€ MenstruationWebhook.ts
â”‚   â”‚       â”œâ”€â”€ MetData.ts
â”‚   â”‚       â”œâ”€â”€ MetSample.ts
â”‚   â”‚       â”œâ”€â”€ MovementData.ts
â”‚   â”‚       â”œâ”€â”€ Muscle.ts
â”‚   â”‚       â”œâ”€â”€ NoDataReturned.ts
â”‚   â”‚       â”œâ”€â”€ NotFoundErrorBody.ts
â”‚   â”‚       â”œâ”€â”€ Nutrition.ts
â”‚   â”‚       â”œâ”€â”€ NutritionEvent.ts
â”‚   â”‚       â”œâ”€â”€ NutritionMacros.ts
â”‚   â”‚       â”œâ”€â”€ NutritionMetadata.ts
â”‚   â”‚       â”œâ”€â”€ NutritionMicros.ts
â”‚   â”‚       â”œâ”€â”€ NutritionQuantity.ts
â”‚   â”‚       â”œâ”€â”€ NutritionSummary.ts
â”‚   â”‚       â”œâ”€â”€ NutritionUnits.ts
â”‚   â”‚       â”œâ”€â”€ NutritionWebhook.ts
â”‚   â”‚       â”œâ”€â”€ Other.ts
â”‚   â”‚       â”œâ”€â”€ OtherDeviceData.ts
â”‚   â”‚       â”œâ”€â”€ OtherSleepDurations.ts
â”‚   â”‚       â”œâ”€â”€ OxygenData.ts
â”‚   â”‚       â”œâ”€â”€ OxygenSaturationData.ts
â”‚   â”‚       â”œâ”€â”€ OxygenSaturationSample.ts
â”‚   â”‚       â”œâ”€â”€ PacePlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ PermissionChangeEvent.ts
â”‚   â”‚       â”œâ”€â”€ PermissionChangeWebhook.ts
â”‚   â”‚       â”œâ”€â”€ PilatesPlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkout.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutMetadata.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutRepeatStep.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutStepDurations.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutStepTargets.ts
â”‚   â”‚       â”œâ”€â”€ PlannedWorkoutSteps.ts
â”‚   â”‚       â”œâ”€â”€ PolylineMapData.ts
â”‚   â”‚       â”œâ”€â”€ PositionData.ts
â”‚   â”‚       â”œâ”€â”€ PositionSample.ts
â”‚   â”‚       â”œâ”€â”€ PowerAbovePlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ PowerBelowPlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ PowerData.ts
â”‚   â”‚       â”œâ”€â”€ PowerPlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ PowerSample.ts
â”‚   â”‚       â”œâ”€â”€ ProcessingEvent.ts
â”‚   â”‚       â”œâ”€â”€ PulseVelocitySample.ts
â”‚   â”‚       â”œâ”€â”€ RateLimitHitEvent.ts
â”‚   â”‚       â”œâ”€â”€ RateLimitHitWebhook.ts
â”‚   â”‚       â”œâ”€â”€ RateLimitRequestProcessing.ts
â”‚   â”‚       â”œâ”€â”€ RawEcgSample.ts
â”‚   â”‚       â”œâ”€â”€ ReadinessData.ts
â”‚   â”‚       â”œâ”€â”€ RecoveryLevel.ts
â”‚   â”‚       â”œâ”€â”€ RepetitionPlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ RepsPlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ RequestProcessing.ts
â”‚   â”‚       â”œâ”€â”€ RespirationData.ts
â”‚   â”‚       â”œâ”€â”€ RrIntervalSample.ts
â”‚   â”‚       â”œâ”€â”€ RunningPlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ S3PayloadEvent.ts
â”‚   â”‚       â”œâ”€â”€ S3UploadWebhook.ts
â”‚   â”‚       â”œâ”€â”€ ScoresData.ts
â”‚   â”‚       â”œâ”€â”€ Sleep.ts
â”‚   â”‚       â”œâ”€â”€ SleepDataEnrichment.ts
â”‚   â”‚       â”œâ”€â”€ SleepDurationsData.ts
â”‚   â”‚       â”œâ”€â”€ SleepEvent.ts
â”‚   â”‚       â”œâ”€â”€ SleepHypnogramSample.ts
â”‚   â”‚       â”œâ”€â”€ SleepLevel.ts
â”‚   â”‚       â”œâ”€â”€ SleepMetadata.ts
â”‚   â”‚       â”œâ”€â”€ SleepTemperatureData.ts
â”‚   â”‚       â”œâ”€â”€ SleepWebhook.ts
â”‚   â”‚       â”œâ”€â”€ Snack.ts
â”‚   â”‚       â”œâ”€â”€ SnoringData.ts
â”‚   â”‚       â”œâ”€â”€ SnoringSample.ts
â”‚   â”‚       â”œâ”€â”€ SpeedPlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ SpeedSample.ts
â”‚   â”‚       â”œâ”€â”€ StepSample.ts
â”‚   â”‚       â”œâ”€â”€ StepsPlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ StrainData.ts
â”‚   â”‚       â”œâ”€â”€ StrengthPlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ StressData.ts
â”‚   â”‚       â”œâ”€â”€ StressSample.ts
â”‚   â”‚       â”œâ”€â”€ StrokeType.ts
â”‚   â”‚       â”œâ”€â”€ SwimStrokePlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ SwimmingData.ts
â”‚   â”‚       â”œâ”€â”€ SwimmingPlannedWorkoutStep.ts
â”‚   â”‚       â”œâ”€â”€ TagData.ts
â”‚   â”‚       â”œâ”€â”€ TagEntry.ts
â”‚   â”‚       â”œâ”€â”€ TemperatureData.ts
â”‚   â”‚       â”œâ”€â”€ TemperatureSample.ts
â”‚   â”‚       â”œâ”€â”€ TerraUser.ts
â”‚   â”‚       â”œâ”€â”€ TimePlannedWorkoutStepDuration.ts
â”‚   â”‚       â”œâ”€â”€ TimestampLocalization.ts
â”‚   â”‚       â”œâ”€â”€ TorqueSample.ts
â”‚   â”‚       â”œâ”€â”€ TrendArrow.ts
â”‚   â”‚       â”œâ”€â”€ TssData.ts
â”‚   â”‚       â”œâ”€â”€ TssPlannedWorkoutStepTarget.ts
â”‚   â”‚       â”œâ”€â”€ TssSample.ts
â”‚   â”‚       â”œâ”€â”€ UnauthorizedErrorBody.ts
â”‚   â”‚       â”œâ”€â”€ UploadType.ts
â”‚   â”‚       â”œâ”€â”€ User.ts
â”‚   â”‚       â”œâ”€â”€ UserAuthWebhook.ts
â”‚   â”‚       â”œâ”€â”€ UserAuthWebhookError.ts
â”‚   â”‚       â”œâ”€â”€ UserAuthWebhookPayload.ts
â”‚   â”‚       â”œâ”€â”€ UserDeauthWebhook.ts
â”‚   â”‚       â”œâ”€â”€ UserReauthEvent.ts
â”‚   â”‚       â”œâ”€â”€ UserReauthWebhook.ts
â”‚   â”‚       â”œâ”€â”€ Vo2MaxSample.ts
â”‚   â”‚       â”œâ”€â”€ WebhookEvent.ts
â”‚   â”‚       â”œâ”€â”€ WebhookEventType.ts
â”‚   â”‚       â”œâ”€â”€ WebhookEvents.ts
â”‚   â”‚       â”œâ”€â”€ WorkData.ts
â”‚   â”‚       â”œâ”€â”€ YogaPlannedWorkoutStep.ts
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”œâ”€â”€ fetcher
â”‚   â”‚   â”‚   â”œâ”€â”€ APIResponse.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ BinaryResponse.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ Fetcher.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ Headers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ HttpResponsePromise.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ RawResponse.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ ResponseWithBody.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ Supplier.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ createRequestUrl.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ getFetchFn.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ getHeader.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ getRequestBody.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ getResponseBody.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ makeRequest.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ requestWithRetries.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ signals.ts
â”‚   â”‚   â”‚   â””â”€â”€ stream-wrappers
â”‚   â”‚   â”‚       â”œâ”€â”€ Node18UniversalStreamWrapper.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ NodePre18StreamWrapper.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ UndiciStreamWrapper.ts
â”‚   â”‚   â”‚       â””â”€â”€ chooseStreamWrapper.ts
â”‚   â”‚   â”œâ”€â”€ headers.ts
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ json.ts
â”‚   â”‚   â””â”€â”€ runtime
â”‚   â”‚       â”œâ”€â”€ index.ts
â”‚   â”‚       â””â”€â”€ runtime.ts
â”‚   â”œâ”€â”€ environments.ts
â”‚   â”œâ”€â”€ errors
â”‚   â”‚   â”œâ”€â”€ TerraError.ts
â”‚   â”‚   â”œâ”€â”€ TerraTimeoutError.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ index.ts
â”‚   â””â”€â”€ version.ts
â””â”€â”€ tests
    â”œâ”€â”€ custom.test.ts
    â”œâ”€â”€ mock-server
    â”‚   â”œâ”€â”€ MockServer.ts
    â”‚   â”œâ”€â”€ MockServerPool.ts
    â”‚   â”œâ”€â”€ mockEndpointBuilder.ts
    â”‚   â”œâ”€â”€ randomBaseUrl.ts
    â”‚   â”œâ”€â”€ setup.ts
    â”‚   â”œâ”€â”€ withHeaders.ts
    â”‚   â””â”€â”€ withJson.ts
    â”œâ”€â”€ unit
    â”‚   â””â”€â”€ fetcher
    â”‚       â”œâ”€â”€ Fetcher.test.ts
    â”‚       â”œâ”€â”€ HttpResponsePromise.test.ts
    â”‚       â”œâ”€â”€ RawResponse.test.ts
    â”‚       â”œâ”€â”€ createRequestUrl.test.ts
    â”‚       â”œâ”€â”€ getFetchFn.test.ts
    â”‚       â”œâ”€â”€ getRequestBody.test.ts
    â”‚       â”œâ”€â”€ getResponseBody.test.ts
    â”‚       â”œâ”€â”€ makeRequest.test.ts
    â”‚       â”œâ”€â”€ requestWithRetries.test.ts
    â”‚       â”œâ”€â”€ signals.test.ts
    â”‚       â”œâ”€â”€ stream-wrappers
    â”‚       â”‚   â”œâ”€â”€ Node18UniversalStreamWrapper.test.ts
    â”‚       â”‚   â”œâ”€â”€ NodePre18StreamWrapper.test.ts
    â”‚       â”‚   â”œâ”€â”€ UndiciStreamWrapper.test.ts
    â”‚       â”‚   â”œâ”€â”€ chooseStreamWrapper.test.ts
    â”‚       â”‚   â””â”€â”€ webpack.test.ts
    â”‚       â””â”€â”€ test-file.txt
    â””â”€â”€ wire
        â”œâ”€â”€ activity.test.ts
        â”œâ”€â”€ athlete.test.ts
        â”œâ”€â”€ authentication.test.ts
        â”œâ”€â”€ body.test.ts
        â”œâ”€â”€ daily.test.ts
        â”œâ”€â”€ integrations.test.ts
        â”œâ”€â”€ menstruation.test.ts
        â”œâ”€â”€ nutrition.test.ts
        â”œâ”€â”€ plannedworkout.test.ts
        â”œâ”€â”€ sleep.test.ts
        â””â”€â”€ user.test.ts

</source-tree>

<files>
<file path="terra-client-js/README.md">
```md
# Terra TypeScript Library

[![fern shield](https://img.shields.io/badge/%F0%9F%8C%BF-Built%20with%20Fern-brightgreen)](https://buildwithfern.com?utm_source=github&utm_medium=github&utm_campaign=readme&utm_source=https%3A%2F%2Fgithub.com%2Ftryterra%2Fterra-client-js)
[![npm shield](https://img.shields.io/npm/v/terra-api)](https://www.npmjs.com/package/terra-api)

The Terra TypeScript library provides convenient access to the Terra API from TypeScript.

## Documentation

API reference documentation is available [here](https://docs.tryterra.co/reference).

## Installation

```sh
npm i -s terra-api
```

## Reference

A full reference for this library is available [here](https://github.com/tryterra/terra-client-js/blob/HEAD/./reference.md).

## Usage

Instantiate and use the client with the following:

```typescript
import { TerraClient } from "terra-api";

const client = new TerraClient({ apiKey: "YOUR_API_KEY", devId: "YOUR_DEV_ID" });
await client.integrations.fetch();
```

## Request And Response Types

The SDK exports all request and response types as TypeScript interfaces. Simply import them with the
following namespace:

```typescript
import { Terra } from "terra-api";

const request: Terra.AuthenticationAuthenticateUserRequest = {
    ...
};
```

## Exception Handling

When the API returns a non-success status code (4xx or 5xx response), a subclass of the following error
will be thrown.

```typescript
import { TerraError } from "terra-api";

try {
    await client.integrations.fetch(...);
} catch (err) {
    if (err instanceof TerraError) {
        console.log(err.statusCode);
        console.log(err.message);
        console.log(err.body);
        console.log(err.rawResponse);
    }
}
```

## Advanced

### Additional Headers

If you would like to send additional headers as part of the request, use the `headers` request option.

```typescript
const response = await client.integrations.fetch(..., {
    headers: {
        'X-Custom-Header': 'custom value'
    }
});
```

### Retries

The SDK is instrumented with automatic retries with exponential backoff. A request will be retried as long
as the request is deemed retryable and the number of retry attempts has not grown larger than the configured
retry limit (default: 2).

A request is deemed retryable when any of the following HTTP status codes is returned:

- [408](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408) (Timeout)
- [429](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429) (Too Many Requests)
- [5XX](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500) (Internal Server Errors)

Use the `maxRetries` request option to configure this behavior.

```typescript
const response = await client.integrations.fetch(..., {
    maxRetries: 0 // override maxRetries at the request level
});
```

### Timeouts

The SDK defaults to a 60 second timeout. Use the `timeoutInSeconds` option to configure this behavior.

```typescript
const response = await client.integrations.fetch(..., {
    timeoutInSeconds: 30 // override timeout to 30s
});
```

### Aborting Requests

The SDK allows users to abort requests at any point by passing in an abort signal.

```typescript
const controller = new AbortController();
const response = await client.integrations.fetch(..., {
    abortSignal: controller.signal
});
controller.abort(); // aborts the request
```

### Access Raw Response Data

The SDK provides access to raw response data, including headers, through the `.withRawResponse()` method.
The `.withRawResponse()` method returns a promise that results to an object with a `data` and a `rawResponse` property.

```typescript
const { data, rawResponse } = await client.integrations.fetch(...).withRawResponse();

console.log(data);
console.log(rawResponse.headers['X-My-Header']);
```

### Runtime Compatibility

The SDK defaults to `node-fetch` but will use the global fetch client if present. The SDK works in the following
runtimes:

- Node.js 18+
- Vercel
- Cloudflare Workers
- Deno v1.25+
- Bun 1.0+
- React Native

### Customizing Fetch Client

The SDK provides a way for you to customize the underlying HTTP client / Fetch function. If you're running in an
unsupported environment, this provides a way for you to break glass and ensure the SDK works.

```typescript
import { TerraClient } from "terra-api";

const client = new TerraClient({
    ...
    fetcher: // provide your implementation here
});
```

## Contributing

While we value open-source contributions to this SDK, this library is generated programmatically.
Additions made directly to this library would have to be moved over to our generation code,
otherwise they would be overwritten upon the next generated release. Feel free to open a PR as
a proof of concept, but know that we will not be able to merge it as-is. We suggest opening
an issue first to discuss with us!

On the other hand, contributions to the README are always very welcome!

```
</file>
<file path="terra-client-js/jest.config.mjs">
```mjs
/** @type {import('jest').Config} */
export default {
    preset: "ts-jest",
    testEnvironment: "node",
    moduleNameMapper: {
        "^(\.{1,2}/.*)\.js$": "$1",
    },
    setupFilesAfterEnv: ["<rootDir>/tests/mock-server/setup.ts"],
};

```
</file>
<file path="terra-client-js/package.json">
```json
{
    "name": "terra-api",
    "version": "2.0.2",
    "private": false,
    "repository": "https://github.com/tryterra/terra-client-js",
    "type": "commonjs",
    "main": "./dist/cjs/index.js",
    "module": "./dist/esm/index.mjs",
    "types": "./dist/cjs/index.d.ts",
    "exports": {
        ".": {
            "types": "./dist/cjs/index.d.ts",
            "import": {
                "types": "./dist/esm/index.d.mts",
                "default": "./dist/esm/index.mjs"
            },
            "require": {
                "types": "./dist/cjs/index.d.ts",
                "default": "./dist/cjs/index.js"
            },
            "default": "./dist/cjs/index.js"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "dist",
        "reference.md"
    ],
    "scripts": {
        "format": "prettier . --write --ignore-unknown",
        "build": "yarn build:cjs && yarn build:esm",
        "build:cjs": "tsc --project ./tsconfig.cjs.json",
        "build:esm": "tsc --project ./tsconfig.esm.json && node scripts/rename-to-esm-files.js dist/esm",
        "test": "jest tests/unit --passWithNoTests",
        "test:wire": "jest tests/wire --passWithNoTests",
        "wire:test": "yarn test:wire"
    },
    "dependencies": {
        "url-join": "4.0.1",
        "form-data": "^4.0.0",
        "formdata-node": "^6.0.3",
        "node-fetch": "^2.7.0",
        "qs": "^6.13.1",
        "readable-stream": "^4.5.2"
    },
    "devDependencies": {
        "@types/url-join": "4.0.1",
        "@types/qs": "^6.9.17",
        "@types/node-fetch": "^2.6.12",
        "@types/readable-stream": "^4.0.18",
        "webpack": "^5.97.1",
        "ts-loader": "^9.5.1",
        "jest": "^29.7.0",
        "@jest/globals": "^29.7.0",
        "@types/jest": "^29.5.14",
        "ts-jest": "^29.3.4",
        "jest-environment-jsdom": "^29.7.0",
        "msw": "^2.8.4",
        "@types/node": "^18.19.70",
        "prettier": "^3.4.2",
        "typescript": "~5.7.2"
    },
    "browser": {
        "fs": false,
        "os": false,
        "path": false
    },
    "packageManager": "yarn@1.22.22"
}

```
</file>
<file path="terra-client-js/reference.md">
```md
# Reference

## Authentication

<details><summary><code>client.authentication.<a href="/src/api/resources/authentication/client/Client.ts">authenticateuser</a>({ ...params }) -> Terra.AuthenticationAuthenticateUserResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Creates a login link that allows end users to connect their fitness tracking account

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.authentication.authenticateuser({
    resource: "resource",
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.AuthenticationAuthenticateUserRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Authentication.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.authentication.<a href="/src/api/resources/authentication/client/Client.ts">generatewidgetsession</a>({ ...params }) -> Terra.AuthenticationGenerateWidgetSessionResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.authentication.generatewidgetsession();
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.WidgetSessionParams`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Authentication.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.authentication.<a href="/src/api/resources/authentication/client/Client.ts">deauthenticateuser</a>({ ...params }) -> Terra.AuthenticationDeauthenticateUserResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Deletes all records of the user on Terra's end, revoking Terra's access to their data

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.authentication.deauthenticateuser({
    user_id: "user_id",
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.AuthenticationDeauthenticateUserRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Authentication.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.authentication.<a href="/src/api/resources/authentication/client/Client.ts">generateauthtoken</a>() -> Terra.AuthenticationGenerateAuthTokenResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.authentication.generateauthtoken();
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**requestOptions:** `Authentication.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## User

<details><summary><code>client.user.<a href="/src/api/resources/user/client/Client.ts">modifyuser</a>(userId, { ...params }) -> Terra.UserModifyUserResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Update a Terra user's reference_id or active status

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.user.modifyuser("user_id");
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**userId:** `string` â€” Terra user ID to update

</dd>
</dl>

<dl>
<dd>

**request:** `Terra.UserModifyUserRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `User.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.user.<a href="/src/api/resources/user/client/Client.ts">getinfoforuserid</a>({ ...params }) -> Terra.UserGetInfoForUserIdResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.user.getinfoforuserid();
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.UserGetInfoForUserIdRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `User.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.user.<a href="/src/api/resources/user/client/Client.ts">getalluserids</a>({ ...params }) -> Terra.UserGetAllUserIDsResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.user.getalluserids();
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.UserGetAllUserIDsRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `User.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.user.<a href="/src/api/resources/user/client/Client.ts">getinfoformultipleuserids</a>({ ...params }) -> Terra.TerraUser[]</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to query for information for multiple Terra User IDs

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.user.getinfoformultipleuserids(["string"]);
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `string[]`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `User.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Activity

<details><summary><code>client.activity.<a href="/src/api/resources/activity/client/Client.ts">fetch</a>({ ...params }) -> Terra.ActivityFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.activity.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.ActivityFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Activity.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.activity.<a href="/src/api/resources/activity/client/Client.ts">write</a>({ ...params }) -> Terra.ActivityWriteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to post activity data to a provider. Available for Wahoo

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.activity.write({
    data: [
        {
            metadata: {
                end_time: "2022-10-28T10:00:00.000000+01:00",
                start_time: "1999-11-23T09:00:00.000000+02:00",
                summary_id: "123e4567-e89b-12d3-a456-426614174000",
                type: 1.1,
                upload_type: 1.1,
            },
        },
    ],
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.ActivityWriteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Activity.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Athlete

<details><summary><code>client.athlete.<a href="/src/api/resources/athlete/client/Client.ts">fetch</a>({ ...params }) -> Terra.AthleteFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches relevant profile info such as first & last name, birth date etc. for a given user ID

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.athlete.fetch({
    user_id: "user_id",
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.AthleteFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Athlete.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Body

<details><summary><code>client.body.<a href="/src/api/resources/body/client/Client.ts">fetch</a>({ ...params }) -> Terra.BodyFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.body.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.BodyFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Body.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.body.<a href="/src/api/resources/body/client/Client.ts">write</a>({ ...params }) -> Terra.BodyWriteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to post body data to a provider. Available for Google Fit

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.body.write({
    data: [
        {
            metadata: {
                end_time: "2022-10-28T10:00:00.000000+01:00",
                start_time: "1999-11-23T09:00:00.000000+02:00",
            },
        },
    ],
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.BodyWriteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Body.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.body.<a href="/src/api/resources/body/client/Client.ts">delete</a>({ ...params }) -> Terra.BodyDeleteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to delete Body metrics the user has registered on their account

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.body.delete({
    user_id: "user_id",
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.BodyDeleteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Body.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Daily

<details><summary><code>client.daily.<a href="/src/api/resources/daily/client/Client.ts">fetch</a>({ ...params }) -> Terra.DailyFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.daily.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.DailyFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Daily.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Menstruation

<details><summary><code>client.menstruation.<a href="/src/api/resources/menstruation/client/Client.ts">fetch</a>({ ...params }) -> Terra.MenstruationFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.menstruation.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.MenstruationFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Menstruation.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Nutrition

<details><summary><code>client.nutrition.<a href="/src/api/resources/nutrition/client/Client.ts">fetch</a>({ ...params }) -> Terra.NutritionFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.nutrition.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.NutritionFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Nutrition.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.nutrition.<a href="/src/api/resources/nutrition/client/Client.ts">write</a>({ ...params }) -> Terra.NutritionWriteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to post nutrition logs to a provider. Available for Fitbit

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.nutrition.write({
    data: [
        {
            metadata: {
                end_time: "2022-10-28T10:00:00.000000+01:00",
                start_time: "1999-11-23T09:00:00.000000+02:00",
            },
        },
    ],
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.NutritionWriteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Nutrition.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.nutrition.<a href="/src/api/resources/nutrition/client/Client.ts">delete</a>({ ...params }) -> Terra.NutritionDeleteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to delete nutrition logs the user has registered on their account

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.nutrition.delete({
    user_id: "user_id",
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.NutritionDeleteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Nutrition.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Sleep

<details><summary><code>client.sleep.<a href="/src/api/resources/sleep/client/Client.ts">fetch</a>({ ...params }) -> Terra.SleepFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.sleep.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.SleepFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Sleep.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Plannedworkout

<details><summary><code>client.plannedworkout.<a href="/src/api/resources/plannedworkout/client/Client.ts">fetch</a>({ ...params }) -> Terra.PlannedWorkoutFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to get workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.plannedworkout.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.PlannedWorkoutFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Plannedworkout.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.plannedworkout.<a href="/src/api/resources/plannedworkout/client/Client.ts">write</a>({ ...params }) -> Terra.PlannedWorkoutWriteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to post workout plans users can follow on their wearable. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.plannedworkout.write({
    data: [{}],
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.PlannedWorkoutWriteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Plannedworkout.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.plannedworkout.<a href="/src/api/resources/plannedworkout/client/Client.ts">delete</a>({ ...params }) -> Terra.PlannedWorkoutDeleteResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Used to delete workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.plannedworkout.delete({
    user_id: "user_id",
});
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.PlannedWorkoutDeleteRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Plannedworkout.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

## Integrations

<details><summary><code>client.integrations.<a href="/src/api/resources/integrations/client/Client.ts">fetch</a>() -> Terra.IntegrationsFetchResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Retrieve a list of all available provider integrations on the API.

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.integrations.fetch();
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**requestOptions:** `Integrations.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

<details><summary><code>client.integrations.<a href="/src/api/resources/integrations/client/Client.ts">detailedfetch</a>({ ...params }) -> Terra.IntegrationsResponse</code></summary>
<dl>
<dd>

#### ğŸ“ Description

<dl>
<dd>

<dl>
<dd>

Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.

</dd>
</dl>
</dd>
</dl>

#### ğŸ”Œ Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.integrations.detailedfetch();
```

</dd>
</dl>
</dd>
</dl>

#### âš™ï¸ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Terra.IntegrationsDetailedFetchRequest`

</dd>
</dl>

<dl>
<dd>

**requestOptions:** `Integrations.RequestOptions`

</dd>
</dl>
</dd>
</dl>

</dd>
</dl>
</details>

```
</file>
<file path="terra-client-js/src/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "./environments.js";
import * as core from "./core/index.js";
import { mergeHeaders } from "./core/headers.js";
import { Authentication } from "./api/resources/authentication/client/Client.js";
import { User } from "./api/resources/user/client/Client.js";
import { Activity } from "./api/resources/activity/client/Client.js";
import { Athlete } from "./api/resources/athlete/client/Client.js";
import { Body } from "./api/resources/body/client/Client.js";
import { Daily } from "./api/resources/daily/client/Client.js";
import { Menstruation } from "./api/resources/menstruation/client/Client.js";
import { Nutrition } from "./api/resources/nutrition/client/Client.js";
import { Sleep } from "./api/resources/sleep/client/Client.js";
import { Plannedworkout } from "./api/resources/plannedworkout/client/Client.js";
import { Integrations } from "./api/resources/integrations/client/Client.js";

export declare namespace TerraClient {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class TerraClient {
    protected readonly _options: TerraClient.Options;
    protected _authentication: Authentication | undefined;
    protected _user: User | undefined;
    protected _activity: Activity | undefined;
    protected _athlete: Athlete | undefined;
    protected _body: Body | undefined;
    protected _daily: Daily | undefined;
    protected _menstruation: Menstruation | undefined;
    protected _nutrition: Nutrition | undefined;
    protected _sleep: Sleep | undefined;
    protected _plannedworkout: Plannedworkout | undefined;
    protected _integrations: Integrations | undefined;

    constructor(_options: TerraClient.Options) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "dev-id": _options?.devId,
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "terra-api",
                    "X-Fern-SDK-Version": "2.0.2",
                    "User-Agent": "terra-api/2.0.2",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    public get authentication(): Authentication {
        return (this._authentication ??= new Authentication(this._options));
    }

    public get user(): User {
        return (this._user ??= new User(this._options));
    }

    public get activity(): Activity {
        return (this._activity ??= new Activity(this._options));
    }

    public get athlete(): Athlete {
        return (this._athlete ??= new Athlete(this._options));
    }

    public get body(): Body {
        return (this._body ??= new Body(this._options));
    }

    public get daily(): Daily {
        return (this._daily ??= new Daily(this._options));
    }

    public get menstruation(): Menstruation {
        return (this._menstruation ??= new Menstruation(this._options));
    }

    public get nutrition(): Nutrition {
        return (this._nutrition ??= new Nutrition(this._options));
    }

    public get sleep(): Sleep {
        return (this._sleep ??= new Sleep(this._options));
    }

    public get plannedworkout(): Plannedworkout {
        return (this._plannedworkout ??= new Plannedworkout(this._options));
    }

    public get integrations(): Integrations {
        return (this._integrations ??= new Integrations(this._options));
    }
}

```
</file>
<file path="terra-client-js/src/api/errors/BadRequestError.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../errors/index.js";
import * as core from "../../core/index.js";

export class BadRequestError extends errors.TerraError {
    constructor(body?: unknown, rawResponse?: core.RawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, BadRequestError.prototype);
    }
}

```
</file>
<file path="terra-client-js/src/api/errors/NotFoundError.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../errors/index.js";
import * as core from "../../core/index.js";

export class NotFoundError extends errors.TerraError {
    constructor(body?: unknown, rawResponse?: core.RawResponse) {
        super({
            message: "NotFoundError",
            statusCode: 404,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }
}

```
</file>
<file path="terra-client-js/src/api/errors/UnauthorizedError.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../errors/index.js";
import * as core from "../../core/index.js";

export class UnauthorizedError extends errors.TerraError {
    constructor(body?: unknown, rawResponse?: core.RawResponse) {
        super({
            message: "UnauthorizedError",
            statusCode: 401,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, UnauthorizedError.prototype);
    }
}

```
</file>
<file path="terra-client-js/src/api/errors/index.ts">
```ts
export * from "./BadRequestError.js";
export * from "./NotFoundError.js";
export * from "./UnauthorizedError.js";

```
</file>
<file path="terra-client-js/src/api/index.ts">
```ts
export * from "./resources/index.js";
export * from "./types/index.js";
export * from "./errors/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/activity/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Activity {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Activity {
    protected readonly _options: Activity.Options;

    constructor(_options: Activity.Options) {
        this._options = _options;
    }

    /**
     * Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)
     *
     * @param {Terra.ActivityFetchRequest} request
     * @param {Activity.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.activity.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.ActivityFetchRequest,
        requestOptions?: Activity.RequestOptions,
    ): core.HttpResponsePromise<Terra.ActivityFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.ActivityFetchRequest,
        requestOptions?: Activity.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.ActivityFetchResponse>> {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "activity",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.ActivityFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /activity.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post activity data to a provider. Available for Wahoo
     *
     * @param {Terra.ActivityWriteRequest} request
     * @param {Activity.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.activity.write({
     *         data: [{
     *                 metadata: {
     *                     end_time: "2022-10-28T10:00:00.000000+01:00",
     *                     start_time: "1999-11-23T09:00:00.000000+02:00",
     *                     summary_id: "123e4567-e89b-12d3-a456-426614174000",
     *                     type: 1.1,
     *                     upload_type: 1.1
     *                 }
     *             }]
     *     })
     */
    public write(
        request: Terra.ActivityWriteRequest,
        requestOptions?: Activity.RequestOptions,
    ): core.HttpResponsePromise<Terra.ActivityWriteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.ActivityWriteRequest,
        requestOptions?: Activity.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.ActivityWriteResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "activity",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.ActivityWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /activity.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/activity/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/activity/client/requests/ActivityFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface ActivityFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.ActivityFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/activity/client/requests/ActivityWriteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{
 *                 metadata: {
 *                     end_time: "2022-10-28T10:00:00.000000+01:00",
 *                     start_time: "1999-11-23T09:00:00.000000+02:00",
 *                     summary_id: "123e4567-e89b-12d3-a456-426614174000",
 *                     type: 1.1,
 *                     upload_type: 1.1
 *                 }
 *             }]
 *     }
 */
export interface ActivityWriteRequest {
    /** List of user-tracked workouts to post to data provider */
    data: Terra.Activity[];
}

```
</file>
<file path="terra-client-js/src/api/resources/activity/client/requests/index.ts">
```ts
export { type ActivityFetchRequest } from "./ActivityFetchRequest.js";
export { type ActivityWriteRequest } from "./ActivityWriteRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/activity/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/activity/types/ActivityFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ActivityFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/activity/types/ActivityFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type ActivityFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Activity[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/resources/activity/types/ActivityWriteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface ActivityWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/activity/types/index.ts">
```ts
export * from "./ActivityFetchRequestStartDate.js";
export * from "./ActivityFetchResponse.js";
export * from "./ActivityWriteResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/athlete/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Athlete {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Athlete {
    protected readonly _options: Athlete.Options;

    constructor(_options: Athlete.Options) {
        this._options = _options;
    }

    /**
     * Fetches relevant profile info such as first & last name, birth date etc. for a given user ID
     *
     * @param {Terra.AthleteFetchRequest} request
     * @param {Athlete.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.athlete.fetch({
     *         user_id: "user_id"
     *     })
     */
    public fetch(
        request: Terra.AthleteFetchRequest,
        requestOptions?: Athlete.RequestOptions,
    ): core.HttpResponsePromise<Terra.AthleteFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.AthleteFetchRequest,
        requestOptions?: Athlete.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.AthleteFetchResponse>> {
        const { user_id: userId, to_webhook: toWebhook } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "athlete",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.AthleteFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /athlete.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/athlete/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/athlete/client/requests/AthleteFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface AthleteFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/athlete/client/requests/index.ts">
```ts
export { type AthleteFetchRequest } from "./AthleteFetchRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/athlete/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/athlete/types/AthleteFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type AthleteFetchResponse =
    | Terra.AthleteFetchResponse.Athlete
    | Terra.AthleteFetchResponse.NoData
    | Terra.AthleteFetchResponse.Webhook;

export namespace AthleteFetchResponse {
    export interface Athlete extends Terra.AthleteCollection {
        type: "athlete";
    }

    export interface NoData extends Terra.NoDataReturned {
        type: "no_data";
    }

    export interface Webhook extends Terra.DataSentToWebhook {
        type: "webhook";
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/athlete/types/index.ts">
```ts
export * from "./AthleteFetchResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/authentication/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Authentication {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Authentication {
    protected readonly _options: Authentication.Options;

    constructor(_options: Authentication.Options) {
        this._options = _options;
    }

    /**
     * Creates a login link that allows end users to connect their fitness tracking account
     *
     * @param {Terra.AuthenticationAuthenticateUserRequest} request
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.authentication.authenticateuser({
     *         resource: "resource"
     *     })
     */
    public authenticateuser(
        request: Terra.AuthenticationAuthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise<Terra.AuthenticationAuthenticateUserResponse> {
        return core.HttpResponsePromise.fromPromise(this.__authenticateuser(request, requestOptions));
    }

    private async __authenticateuser(
        request: Terra.AuthenticationAuthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.AuthenticationAuthenticateUserResponse>> {
        const { resource, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["resource"] = resource;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/authenticateUser",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationAuthenticateUserResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /auth/authenticateUser.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider
     *
     * @param {Terra.WidgetSessionParams} request
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     *
     * @example
     *     await client.authentication.generatewidgetsession()
     */
    public generatewidgetsession(
        request: Terra.WidgetSessionParams = {},
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise<Terra.AuthenticationGenerateWidgetSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__generatewidgetsession(request, requestOptions));
    }

    private async __generatewidgetsession(
        request: Terra.WidgetSessionParams = {},
        requestOptions?: Authentication.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.AuthenticationGenerateWidgetSessionResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/generateWidgetSession",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationGenerateWidgetSessionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /auth/generateWidgetSession.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes all records of the user on Terra's end, revoking Terra's access to their data
     *
     * @param {Terra.AuthenticationDeauthenticateUserRequest} request
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.authentication.deauthenticateuser({
     *         user_id: "user_id"
     *     })
     */
    public deauthenticateuser(
        request: Terra.AuthenticationDeauthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise<Terra.AuthenticationDeauthenticateUserResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deauthenticateuser(request, requestOptions));
    }

    private async __deauthenticateuser(
        request: Terra.AuthenticationDeauthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.AuthenticationDeauthenticateUserResponse>> {
        const { user_id: userId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/deauthenticateUser",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationDeauthenticateUserResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /auth/deauthenticateUser.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)
     *
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.authentication.generateauthtoken()
     */
    public generateauthtoken(
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise<Terra.AuthenticationGenerateAuthTokenResponse> {
        return core.HttpResponsePromise.fromPromise(this.__generateauthtoken(requestOptions));
    }

    private async __generateauthtoken(
        requestOptions?: Authentication.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.AuthenticationGenerateAuthTokenResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/generateAuthToken",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationGenerateAuthTokenResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /auth/generateAuthToken.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/authentication/client/requests/AuthenticationAuthenticateUserRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         resource: "resource"
 *     }
 */
export interface AuthenticationAuthenticateUserRequest {
    /**
     * resource to authenticate user with
     */
    resource: string;
    language?: string;
    reference_id?: string;
    auth_success_redirect_url?: string;
    auth_failure_redirect_url?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/client/requests/AuthenticationDeauthenticateUserRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface AuthenticationDeauthenticateUserRequest {
    /**
     * user_id to deauthenticate for
     */
    user_id: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/client/requests/WidgetSessionParams.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface WidgetSessionParams {
    /** Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard */
    providers?: string;
    /** Display language of the widget */
    language?: string;
    /** Identifier of the end user on your system, such as a user ID or email associated with them */
    reference_id?: string;
    /** URL the user is redirected to upon successful authentication */
    auth_success_redirect_url?: string;
    /** URL the user is redirected to upon unsuccessful authentication */
    auth_failure_redirect_url?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/client/requests/index.ts">
```ts
export { type AuthenticationAuthenticateUserRequest } from "./AuthenticationAuthenticateUserRequest.js";
export { type WidgetSessionParams } from "./WidgetSessionParams.js";
export { type AuthenticationDeauthenticateUserRequest } from "./AuthenticationDeauthenticateUserRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/authentication/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/authentication/types/AuthenticationAuthenticateUserResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationAuthenticateUserResponse {
    /** indicates that the request was successful */
    status?: AuthenticationAuthenticateUserResponse.Status;
    /** User ID for the user being created */
    user_id?: string;
    /** authentication URL the user must be redirected to in order to link their account */
    auth_url?: string;
}

export namespace AuthenticationAuthenticateUserResponse {
    /**
     * indicates that the request was successful
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/types/AuthenticationDeauthenticateUserResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationDeauthenticateUserResponse {
    /** indicates that an error happened (value is success) */
    status?: AuthenticationDeauthenticateUserResponse.Status;
}

export namespace AuthenticationDeauthenticateUserResponse {
    /**
     * indicates that an error happened (value is success)
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/types/AuthenticationGenerateAuthTokenResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationGenerateAuthTokenResponse {
    status?: string;
    token?: string;
    expires_in?: number;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/types/AuthenticationGenerateWidgetSessionResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationGenerateWidgetSessionResponse {
    /** Session ID for the widget authentication session */
    session_id?: string;
    /** the widget URL the user must be redirected to in order to link their account */
    url?: string;
    /** indicates that an error happened (value is success) */
    status?: AuthenticationGenerateWidgetSessionResponse.Status;
    /** a number in seconds depicting how long the url is valid for */
    expires_in?: number;
}

export namespace AuthenticationGenerateWidgetSessionResponse {
    /**
     * indicates that an error happened (value is success)
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/resources/authentication/types/index.ts">
```ts
export * from "./AuthenticationAuthenticateUserResponse.js";
export * from "./AuthenticationGenerateWidgetSessionResponse.js";
export * from "./AuthenticationDeauthenticateUserResponse.js";
export * from "./AuthenticationGenerateAuthTokenResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/body/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Body {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Body {
    protected readonly _options: Body.Options;

    constructor(_options: Body.Options) {
        this._options = _options;
    }

    /**
     * Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID
     *
     * @param {Terra.BodyFetchRequest} request
     * @param {Body.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.body.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.BodyFetchRequest,
        requestOptions?: Body.RequestOptions,
    ): core.HttpResponsePromise<Terra.BodyFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.BodyFetchRequest,
        requestOptions?: Body.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.BodyFetchResponse>> {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "body",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.BodyFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /body.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post body data to a provider. Available for Google Fit
     *
     * @param {Terra.BodyWriteRequest} request
     * @param {Body.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.body.write({
     *         data: [{
     *                 metadata: {
     *                     end_time: "2022-10-28T10:00:00.000000+01:00",
     *                     start_time: "1999-11-23T09:00:00.000000+02:00"
     *                 }
     *             }]
     *     })
     */
    public write(
        request: Terra.BodyWriteRequest,
        requestOptions?: Body.RequestOptions,
    ): core.HttpResponsePromise<Terra.BodyWriteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.BodyWriteRequest,
        requestOptions?: Body.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.BodyWriteResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "body",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.BodyWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /body.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to delete Body metrics the user has registered on their account
     *
     * @param {Terra.BodyDeleteRequest} request
     * @param {Body.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.body.delete({
     *         user_id: "user_id"
     *     })
     */
    public delete(
        request: Terra.BodyDeleteRequest,
        requestOptions?: Body.RequestOptions,
    ): core.HttpResponsePromise<Terra.BodyDeleteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Terra.BodyDeleteRequest,
        requestOptions?: Body.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.BodyDeleteResponse>> {
        const { user_id: userId, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "body",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.BodyDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /body.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/body/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/body/client/requests/BodyDeleteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface BodyDeleteRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /** List of identifiers for body metrics entries to be deleted */
    log_ids?: string[];
}

```
</file>
<file path="terra-client-js/src/api/resources/body/client/requests/BodyFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface BodyFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.BodyFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/body/client/requests/BodyWriteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{
 *                 metadata: {
 *                     end_time: "2022-10-28T10:00:00.000000+01:00",
 *                     start_time: "1999-11-23T09:00:00.000000+02:00"
 *                 }
 *             }]
 *     }
 */
export interface BodyWriteRequest {
    /** Body measurement metrics to post to data provider */
    data: Terra.Body[];
}

```
</file>
<file path="terra-client-js/src/api/resources/body/client/requests/index.ts">
```ts
export { type BodyFetchRequest } from "./BodyFetchRequest.js";
export { type BodyWriteRequest } from "./BodyWriteRequest.js";
export { type BodyDeleteRequest } from "./BodyDeleteRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/body/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/body/types/BodyDeleteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface BodyDeleteResponse {
    user?: Terra.TerraUser;
    processed_data?: BodyDeleteResponse.ProcessedData.Item[];
}

export namespace BodyDeleteResponse {
    export type ProcessedData = ProcessedData.Item[];

    export namespace ProcessedData {
        export interface Item {
            /** Identifier of the body metric entries whose deletion was attempted */
            id?: string;
            /** Response code from the provider when attempting to delete the body metric entries */
            response_code?: number;
        }
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/body/types/BodyFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type BodyFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/body/types/BodyFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type BodyFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Body[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/resources/body/types/BodyWriteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface BodyWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/body/types/index.ts">
```ts
export * from "./BodyFetchRequestStartDate.js";
export * from "./BodyFetchResponse.js";
export * from "./BodyWriteResponse.js";
export * from "./BodyDeleteResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/daily/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Daily {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Daily {
    protected readonly _options: Daily.Options;

    constructor(_options: Daily.Options) {
        this._options = _options;
    }

    /**
     * Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID
     *
     * @param {Terra.DailyFetchRequest} request
     * @param {Daily.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.daily.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.DailyFetchRequest,
        requestOptions?: Daily.RequestOptions,
    ): core.HttpResponsePromise<Terra.DailyFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.DailyFetchRequest,
        requestOptions?: Daily.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.DailyFetchResponse>> {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "daily",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.DailyFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /daily.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/daily/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/daily/client/requests/DailyFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface DailyFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.DailyFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/daily/client/requests/index.ts">
```ts
export { type DailyFetchRequest } from "./DailyFetchRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/daily/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/daily/types/DailyFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type DailyFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/daily/types/DailyFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type DailyFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Daily[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/resources/daily/types/index.ts">
```ts
export * from "./DailyFetchRequestStartDate.js";
export * from "./DailyFetchResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/index.ts">
```ts
export * as authentication from "./authentication/index.js";
export * from "./authentication/types/index.js";
export * as user from "./user/index.js";
export * from "./user/types/index.js";
export * as activity from "./activity/index.js";
export * from "./activity/types/index.js";
export * as athlete from "./athlete/index.js";
export * from "./athlete/types/index.js";
export * as body from "./body/index.js";
export * from "./body/types/index.js";
export * as daily from "./daily/index.js";
export * from "./daily/types/index.js";
export * as menstruation from "./menstruation/index.js";
export * from "./menstruation/types/index.js";
export * as nutrition from "./nutrition/index.js";
export * from "./nutrition/types/index.js";
export * as sleep from "./sleep/index.js";
export * from "./sleep/types/index.js";
export * as plannedworkout from "./plannedworkout/index.js";
export * from "./plannedworkout/types/index.js";
export * as integrations from "./integrations/index.js";
export * from "./integrations/types/index.js";
export * from "./authentication/client/requests/index.js";
export * from "./user/client/requests/index.js";
export * from "./activity/client/requests/index.js";
export * from "./athlete/client/requests/index.js";
export * from "./body/client/requests/index.js";
export * from "./daily/client/requests/index.js";
export * from "./menstruation/client/requests/index.js";
export * from "./nutrition/client/requests/index.js";
export * from "./sleep/client/requests/index.js";
export * from "./plannedworkout/client/requests/index.js";
export * from "./integrations/client/requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/integrations/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Integrations {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Integrations {
    protected readonly _options: Integrations.Options;

    constructor(_options: Integrations.Options) {
        this._options = _options;
    }

    /**
     * Retrieve a list of all available provider integrations on the API.
     *
     * @param {Integrations.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.integrations.fetch()
     */
    public fetch(
        requestOptions?: Integrations.RequestOptions,
    ): core.HttpResponsePromise<Terra.IntegrationsFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(requestOptions));
    }

    private async __fetch(
        requestOptions?: Integrations.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.IntegrationsFetchResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "integrations",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.IntegrationsFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TerraError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /integrations.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.
     *
     * @param {Terra.IntegrationsDetailedFetchRequest} request
     * @param {Integrations.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.integrations.detailedfetch()
     */
    public detailedfetch(
        request: Terra.IntegrationsDetailedFetchRequest = {},
        requestOptions?: Integrations.RequestOptions,
    ): core.HttpResponsePromise<Terra.IntegrationsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__detailedfetch(request, requestOptions));
    }

    private async __detailedfetch(
        request: Terra.IntegrationsDetailedFetchRequest = {},
        requestOptions?: Integrations.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.IntegrationsResponse>> {
        const { sdk } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (sdk != null) {
            _queryParams["sdk"] = sdk.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "integrations/detailed",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.IntegrationsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TerraError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /integrations/detailed.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/integrations/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/integrations/client/requests/IntegrationsDetailedFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface IntegrationsDetailedFetchRequest {
    /**
     * If `true`, allows SDK integrations to be included in the response.
     */
    sdk?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/integrations/client/requests/index.ts">
```ts
export { type IntegrationsDetailedFetchRequest } from "./IntegrationsDetailedFetchRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/integrations/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/integrations/types/IntegrationsFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface IntegrationsFetchResponse {
    providers?: string[];
    sdk_resource?: string[];
    status?: IntegrationsFetchResponse.Status;
}

export namespace IntegrationsFetchResponse {
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/resources/integrations/types/index.ts">
```ts
export * from "./IntegrationsFetchResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Menstruation {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Menstruation {
    protected readonly _options: Menstruation.Options;

    constructor(_options: Menstruation.Options) {
        this._options = _options;
    }

    /**
     * Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID
     *
     * @param {Terra.MenstruationFetchRequest} request
     * @param {Menstruation.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.menstruation.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.MenstruationFetchRequest,
        requestOptions?: Menstruation.RequestOptions,
    ): core.HttpResponsePromise<Terra.MenstruationFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.MenstruationFetchRequest,
        requestOptions?: Menstruation.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.MenstruationFetchResponse>> {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "menstruation",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.MenstruationFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /menstruation.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/client/requests/MenstruationFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface MenstruationFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.MenstruationFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/client/requests/index.ts">
```ts
export { type MenstruationFetchRequest } from "./MenstruationFetchRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/types/MenstruationFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type MenstruationFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/types/MenstruationFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type MenstruationFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Menstruation[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/resources/menstruation/types/index.ts">
```ts
export * from "./MenstruationFetchRequestStartDate.js";
export * from "./MenstruationFetchResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Nutrition {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Nutrition {
    protected readonly _options: Nutrition.Options;

    constructor(_options: Nutrition.Options) {
        this._options = _options;
    }

    /**
     * Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID
     *
     * @param {Terra.NutritionFetchRequest} request
     * @param {Nutrition.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.nutrition.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.NutritionFetchRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): core.HttpResponsePromise<Terra.NutritionFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.NutritionFetchRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.NutritionFetchResponse>> {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "nutrition",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.NutritionFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /nutrition.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post nutrition logs to a provider. Available for Fitbit
     *
     * @param {Terra.NutritionWriteRequest} request
     * @param {Nutrition.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.nutrition.write({
     *         data: [{
     *                 metadata: {
     *                     end_time: "2022-10-28T10:00:00.000000+01:00",
     *                     start_time: "1999-11-23T09:00:00.000000+02:00"
     *                 }
     *             }]
     *     })
     */
    public write(
        request: Terra.NutritionWriteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): core.HttpResponsePromise<Terra.NutritionWriteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.NutritionWriteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.NutritionWriteResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "nutrition",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.NutritionWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /nutrition.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to delete nutrition logs the user has registered on their account
     *
     * @param {Terra.NutritionDeleteRequest} request
     * @param {Nutrition.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.nutrition.delete({
     *         user_id: "user_id"
     *     })
     */
    public delete(
        request: Terra.NutritionDeleteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): core.HttpResponsePromise<Terra.NutritionDeleteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Terra.NutritionDeleteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.NutritionDeleteResponse>> {
        const { user_id: userId, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "nutrition",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.NutritionDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /nutrition.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/client/requests/NutritionDeleteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface NutritionDeleteRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /** List of identifiers for nutrition entries to be deleted */
    data?: string[];
}

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/client/requests/NutritionFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface NutritionFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.NutritionFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/client/requests/NutritionWriteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{
 *                 metadata: {
 *                     end_time: "2022-10-28T10:00:00.000000+01:00",
 *                     start_time: "1999-11-23T09:00:00.000000+02:00"
 *                 }
 *             }]
 *     }
 */
export interface NutritionWriteRequest {
    /** Nutrition entry to post to data provider */
    data: Terra.Nutrition[];
}

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/client/requests/index.ts">
```ts
export { type NutritionFetchRequest } from "./NutritionFetchRequest.js";
export { type NutritionWriteRequest } from "./NutritionWriteRequest.js";
export { type NutritionDeleteRequest } from "./NutritionDeleteRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/types/NutritionDeleteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface NutritionDeleteResponse {
    user?: Terra.TerraUser;
    processed_data?: NutritionDeleteResponse.ProcessedData.Item[];
}

export namespace NutritionDeleteResponse {
    export type ProcessedData = ProcessedData.Item[];

    export namespace ProcessedData {
        export interface Item {
            /** Identifier of the nutrition log whose deletion was attempted */
            id?: string;
            /** Response code from the provider when attempting to delete the nutrition log */
            response_code?: number;
        }
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/types/NutritionFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type NutritionFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/types/NutritionFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type NutritionFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Nutrition[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/types/NutritionWriteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface NutritionWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/nutrition/types/index.ts">
```ts
export * from "./NutritionFetchRequestStartDate.js";
export * from "./NutritionFetchResponse.js";
export * from "./NutritionWriteResponse.js";
export * from "./NutritionDeleteResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Plannedworkout {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Plannedworkout {
    protected readonly _options: Plannedworkout.Options;

    constructor(_options: Plannedworkout.Options) {
        this._options = _options;
    }

    /**
     * Used to get workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
     *
     * @param {Terra.PlannedWorkoutFetchRequest} request
     * @param {Plannedworkout.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.plannedworkout.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.PlannedWorkoutFetchRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): core.HttpResponsePromise<Terra.PlannedWorkoutFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.PlannedWorkoutFetchRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.PlannedWorkoutFetchResponse>> {
        const { user_id: userId, start_date: startDate, end_date: endDate, to_webhook: toWebhook } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "plannedWorkout",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.PlannedWorkoutFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /plannedWorkout.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post workout plans users can follow on their wearable. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
     *
     * @param {Terra.PlannedWorkoutWriteRequest} request
     * @param {Plannedworkout.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.plannedworkout.write({
     *         data: [{}]
     *     })
     */
    public write(
        request: Terra.PlannedWorkoutWriteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): core.HttpResponsePromise<Terra.PlannedWorkoutWriteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.PlannedWorkoutWriteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.PlannedWorkoutWriteResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "plannedWorkout",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.PlannedWorkoutWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /plannedWorkout.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to delete workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
     *
     * @param {Terra.PlannedWorkoutDeleteRequest} request
     * @param {Plannedworkout.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.plannedworkout.delete({
     *         user_id: "user_id"
     *     })
     */
    public delete(
        request: Terra.PlannedWorkoutDeleteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): core.HttpResponsePromise<Terra.PlannedWorkoutDeleteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Terra.PlannedWorkoutDeleteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.PlannedWorkoutDeleteResponse>> {
        const { user_id: userId, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "plannedWorkout",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.PlannedWorkoutDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /plannedWorkout.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/client/requests/PlannedWorkoutDeleteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface PlannedWorkoutDeleteRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /** List of identifiers for planned workout entries to be deleted */
    data?: string[];
}

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/client/requests/PlannedWorkoutFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface PlannedWorkoutFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.PlannedWorkoutFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/client/requests/PlannedWorkoutWriteRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{}]
 *     }
 */
export interface PlannedWorkoutWriteRequest {
    /** PlannedWorkout entry to post to data provider */
    data: Terra.PlannedWorkout[];
}

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/client/requests/index.ts">
```ts
export { type PlannedWorkoutFetchRequest } from "./PlannedWorkoutFetchRequest.js";
export { type PlannedWorkoutWriteRequest } from "./PlannedWorkoutWriteRequest.js";
export { type PlannedWorkoutDeleteRequest } from "./PlannedWorkoutDeleteRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/types/PlannedWorkoutDeleteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface PlannedWorkoutDeleteResponse {
    user?: Terra.TerraUser;
    processed_data?: PlannedWorkoutDeleteResponse.ProcessedData.Item[];
}

export namespace PlannedWorkoutDeleteResponse {
    export type ProcessedData = ProcessedData.Item[];

    export namespace ProcessedData {
        export interface Item {
            /** Identifier of the planned workout whose deletion was attempted */
            id?: string;
            /** Response code from the provider when attempting to delete the planned workout */
            response_code?: number;
        }
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/types/PlannedWorkoutFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PlannedWorkoutFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/types/PlannedWorkoutFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type PlannedWorkoutFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.PlannedWorkout[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook;

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/types/PlannedWorkoutWriteResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface PlannedWorkoutWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/plannedworkout/types/index.ts">
```ts
export * from "./PlannedWorkoutFetchRequestStartDate.js";
export * from "./PlannedWorkoutFetchResponse.js";
export * from "./PlannedWorkoutWriteResponse.js";
export * from "./PlannedWorkoutDeleteResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/sleep/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Sleep {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Sleep {
    protected readonly _options: Sleep.Options;

    constructor(_options: Sleep.Options) {
        this._options = _options;
    }

    /**
     * Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time
     *
     * @param {Terra.SleepFetchRequest} request
     * @param {Sleep.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.sleep.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.SleepFetchRequest,
        requestOptions?: Sleep.RequestOptions,
    ): core.HttpResponsePromise<Terra.SleepFetchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.SleepFetchRequest,
        requestOptions?: Sleep.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.SleepFetchResponse>> {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "sleep",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.SleepFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /sleep.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/sleep/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/sleep/client/requests/SleepFetchRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface SleepFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.SleepFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/sleep/client/requests/index.ts">
```ts
export { type SleepFetchRequest } from "./SleepFetchRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/sleep/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/sleep/types/SleepFetchRequestStartDate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type SleepFetchRequestStartDate = number | string;

```
</file>
<file path="terra-client-js/src/api/resources/sleep/types/SleepFetchResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type SleepFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Sleep[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/resources/sleep/types/index.ts">
```ts
export * from "./SleepFetchRequestStartDate.js";
export * from "./SleepFetchResponse.js";

```
</file>
<file path="terra-client-js/src/api/resources/user/client/Client.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace User {
    export interface Options {
        environment?: core.Supplier<environments.TerraEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Override the dev-id header */
        devId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class User {
    protected readonly _options: User.Options;

    constructor(_options: User.Options) {
        this._options = _options;
    }

    /**
     * Update a Terra user's reference_id or active status
     *
     * @param {string} userId - Terra user ID to update
     * @param {Terra.UserModifyUserRequest} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     *
     * @example
     *     await client.user.modifyuser("user_id")
     */
    public modifyuser(
        userId: string,
        request: Terra.UserModifyUserRequest = {},
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise<Terra.UserModifyUserResponse> {
        return core.HttpResponsePromise.fromPromise(this.__modifyuser(userId, request, requestOptions));
    }

    private async __modifyuser(
        userId: string,
        request: Terra.UserModifyUserRequest = {},
        requestOptions?: User.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.UserModifyUserResponse>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                `users/${encodeURIComponent(userId)}`,
            ),
            method: "PATCH",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.UserModifyUserResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling PATCH /users/{user_id}.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID
     *
     * @param {Terra.UserGetInfoForUserIdRequest} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.user.getinfoforuserid()
     */
    public getinfoforuserid(
        request: Terra.UserGetInfoForUserIdRequest = {},
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise<Terra.UserGetInfoForUserIdResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getinfoforuserid(request, requestOptions));
    }

    private async __getinfoforuserid(
        request: Terra.UserGetInfoForUserIdRequest = {},
        requestOptions?: User.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.UserGetInfoForUserIdResponse>> {
        const { user_id: userId, reference_id: referenceId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (userId != null) {
            _queryParams["user_id"] = userId;
        }

        if (referenceId != null) {
            _queryParams["reference_id"] = referenceId;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "userInfo",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.UserGetInfoForUserIdResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /userInfo.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).
     *
     * @param {Terra.UserGetAllUserIDsRequest} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     *
     * @example
     *     await client.user.getalluserids()
     */
    public getalluserids(
        request: Terra.UserGetAllUserIDsRequest = {},
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise<Terra.UserGetAllUserIDsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getalluserids(request, requestOptions));
    }

    private async __getalluserids(
        request: Terra.UserGetAllUserIDsRequest = {},
        requestOptions?: User.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.UserGetAllUserIDsResponse>> {
        const { page, per_page: perPage } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams["page"] = page.toString();
        }

        if (perPage != null) {
            _queryParams["per_page"] = perPage.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "subscriptions",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.UserGetAllUserIDsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /subscriptions.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to query for information for multiple Terra User IDs
     *
     * @param {string[]} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.user.getinfoformultipleuserids(["string"])
     */
    public getinfoformultipleuserids(
        request: string[],
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise<Terra.TerraUser[]> {
        return core.HttpResponsePromise.fromPromise(this.__getinfoformultipleuserids(request, requestOptions));
    }

    private async __getinfoformultipleuserids(
        request: string[],
        requestOptions?: User.RequestOptions,
    ): Promise<core.WithRawResponse<Terra.TerraUser[]>> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "bulkUserInfo",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.TerraUser[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /bulkUserInfo.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}

```
</file>
<file path="terra-client-js/src/api/resources/user/client/index.ts">
```ts
export {};
export * from "./requests/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/user/client/requests/UserGetAllUserIDsRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface UserGetAllUserIDsRequest {
    /**
     * Zero-based page number. If omitted, results are not paginated.
     */
    page?: number;
    /**
     * Number of results per page (default is 500).
     */
    per_page?: number;
}

```
</file>
<file path="terra-client-js/src/api/resources/user/client/requests/UserGetInfoForUserIdRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface UserGetInfoForUserIdRequest {
    /**
     * user ID to query for
     */
    user_id?: string;
    /**
     * reference ID to query for
     */
    reference_id?: string;
}

```
</file>
<file path="terra-client-js/src/api/resources/user/client/requests/UserModifyUserRequest.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface UserModifyUserRequest {
    /** Identifier on your system to associate with this user */
    reference_id?: string;
    /** Whether the user should remain active */
    active?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/resources/user/client/requests/index.ts">
```ts
export { type UserModifyUserRequest } from "./UserModifyUserRequest.js";
export { type UserGetInfoForUserIdRequest } from "./UserGetInfoForUserIdRequest.js";
export { type UserGetAllUserIDsRequest } from "./UserGetAllUserIDsRequest.js";

```
</file>
<file path="terra-client-js/src/api/resources/user/index.ts">
```ts
export * from "./types/index.js";
export * from "./client/index.js";

```
</file>
<file path="terra-client-js/src/api/resources/user/types/UserGetAllUserIDsResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type UserGetAllUserIDsResponse =
    | {
          users?: Terra.TerraUser[] | undefined;
      }
    | {
          data?:
              | {
                    next?: number | undefined;
                    max_page?: number | undefined;
                    results?: Terra.TerraUser[] | undefined;
                }
              | undefined;
      };

```
</file>
<file path="terra-client-js/src/api/resources/user/types/UserGetInfoForUserIdResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type UserGetInfoForUserIdResponse =
    /**
     * User information for one connection (single User object) */
    | {
          user?: Terra.TerraUser | undefined;
          status?: ("success" | "error") | undefined;
          is_authenticated?: boolean | undefined;
      }
    /**
     * List of multiple User objects the reference_id is associated to */
    | Terra.TerraUser[];

```
</file>
<file path="terra-client-js/src/api/resources/user/types/UserModifyUserResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface UserModifyUserResponse {
    user?: Terra.TerraUser;
    /** Indicates that the request was successful */
    status?: UserModifyUserResponse.Status;
}

export namespace UserModifyUserResponse {
    /**
     * Indicates that the request was successful
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/resources/user/types/index.ts">
```ts
export * from "./UserModifyUserResponse.js";
export * from "./UserGetInfoForUserIdResponse.js";
export * from "./UserGetAllUserIDsResponse.js";

```
</file>
<file path="terra-client-js/src/api/types/AFibClassificationSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface AFibClassificationSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Flag indicating the atrial fibrillation classification of the individual */
    afib_classification?: Terra.Inconclusive;
}

```
</file>
<file path="terra-client-js/src/api/types/AccessRevokedEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Access revoked event when a user revokes access through the provider
 */
export interface AccessRevokedEvent {
    type: "access_revoked";
    /** User who revoked access */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the access revocation */
    message: string;
}

```
</file>
<file path="terra-client-js/src/api/types/AccessRevokedWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type AccessRevokedWebhook = Terra.AccessRevokedEvent;

```
</file>
<file path="terra-client-js/src/api/types/ActiveDurationsData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ActiveDurationsData {
    /** Array of detailed samples of the intensity the user was in at various points during the workout. */
    activity_levels_samples?: Terra.ActivityLevelSample[];
    /** Total number of seconds spent in an active state during the workout. */
    activity_seconds?: number;
    /** Total number of seconds spent in an inactive state during the workout. */
    inactivity_seconds?: number;
    /** Total number of seconds spent in a low intensity state during the workout. */
    low_intensity_seconds?: number;
    /** Total number of seconds spent in a moderate intensity state during the workout. */
    moderate_intensity_seconds?: number;
    /** Maximum number of continuous periods spent in an inactive state during the workout. */
    num_continuous_inactive_periods?: number;
    /** Total number of seconds spent resting during the workout. */
    rest_seconds?: number;
    /** Total number of seconds spent in a state of vigorous intensity during the workout. */
    vigorous_intensity_seconds?: number;
    standing_hours_count?: number;
    standing_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/Activity.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Activity {
    /** Number of minutes spent at various intensities during the workout, as reported by the Fitness Data provider. */
    active_durations_data?: Terra.ActiveDurationsData;
    /** Object containing calorie-related information for the user during the specific workout. */
    calories_data?: Terra.CaloriesData;
    /** Cheat detection flag. */
    cheat_detection?: number;
    /** Object containing Terra Scores. */
    data_enrichment?: Terra.DataEnrichment;
    /** Object containing information on the device which recorded the specific workout. */
    device_data?: Terra.DeviceData;
    /** Object containing information related to distance covered during the associated workout. */
    distance_data?: Terra.DistanceData;
    /** Object containing information on the energy expended by the user during the workout. */
    energy_data?: Terra.EnergyData;
    /** Object containing heartrate-related information for the workout. */
    heart_rate_data?: Terra.HeartRateData;
    /** Object containing information on data for each lap performed by the user - mostly relates to track & field running activities, and swimming activities. */
    lap_data?: Terra.LapData;
    /** Object containing information on the Metabolic Equivalent of Task for the workout. */
    MET_data?: Terra.MetData;
    /** Object containing workout metadata. */
    metadata: Terra.ActivityMetadata;
    /** Object containing information on the user's movement throughout the workout. */
    movement_data?: Terra.MovementData;
    /** Object containing information on oxygen-related metrics for the workout. */
    oxygen_data?: Terra.OxygenData;
    /** Object containing polyline-representation map data, plotting the user's trajectory throughout the workout. */
    polyline_map_data?: Terra.PolylineMapData;
    /** Object containing information on the user's position throughout the workout. */
    position_data?: Terra.PositionData;
    /** Object containing information on the power generated by the user during the workout. */
    power_data?: Terra.PowerData;
    /** Object containing information on the cardiovascular strain imposed on the user during the workout. */
    strain_data?: Terra.StrainData;
    /** Object containing information on the stress put on the user's body from a workout. */
    TSS_data?: Terra.TssData;
    /** Object containing information on the work output of the user during the workout. */
    work_data?: Terra.WorkData;
}

```
</file>
<file path="terra-client-js/src/api/types/ActivityEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Activity data event
 */
export interface ActivityEvent {
    type: "activity";
    /** Array of activity data */
    data: Terra.Activity[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/ActivityLevel.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * User is engaged in vigorous physical activity such as running or intense exercise.
 */
export type ActivityLevel = number;

```
</file>
<file path="terra-client-js/src/api/types/ActivityLevelSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ActivityLevelSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    level?: Terra.ActivityLevel;
}

```
</file>
<file path="terra-client-js/src/api/types/ActivityMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ActivityMetadata {
    /** The City in which the workout was performed. */
    city?: string;
    /** The Country in which the workout was performed. */
    country?: string;
    /** The end time of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The name - either user-entered or given by the fitness data provider - of the associated workout. */
    name?: string;
    /** The start time of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    /** The State in which the workout was performed. */
    state?: string;
    /** A unique identifier for the workout - note that this is unique for the given user, and may not be globally unique. */
    summary_id: string;
    timestamp_localization?: Terra.TimestampLocalization;
    /** The type of activity performed for the associated workout. */
    type: Terra.Hurling;
    /** The upload type for the associated workout, providing information on whether this was an automatic workout or user-entered. */
    upload_type: Terra.UploadType;
}

```
</file>
<file path="terra-client-js/src/api/types/ActivityWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type ActivityWebhook = Terra.ActivityEvent;

```
</file>
<file path="terra-client-js/src/api/types/AsleepDurations.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AsleepDurations {
    /** Total duration for which the user was asleep, in any state. */
    duration_asleep_state_seconds?: number;
    /** Total duration for which the user was in a state of deep sleep. */
    duration_deep_sleep_state_seconds?: number;
    /** Total duration for which the user was in a state of light sleep. */
    duration_light_sleep_state_seconds?: number;
    /** Total duration for which the user was in a state of REM sleep. */
    duration_REM_sleep_state_seconds?: number;
    /** Number of periods of REM sleep captured during the sleep session. */
    num_REM_events?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/Athlete.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Athlete {
    /** User's age. */
    age?: number;
    /** User's country of residence. */
    country?: string;
    /** User's bio - a short description they display on their profile. */
    bio?: string;
    /** User's state of residence. */
    state?: string;
    /** User's last name. */
    last_name?: string;
    /** User's sex. */
    sex?: string;
    /** User's city of residence. */
    city?: string;
    /** User's email. */
    email?: string;
    /** User's date of birth, in ISO8601 format. */
    date_of_birth?: string;
    /** User's first name. */
    first_name?: string;
    /** User's gender. */
    gender?: string;
    /** User's account creation date. */
    joined_provider?: string;
    devices?: Terra.DeviceData[];
}

```
</file>
<file path="terra-client-js/src/api/types/AthleteCollection.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface AthleteCollection {
    /** Object containing the user's information */
    athlete?: Terra.Athlete;
    /** Terra User object */
    user?: Terra.TerraUser;
}

```
</file>
<file path="terra-client-js/src/api/types/AthleteEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Athlete data event
 */
export interface AthleteEvent {
    type: "athlete";
    /** Athlete data */
    athlete: Terra.Athlete;
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/AthleteWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type AthleteWebhook = Terra.AthleteEvent;

```
</file>
<file path="terra-client-js/src/api/types/AuthErrorEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Authentication error event
 */
export interface AuthErrorEvent extends Terra.AuthEvent {
    /** User who attempted to authenticate */
    user: Terra.TerraUser;
    /** Provider information */
    provider: string;
    /** Error message */
    message: string;
    /** Reason for the error */
    reason: string;
    /** Client-provided reference ID */
    reference_id: string;
    /** Widget session identifier */
    widget_session_id: string;
}

```
</file>
<file path="terra-client-js/src/api/types/AuthEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Authentication event
 */
export interface AuthEvent {
    type: "auth";
}

```
</file>
<file path="terra-client-js/src/api/types/AuthSuccessEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Authentication success event
 */
export interface AuthSuccessEvent extends Terra.AuthEvent {
    /** User who authenticated */
    user: Terra.TerraUser;
    /** Client-provided reference ID */
    reference_id: string;
    /** Widget session identifier */
    widget_session_id: string;
}

```
</file>
<file path="terra-client-js/src/api/types/AuthenticationFailedWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type AuthenticationFailedWebhook = Terra.AuthErrorEvent;

```
</file>
<file path="terra-client-js/src/api/types/AwakeDurations.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AwakeDurations {
    /** Total duration for which the user was awake during the sleep session. */
    duration_awake_state_seconds?: number;
    /** Total duration for which the user was awake during the sleep session, when the interruption of their sleep was greater than 90 seconds. */
    duration_long_interruption_seconds?: number;
    /** Total duration for which the user was awake during the sleep session, when the interruption of their sleep was less than 90 seconds. */
    duration_short_interruption_seconds?: number;
    /** Number of times the user got out of bed during the sleep session. */
    num_out_of_bed_events?: number;
    /** Number of times the user woke up during the sleep session. */
    num_wakeup_events?: number;
    /** Sleep latency, defined as time between the moment the user lays in bed with the intention to sleep and the moment they actually fall asleep. */
    sleep_latency_seconds?: number;
    /** Wake up latency, defined as time between the moment the user wakes up and the moment they get out of bed. */
    wake_up_latency_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/BadRequestErrorBody.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BadRequestErrorBody {
    /** a detailed message describing the error */
    message?: string;
    /** indicates that an error happened (value is error) */
    status?: "error";
}

```
</file>
<file path="terra-client-js/src/api/types/BloodPressureData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface BloodPressureData {
    /** List of Blood Pressure measurements sampled throughout the day. */
    blood_pressure_samples?: Terra.BloodPressureSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/BloodPressureSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BloodPressureSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's diastolic blood pressure, in mmHg */
    diastolic_bp?: number;
    /** User's systolic blood pressure, in mmHg */
    systolic_bp?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/Body.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Body {
    /** Object containing information on user's Blood Pressure. */
    blood_pressure_data?: Terra.BloodPressureData;
    /** Object containing information on the device which recorded data for the payload. */
    device_data?: Terra.DeviceData;
    /** Object containing information on user's heart metrics. */
    heart_data?: Terra.HeartData;
    /** Object containing information on user's hydration (both internal & consumption of water) for the day. */
    hydration_data?: Terra.HydrationData;
    /** Object containing information on user's ketone data for the day. */
    ketone_data?: Terra.KetoneData;
    /** Object containing information on body measurements for the day. */
    measurements_data?: Terra.MeasurementsData;
    /** Object containing daily summary metadata. */
    metadata: Terra.BodyMetadata;
    /** Object containing information on user's oxygen-related data. */
    oxygen_data?: Terra.OxygenData;
    /** Object containing temperature information (core, skin, ambient) during the day. */
    temperature_data?: Terra.TemperatureData;
    /** Object containing information on user's blood glucose for the day. */
    glucose_data?: Terra.GlucoseData;
}

```
</file>
<file path="terra-client-js/src/api/types/BodyBatterySample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BodyBatterySample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    level?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/BodyEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Body data event
 */
export interface BodyEvent {
    type: "body";
    /** Array of body data */
    data: Terra.Body[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/BodyMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface BodyMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
}

```
</file>
<file path="terra-client-js/src/api/types/BodyWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type BodyWebhook = Terra.BodyEvent;

```
</file>
<file path="terra-client-js/src/api/types/Breath.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Ketone sample taken from breath.
 */
export type Breath = number;

```
</file>
<file path="terra-client-js/src/api/types/BreathSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BreathSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    timestamp?: string;
    /** User's respiration rate */
    breaths_per_min?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/BreathsData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface BreathsData {
    /** Average breathing rate of the user during the sleep session. */
    avg_breaths_per_min?: number;
    /** Maximum breathing rate of the user during the sleep session. */
    max_breaths_per_min?: number;
    /** Minimum breathing rate of the user during the sleep session. */
    min_breaths_per_min?: number;
    /** Flag indicating if the reading was performed on demand, or if it was automatically captured by the device. */
    on_demand_reading?: boolean;
    /** List of breathing rate information sampled throughout the sleep session. */
    samples?: Terra.BreathSample[];
    /** The start time of the recording of breathing rate data, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time?: string;
    /** The end time of the recording of breathing rate data, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/CadencePlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CadencePlannedWorkoutStepTarget {
    /** Ideal cadence value to be maintained for the workout step */
    cadence?: number;
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: CadencePlannedWorkoutStepTarget.TargetType;
    /** Minimum cadence threshold for the workout step - i.e. the user is to stay above this value during the workout */
    cadence_low?: number;
    /** Maximum cadence threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    cadence_high?: number;
}

export namespace CadencePlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/CadenceSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CadenceSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    cadence_rpm?: number;
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/CalorieSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CalorieSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    calories?: number;
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/CaloriesData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface CaloriesData {
    BMR_calories?: number;
    calorie_samples?: Terra.CalorieSample[];
    net_activity_calories?: number;
    net_intake_calories?: number;
    total_burned_calories?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/CaloriesPlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CaloriesPlannedWorkoutStepDuration {
    /** Calorie burn target for the workout step - once the user reaches the target, the step will be completed */
    calories?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: CaloriesPlannedWorkoutStepDuration.DurationType;
}

export namespace CaloriesPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/CardioPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface CardioPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Name of exercise to be performed for the workout step */
    exercice_name?: string;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Type of exercise to be performed for the workout step */
    exercice_category?: CardioPlannedWorkoutStep.ExerciceCategory;
    /** Name of workout step */
    name?: string;
}

export namespace CardioPlannedWorkoutStep {
    /**
     * Type of exercise to be performed for the workout step
     */
    export type ExerciceCategory =
        | "UNKNOWN"
        | "BENCH_PRESS"
        | "CALF_RAISE"
        | "CARDIO"
        | "CARRY"
        | "CHOP"
        | "CORE"
        | "CRUNCH"
        | "CURL"
        | "DEADLIFT"
        | "FLYE"
        | "HIP_RAISE"
        | "HIP_STABILITY"
        | "HIP_SWING"
        | "HYPEREXTENSION"
        | "LATERAL_RAISE"
        | "LEG_CURL"
        | "LEG_RAISE"
        | "LUNGE"
        | "OLYMPIC_LIFT"
        | "PLANK"
        | "PLYO"
        | "PULL_UP"
        | "PUSH_UP"
        | "ROW"
        | "SHOULDER_PRESS"
        | "SHOULDER_STABILITY"
        | "SHRUG"
        | "SIT_UP"
        | "SQUAT"
        | "TOTAL_BODY"
        | "TRICEPS_EXTENSION"
        | "WARM_UP"
        | "RUN"
        | "BIKE"
        | "CARDIO_SENSORS";
    export const ExerciceCategory = {
        Unknown: "UNKNOWN",
        BenchPress: "BENCH_PRESS",
        CalfRaise: "CALF_RAISE",
        Cardio: "CARDIO",
        Carry: "CARRY",
        Chop: "CHOP",
        Core: "CORE",
        Crunch: "CRUNCH",
        Curl: "CURL",
        Deadlift: "DEADLIFT",
        Flye: "FLYE",
        HipRaise: "HIP_RAISE",
        HipStability: "HIP_STABILITY",
        HipSwing: "HIP_SWING",
        Hyperextension: "HYPEREXTENSION",
        LateralRaise: "LATERAL_RAISE",
        LegCurl: "LEG_CURL",
        LegRaise: "LEG_RAISE",
        Lunge: "LUNGE",
        OlympicLift: "OLYMPIC_LIFT",
        Plank: "PLANK",
        Plyo: "PLYO",
        PullUp: "PULL_UP",
        PushUp: "PUSH_UP",
        Row: "ROW",
        ShoulderPress: "SHOULDER_PRESS",
        ShoulderStability: "SHOULDER_STABILITY",
        Shrug: "SHRUG",
        SitUp: "SIT_UP",
        Squat: "SQUAT",
        TotalBody: "TOTAL_BODY",
        TricepsExtension: "TRICEPS_EXTENSION",
        WarmUp: "WARM_UP",
        Run: "RUN",
        Bike: "BIKE",
        CardioSensors: "CARDIO_SENSORS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/ConnectionErrorEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Connection error event
 */
export interface ConnectionErrorEvent {
    type: "connection_error";
    /** User with connection issues */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the connection issue */
    message: string;
}

```
</file>
<file path="terra-client-js/src/api/types/ConnectionErrorWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type ConnectionErrorWebhook = Terra.ConnectionErrorEvent;

```
</file>
<file path="terra-client-js/src/api/types/CyclingPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface CyclingPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/Daily.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Daily {
    /** Object containing information related to the time spent in different activity intensities during over the day. */
    active_durations_data?: Terra.ActiveDurationsData;
    /** Object containing calorie-related information for the user during the specific day. */
    calories_data?: Terra.CaloriesData;
    /** Object containing additional enrichment data for the day. */
    data_enrichment?: Terra.DailyDataEnrichment;
    /** Object containing information on the device which recorded data for the day. */
    device_data?: Terra.DeviceData;
    /** Object containing information related to distance covered during the associated day. */
    distance_data?: Terra.DailyDistanceData;
    /** Object containing heartrate-related information for the day. */
    heart_rate_data?: Terra.HeartRateData;
    /** Object containing information on the Metabolic Equivalent of Task for the day. */
    MET_data?: Terra.MetData;
    /** Object containing daily summary metadata. */
    metadata: Terra.DailyMetadata;
    /** Object containing information on oxygen-related metrics for the day. */
    oxygen_data?: Terra.OxygenData;
    /** Scores for the user's performance on different metrics for the given day, as calculated by the fitness data provider. */
    scores?: Terra.ScoresData;
    /** Object containing information on the strain put on the user's body over a day. */
    strain_data?: Terra.StrainData;
    /** Object containing information on the stress put on the user over a day. */
    stress_data?: Terra.StressData;
    /** Object containing all user-entered or automatically tagged events in the day. */
    tag_data?: Terra.TagData;
}

```
</file>
<file path="terra-client-js/src/api/types/DailyDataEnrichment.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DailyDataEnrichment {
    cardiovascular_contributors?: Terra.DataContributor[];
    cardiovascular_score?: number;
    immune_contributors?: Terra.DataContributor[];
    immune_index?: number;
    readiness_contributors?: Terra.DataContributor[];
    readiness_score?: number;
    respiratory_contributors?: Terra.DataContributor[];
    respiratory_score?: number;
    start_time?: string;
    stress_contributors?: Terra.DataContributor[];
    total_stress_score?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/DailyDistanceData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DailyDistanceData {
    /** Object containing detailed distance information - this may include second-by-second samples. */
    detailed?: Terra.DistanceDataDetailed;
    /** Total distance covered by the user throughout the day. */
    distance_meters?: number;
    /** Average elevation of the user throughout the day. */
    elevation?: Terra.ElevationData;
    /** Total number of elevation gain in floors climbed equivalent throughout the day, as determined by the fitness data provider. */
    floors_climbed?: number;
    /** Total number of steps performed during the day. */
    steps?: number;
    /** Summary information of the user's swimming statistics for the day, if applicable. */
    swimming?: Terra.SwimmingData;
}

```
</file>
<file path="terra-client-js/src/api/types/DailyEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Daily data event
 */
export interface DailyEvent {
    type: "daily";
    /** Array of daily data */
    data: Terra.Daily[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/DailyMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DailyMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
    /** The upload type for data in the associated day, providing information on whether data was automatically uploaded or user-entered. If any data point in a day is altered, the day should be classed as manual. */
    upload_type: Terra.UploadType;
}

```
</file>
<file path="terra-client-js/src/api/types/DailyPatternSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DailyPatternSample {
    /** Hour of the day, represented as an integer from 0 to 23, where 0 is midnight and 23 is the hour before the next midnight. */
    time_from_midnight?: number;
    /** Percentile 5 of the glucose level at the given time of day. */
    percentile_5?: number;
    /** Percentile 25 of the glucose level at the given time of day. */
    percentile_25?: number;
    /** Percentile 50 of the glucose level at the given time of day. */
    percentile_50?: number;
    /** Percentile 75 of the glucose level at the given time of day. */
    percentile_75?: number;
    /** Percentile 95 of the glucose level at the given time of day. */
    percentile_95?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/DailyWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type DailyWebhook = Terra.DailyEvent;

```
</file>
<file path="terra-client-js/src/api/types/DataContributor.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DataContributor {
    contributor_name: string;
    contributor_score: number;
}

```
</file>
<file path="terra-client-js/src/api/types/DataEnrichment.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DataEnrichment {
    /** User's stress score. */
    stress_score?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/DataProcessingWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type DataProcessingWebhook = Terra.ProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/types/DataSentToWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DataSentToWebhook {
    /** Payload reference, tying the request to the webhook payload which will be received */
    reference?: string;
    message?: string;
    /** Terra User object */
    user?: Terra.TerraUser;
}

```
</file>
<file path="terra-client-js/src/api/types/DeauthEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * User deauthentication event
 */
export interface DeauthEvent {
    type: "deauth";
    /** User who deauthenticated */
    user: Terra.TerraUser;
    /** Status of deauthentication */
    status: "success";
    /** Confirmation message */
    message: string;
}

```
</file>
<file path="terra-client-js/src/api/types/DeviceData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DeviceData {
    /** Activation timestamp of the device, if applicable. */
    activation_timestamp?: string;
    /** Data provided by the device, as enumerated types. */
    data_provided?: Terra.DeviceDataType[];
    /** Hardware version of the device. */
    hardware_version?: string;
    /** Last upload date from the device. */
    last_upload_date?: string;
    /** Device manufacturer name. */
    manufacturer?: string;
    /** Device name - note that this can also be the name of the application/package which the data comes from, if coming from a data aggregator such as Google Fit. */
    name?: string;
    /** Data pertaining to other devices which may have contributed data for this workout. */
    other_devices?: Terra.OtherDeviceData[];
    /** Sensor state of the device. */
    sensor_state?: string;
    /** Device Serial Number. */
    serial_number?: string;
    /** Device Software Version. */
    software_version?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/DeviceDataType.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents data types that a certain device contributed to.
 */
export type DeviceDataType =
    /**
     * Count of steps taken by the user. */
    | "STEPS"
    /**
     * Duration of time the user spent in physical activity. */
    | "ACTIVE_MINUTES"
    /**
     * User's basal metabolic rate - calories burned at rest. */
    | "BMR"
    /**
     * Calories burned by the user during activity. */
    | "CALORIES"
    /**
     * Distance traveled by the user during activity. */
    | "DISTANCE"
    /**
     * User's heart rate measurements. */
    | "HEART_RATE"
    /**
     * Blood oxygen saturation level (SpO2) of the user. */
    | "OXYGEN_SATURATION"
    /**
     * Classification of user's sleep stages or types. */
    | "SLEEP_TYPE"
    /**
     * User's movement speed during activity. */
    | "SPEED"
    /**
     * Rate of movement repetition during activity (steps per minute). */
    | "CADENCE";
export const DeviceDataType = {
    Steps: "STEPS",
    ActiveMinutes: "ACTIVE_MINUTES",
    Bmr: "BMR",
    Calories: "CALORIES",
    Distance: "DISTANCE",
    HeartRate: "HEART_RATE",
    OxygenSaturation: "OXYGEN_SATURATION",
    SleepType: "SLEEP_TYPE",
    Speed: "SPEED",
    Cadence: "CADENCE",
} as const;

```
</file>
<file path="terra-client-js/src/api/types/DistanceData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DistanceData {
    /** Object containing detailed distance information - this may included second-by-second samples. */
    detailed?: Terra.DistanceDataDetailed;
    /** Object containing summary information related to distance covered throughout the workout. */
    summary?: Terra.DistanceDataSummary;
}

```
</file>
<file path="terra-client-js/src/api/types/DistanceDataDetailed.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DistanceDataDetailed {
    /** Array of detailed samples of distance covered throughout the workout. */
    distance_samples?: Terra.DistanceSample[];
    /** Array of detailed samples of elevation throughout the workout. */
    elevation_samples?: Terra.ElevationSample[];
    /** Array of detailed samples of floors climbed throughout the workout, as determined by the fitness data provider. */
    floors_climbed_samples?: Terra.FloorsClimbedSample[];
    /** Array of detailed samples of steps performed throughout the workout. */
    step_samples?: Terra.StepSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/DistanceDataSummary.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DistanceDataSummary {
    /** Total distance covered by the user throughout the workout. */
    distance_meters?: number;
    /** Average elevation of the user throughout the workout. */
    elevation?: Terra.ElevationData;
    /** Total number of elevation gain in floors climbed equivalent throughout the workout, as determined by the fitness data provider. */
    floors_climbed?: number;
    /** Total number of steps performed during the workout. */
    steps?: number;
    /** Summary information of the user's swimming statistics for the workout, if applicable. */
    swimming?: Terra.SwimmingData;
}

```
</file>
<file path="terra-client-js/src/api/types/DistancePlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DistancePlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: DistancePlannedWorkoutStepDuration.DurationType;
    /** Target distance for the workout step - once the user covers this distance, the step will be completed */
    distance_meters?: number;
}

export namespace DistancePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/DistanceSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DistanceSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Cumulative distance covered up to associated timestamp, since the start of the payload */
    distance_meters?: number;
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/DrinkSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DrinkSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    timestamp?: string;
    /** Volume of drink consumed */
    drink_volume?: number;
    /** Unit of measurement for the drink */
    drink_unit?: string;
    /** Name of drink consumed. */
    drink_name?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/EcgReading.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface EcgReading {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_timestamp?: string;
    /** User's average heart rate throughout the day, in beats per minute (bpm). */
    avg_hr_bpm?: number;
    /** User's afib classification throught the day. */
    afib_classification?: Terra.Inconclusive;
    /** List of raw ECG readings sampled through the day. */
    raw_signal?: Terra.RawEcgSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/ElevationData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ElevationData {
    /** Average elevation of the user throughout the workout. */
    avg_meters?: number;
    /** Planned elevation gain for the workout. */
    gain_actual_meters?: number;
    /** Elevation gain of the user throughout the workout - this includes all elevation gain, and does _not_ represent net gain. */
    gain_planned_meters?: number;
    /** Elevation loss of the user throughout the workout. */
    loss_actual_meters?: number;
    /** Maximum elevation of the user during the workout. */
    max_meters?: number;
    /** Minimum elevation of the user during the workout. */
    min_meters?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/ElevationSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ElevationSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's altitude at a given point in time, in meters above sea level. */
    elev_meters?: number;
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/EnergyData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface EnergyData {
    /** Total number of kiloJoules planned to be expended during the workout - represents the user's predefined goal for the workout */
    energy_kilojoules?: number;
    /** Total number of kiloJoules expended during the workout */
    energy_planned_kilojoules?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/FixedRestPlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FixedRestPlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: FixedRestPlannedWorkoutStepDuration.DurationType;
    /** Time duration to be elapsed for the rest period */
    rest_seconds?: number;
}

export namespace FixedRestPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/FloorsClimbedSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FloorsClimbedSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Cumulative number of elevation gain measured in floors climbed up to associated timestamp, since the start of the payload */
    floors_climbed?: number;
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/GlucoseData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface GlucoseData {
    /** List of blood glucose readings sampled throughout the day. */
    blood_glucose_samples?: Terra.GlucoseDataSample[];
    /** List of blood glucose readings sampled throughout the day - this represents additional data points, potentially at higher frequency from the ones in blood_glucose_samples, which may come at a cost of reduced accuracy. */
    detailed_blood_glucose_samples?: Terra.GlucoseDataSample[];
    /** User's average glucose level throughout the day. */
    day_avg_blood_glucose_mg_per_dL?: number;
    /** GMI (Glucose Management Indicator) is a metric derived from continuous glucose monitoring (CGM) data that estimates average glucose levels to help guide diabetes management, without implying a precise match to laboratory A1C. */
    gmi?: number;
    /** Time that the user's glucose is within acceptable range (not hyper or hypoglycemic). */
    time_in_range?: number;
    /** Number of data points recorded by the sensor throughout the day. */
    sensor_usage?: number;
    /** List of glucose percentile samples throughout the day. */
    daily_patterns?: Terra.DailyPatternSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/GlucoseDataSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface GlucoseDataSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's blood glucose reading */
    blood_glucose_mg_per_dL?: number;
    /** Flag indicating state of user's blood glucose level */
    glucose_level_flag?: Terra.Low;
    /** Flag indicating the current trend in the user's blood glucose level (e.g. rising, constant, falling) */
    trend_arrow?: Terra.TrendArrow;
}

```
</file>
<file path="terra-client-js/src/api/types/GoogleNoDataSourceWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type GoogleNoDataSourceWebhook = Terra.GoogleNoDatasourceEvent;

```
</file>
<file path="terra-client-js/src/api/types/GoogleNoDatasourceEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Google no datasource event
 */
export interface GoogleNoDatasourceEvent {
    type: "google_no_datasource";
    /** Affected user */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the issue */
    message: string;
}

```
</file>
<file path="terra-client-js/src/api/types/Had.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Menstrual flow occurred but intensity not specified.
 */
export type Had = number;

```
</file>
<file path="terra-client-js/src/api/types/HealthCheckWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type HealthCheckWebhook = Terra.HealthcheckEvent;

```
</file>
<file path="terra-client-js/src/api/types/HealthcheckEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Healthcheck event sent periodically to verify your webhook endpoint is functional
 */
export interface HealthcheckEvent {
    type: "healthcheck";
    /** Timestamp when the event was created */
    creation_timestamp: string;
    /** Percentage change in trends */
    trend_percentage: number;
    /** Number of webhooks sent in the last hour */
    sent_webhooks_last_hour: number;
}

```
</file>
<file path="terra-client-js/src/api/types/HeartData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartData {
    /** List of Atrial Fibrillation classification measurements sampled through the day. */
    afib_classification_samples?: Terra.AFibClassificationSample[];
    /** List of ECGReadings sampled through the day. */
    ecg_signal?: Terra.EcgReading[];
    /** Object containing heart rate data. */
    heart_rate_data?: Terra.HeartRateData;
    /** List of Pulse Wave Velocity measurements sampled throughout the day. This represents a measurement of arterial stiffness that is an independent predictor of cardiovascular risk. */
    pulse_wave_velocity_samples?: Terra.PulseVelocitySample[];
    /** List of RR Interval samples throughout the day. */
    rr_interval_samples?: Terra.RrIntervalSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateContext.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Heart rate was measured during rest or non-active periods.
 */
export type HeartRateContext = number;

```
</file>
<file path="terra-client-js/src/api/types/HeartRateData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateData {
    /** Object containing detailed heart rate information for the associated workout. */
    detailed?: Terra.HeartRateDataDetailed;
    /** Object containing summary heart rate information for the associated workout. */
    summary?: Terra.HeartRateDataSummary;
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateDataDetailed.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateDataDetailed {
    /** Array of HeartRate data samples recorded for the user during the workout. */
    hr_samples?: Terra.HeartRateDataSample[];
    /** Array of HeartRate Variability data samples recorded for the user during the workout, computed using RMSSD. */
    hrv_samples_rmssd?: Terra.HeartRateVariabilityDataSampleRmssd[];
    /** Array of HeartRate Variability data samples recorded for the user during the workout, computed using SDNN. */
    hrv_samples_sdnn?: Terra.HeartRateVariabilityDataSampleSdnn[];
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateDataSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateDataSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's heart rate in bpm */
    bpm?: number;
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
    /** Represents the context in which heart rate was measured. */
    context?: Terra.HeartRateContext;
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateDataSummary.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateDataSummary {
    /** Average HeartRate of the user during the workout. */
    avg_hr_bpm?: number;
    /** Average HeartRate Variability of the user during the workout, computed using RMSSD. */
    avg_hrv_rmssd?: number;
    /** Average HeartRate Variability of the user during the workout, computed using SDNN. */
    avg_hrv_sdnn?: number;
    /** Array of time spent in various HR zones throughout the workout. */
    hr_zone_data?: Terra.HeartRateZoneData[];
    /** Maximum HeartRate of the user during the workout. */
    max_hr_bpm?: number;
    /** Minimum HeartRate of the user during the workout. */
    min_hr_bpm?: number;
    /** Resting HeartRate of the user, as determined by the fitness data provider. */
    resting_hr_bpm?: number;
    /** User's maximum HeartRate based on their age, and other factors as determined by the fitness data provider. */
    user_max_hr_bpm?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateVariabilityDataSampleRmssd.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HeartRateVariabilityDataSampleRmssd {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's Heart Rate Variability, computed using RMSSD */
    hrv_rmssd?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateVariabilityDataSampleSdnn.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HeartRateVariabilityDataSampleSdnn {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's Heart Rate Variability, computed using SDNN */
    hrv_sdnn?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/HeartRateZoneData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateZoneData {
    /** Heart rate zone designation */
    zone?: Terra.Other;
    /** Start percentage (based off user's max HR) of the HR zone */
    start_percentage?: number;
    /** End percentage (based off user's max HR) of the HR zone */
    end_percentage?: number;
    /** Name of the associated heart rate zone */
    name?: string;
    /** Duration spent in the heart rate zone */
    duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/High.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * High stress level (range 76-100).
 */
export type High = number;

```
</file>
<file path="terra-client-js/src/api/types/HrAbovePlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HrAbovePlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: HrAbovePlannedWorkoutStepDuration.DurationType;
    /** Threshold heart rate goal to complete the workout step - once the user's heart rate reaches above below this value, the step will be completed */
    hr_above_bpm?: number;
}

export namespace HrAbovePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/HrBelowPlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HrBelowPlannedWorkoutStepDuration {
    /** Threshold heart rate goal to complete the workout step - once the user's heart rate reaches below this value, the step will be completed */
    hr_below_bpm?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: HrBelowPlannedWorkoutStepDuration.DurationType;
}

export namespace HrBelowPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/HrPlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HrPlannedWorkoutStepTarget {
    /** Maximum max heart rate percentage threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    hr_percentage_low?: number;
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: HrPlannedWorkoutStepTarget.TargetType;
    /** Minimum heart rate percentage threshold for the workout step - i.e. the user is to stay above this value during the workout */
    hr_percentage_high?: number;
    /** Ideal percentage of user's maximum HR to be maintained workout step */
    hr_percentage?: number;
    /** Maximum heart rate threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    hr_bpm_high?: number;
    /** Minimum heart rate threshold for the workout step - i.e. the user is to stay above this value during the workout */
    hr_bpm_low?: number;
}

export namespace HrPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/Hurling.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Activity type for playing hurling.
 */
export type Hurling = number;

```
</file>
<file path="terra-client-js/src/api/types/HydrationData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HydrationData {
    /** User's total water consumption throughout the day. */
    day_total_water_consumption_ml?: number;
    /** User's hydration level samples throughout the day. */
    hydration_amount_samples?: Terra.HydrationMeasurementSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/HydrationMeasurementSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HydrationMeasurementSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Total body water composition of the user, in kilograms. */
    hydration_kg?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/IfPlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface IfPlannedWorkoutStepTarget {
    /** Maximum Intensity Factor to be achieved for the workout step */
    if_high?: number;
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: IfPlannedWorkoutStepTarget.TargetType;
    /** Minimum Intensity Factor to be achieved for the workout step */
    if_low?: number;
}

export namespace IfPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/Inconclusive.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * The heart rhythm analysis couldn't determine whether AFib was present or absent.
 */
export type Inconclusive = number;

```
</file>
<file path="terra-client-js/src/api/types/Indeterminate.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * The sleep data upload type cannot be clearly categorized.
 */
export type Indeterminate = number;

```
</file>
<file path="terra-client-js/src/api/types/IntegrationProvider.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface IntegrationProvider {
    /** Identifier for the provider */
    provider?: string;
    /** Display name of the integration */
    name?: string;
    /** URL for the provider's icon image */
    icon?: string;
    /** Indicates how the integration is set up */
    setup?: string;
    /** Whether the integration is enabled */
    enabled?: boolean;
    /** Indicates the types of data available through the provider */
    types?: IntegrationProvider.Types;
}

export namespace IntegrationProvider {
    /**
     * Indicates the types of data available through the provider
     */
    export interface Types {
        activity?: boolean;
        body?: boolean;
        nutrition?: boolean;
        daily?: boolean;
        sleep?: boolean;
        menstruation?: boolean;
    }
}

```
</file>
<file path="terra-client-js/src/api/types/IntegrationsResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface IntegrationsResponse {
    /** Status of the API response */
    status?: string;
    /** List of integration providers with their details */
    providers?: Terra.IntegrationProvider[];
}

```
</file>
<file path="terra-client-js/src/api/types/KetoneData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface KetoneData {
    /** List of ketone data sampled through the day. */
    ketone_samples?: Terra.KetoneSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/KetoneSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface KetoneSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Ketone in mg per dL */
    ketone_mg_per_dL?: number;
    /** Flag indicating the ketone sample type (e.g. blood, breath, urine) */
    sample_type?: Terra.Breath;
}

```
</file>
<file path="terra-client-js/src/api/types/LapData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface LapData {
    /** Array of datapoints for each lap performed by the user during the workout. */
    laps?: Terra.LapSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/LapSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface LapSample {
    /** Calories burned during the lap */
    calories?: number;
    /** Average heart rate in bpm, for the Lap sample */
    avg_hr_bpm?: number;
    /** The start time of the associated lap, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    start_time?: string;
    /** Average speed of the user during the lap */
    avg_speed_meters_per_second?: number;
    /** Distance covered during the lap */
    distance_meters?: number;
    /** Total strokes performed during the lap - only relevant for swimming activities */
    total_strokes?: number;
    /** The end time of the associated lap, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    end_time?: string;
    /** Stroke type - only relevant for swimming activities */
    stroke_type?: Terra.StrokeType;
}

```
</file>
<file path="terra-client-js/src/api/types/LargeRequestProcessingEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Large request processing event
 */
export interface LargeRequestProcessingEvent {
    type: "large_request_processing";
    /** Status of the processing */
    status: "processing";
    /** Information about the processing */
    message: string;
    /** User whose data is being processed */
    user: Terra.TerraUser;
    /** Reference ID for tracking this request */
    reference: string;
}

```
</file>
<file path="terra-client-js/src/api/types/LargeRequestProcessingResponse.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type LargeRequestProcessingResponse = Terra.LargeRequestProcessingEvent;

```
</file>
<file path="terra-client-js/src/api/types/LargeRequestSendingEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Large request sending event
 */
export interface LargeRequestSendingEvent {
    type: "large_request_sending";
    /** User whose data is being sent */
    user: Terra.TerraUser;
    /** Reference ID for tracking this request */
    reference: string;
    /** Information about the request */
    message: string;
    /** Number of expected payload events */
    expected_payloads: number;
}

```
</file>
<file path="terra-client-js/src/api/types/LargeRequestSendingWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type LargeRequestSendingWebhook = Terra.LargeRequestSendingEvent;

```
</file>
<file path="terra-client-js/src/api/types/Low.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Blood glucose level is below the normal range (hypoglycemia).
 */
export type Low = number;

```
</file>
<file path="terra-client-js/src/api/types/Meal.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Meal {
    /** Micronutrient information for associated food. */
    micros: Terra.NutritionMicros;
    /** Enum representing the category the consumed food/meal falls under (i.e. Breakfast/Lunch/Dinner etc). */
    type: Terra.Snack;
    /** Identifier for food logged by the user. */
    id: string;
    /** Timestamp the food is associated with, in ISO8601 format, with microsecond precision. */
    timestamp: string;
    /** Quantity of the food that was consumed, containing information on amount & units in which this was recorded. */
    quantity: Terra.NutritionQuantity;
    /** Name of food logged by the user. */
    name: string;
    /** Macronutrient information for associated food. */
    macros: Terra.NutritionMacros;
}

```
</file>
<file path="terra-client-js/src/api/types/MeasurementDataSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MeasurementDataSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    measurement_time?: string;
    /** User's Body Mass Index (BMI). */
    BMI?: number;
    /** User's Basal Metabolic Rate - minimum amount of calories that a person's body needs to perform necessary functions. */
    BMR?: number;
    /** User's Resting Metabolic Rate - amount of energy that a person's body needs to function while at rest. RMR accounts for additional low-effort daily activities on top of basic body functions. */
    RMR?: number;
    /** Estimate of how fit the user is compared to their actual age, as measured by the device. */
    estimated_fitness_age?: string;
    /** User's skin fold measurement. */
    skin_fold_mm?: number;
    /** User's body fat percentage. */
    bodyfat_percentage?: number;
    /** User's body weight. */
    weight_kg?: number;
    /** User's height. */
    height_cm?: number;
    /** User's total bone mass. */
    bone_mass_g?: number;
    /** User's total muscle mass (i.e. skeletal muscle mass). */
    muscle_mass_g?: number;
    /** Total lean mass of the user - calculated as the difference between total body weight and body fat weight. */
    lean_mass_g?: number;
    /** Total amount of fluid in the user's body. */
    water_percentage?: number;
    /** Quantity of insulin administered to the user. */
    insulin_units?: number;
    /** Type of insulin administered to the user. */
    insulin_type?: string;
    /** Color of the user's urine. */
    urine_color?: string;
    /** User notes associated with the measurement. */
    user_notes?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/MeasurementsData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MeasurementsData {
    /** List of body metrics & measurements taken throughout the associated day. */
    measurements?: Terra.MeasurementDataSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/MenstrualPhase.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents menstrual cycle phases.
 */
export type MenstrualPhase =
    /**
     * The menstrual phase when bleeding occurs. */
    | "menstrual"
    /**
     * The follicular phase when follicles in ovaries develop. */
    | "follicular"
    /**
     * The ovulation phase when an egg is released. */
    | "ovulation"
    /**
     * The luteal phase following ovulation. */
    | "luteal"
    /**
     * Premenstrual syndrome phase before menstruation begins. */
    | "pms"
    /**
     * The fertile window when conception is most likely. */
    | "fertile"
    /**
     * First third of pregnancy, weeks 1-12. */
    | "first_trimester"
    /**
     * Middle third of pregnancy, weeks 13-26. */
    | "second_trimester"
    /**
     * Final third of pregnancy, weeks 27-40. */
    | "third_trimester"
    /**
     * Menstrual cycle phase could not be determined. */
    | "unknown";
export const MenstrualPhase = {
    Menstrual: "menstrual",
    Follicular: "follicular",
    Ovulation: "ovulation",
    Luteal: "luteal",
    Pms: "pms",
    Fertile: "fertile",
    FirstTrimester: "first_trimester",
    SecondTrimester: "second_trimester",
    ThirdTrimester: "third_trimester",
    Unknown: "unknown",
} as const;

```
</file>
<file path="terra-client-js/src/api/types/Menstruation.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Menstruation {
    /** Object containing daily summary metadata. */
    metadata: Terra.MenstruationMetadata;
    /** Object containing information on user's menstruation for a given day. */
    menstruation_data?: Terra.MenstruationData;
}

```
</file>
<file path="terra-client-js/src/api/types/MenstruationData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MenstruationData {
    /** Total length of period (i.e. menstrual bleeding). */
    period_length_days?: number;
    /** Phase in associated cycle, (i.e. menstruation, fertile etc). */
    current_phase?: Terra.MenstrualPhase;
    /** Length of current phase. */
    length_of_current_phase_days?: number;
    /** Number of days to reach the next phase (predicted). */
    days_until_next_phase?: number;
    /** Start date of menstrual cycle, in ISO8601 format. */
    period_start_date?: string;
    /** Prediction of the cycle's total length. */
    predicted_cycle_length_days?: number;
    /** Number of day in cycle this object is associated with. */
    day_in_cycle?: number;
    /** Last time when the user recorded information regarding their cycle, in ISO8601 format, with microseconds precision. */
    last_updated_time?: string;
    /** Total cycle length. */
    cycle_length_days?: string;
    /** Flag indicating whether associated object is a prediction or user-logged information. */
    is_predicted_cycle?: string;
    /** List of user logs of information related to the strength of user's menstrual flow. */
    menstruation_flow?: Terra.MenstruationFlowSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/MenstruationEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Menstruation data event
 */
export interface MenstruationEvent {
    type: "menstruation";
    /** Array of menstruation data */
    data: Terra.Menstruation[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/MenstruationFlowSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MenstruationFlowSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Flag indicating the strength of the user's menstrual flow. */
    flow?: Terra.Had;
}

```
</file>
<file path="terra-client-js/src/api/types/MenstruationMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MenstruationMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
}

```
</file>
<file path="terra-client-js/src/api/types/MenstruationWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type MenstruationWebhook = Terra.MenstruationEvent;

```
</file>
<file path="terra-client-js/src/api/types/MetData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MetData {
    /** An array of Metabolic Equivalent Time samples, as calculated by the user's wearable. */
    MET_samples?: Terra.MetSample[];
    /** The average MET level of the activity. */
    avg_level?: number;
    /** Number of minutes spent in High Intensity during the workout - based off MET scale. */
    num_high_intensity_minutes?: number;
    /** Number of minutes spent in state of Inactivity during the workout - based off MET scale. */
    num_inactive_minutes?: number;
    /** Number of minutes spent in Low Intensity during the workout - based off MET scale. */
    num_low_intensity_minutes?: number;
    /** Number of minutes spent in Moderate Intensity during the workout - based off MET scale. */
    num_moderate_intensity_minutes?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/MetSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MetSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    level?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/MovementData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MovementData {
    /** Adjusted max speed of the user during the workout - generated using Terra's algorithms to remove potential affecting the user's actual max speed measurement. */
    adjusted_max_speed_meters_per_second?: number;
    /** Average cadence of the user during the workout, in RPM. */
    avg_cadence_rpm?: number;
    /** Average pace of the user during the workout. */
    avg_pace_minutes_per_kilometer?: number;
    /** Average speed of the user during the workout. */
    avg_speed_meters_per_second?: number;
    /** Average torque generated by the user during the workout - mainly relevant for cycling activities. */
    avg_torque_newton_meters?: number;
    /** Average velocity of the user during the workout - only calculated by certain providers, representing a separate quantity from speed. */
    avg_velocity_meters_per_second?: number;
    /** Array of cadence values recorded throughout the workout, sampled at intervals determined by the fitness data provider. */
    cadence_samples?: Terra.CadenceSample[];
    /** Maximum cadence of the user during the workout - mainly relevant for cycling activities. */
    max_cadence_rpm?: number;
    /** Maximum pace of the user during the workout. */
    max_pace_minutes_per_kilometer?: number;
    /** Maximum speed of the user during the workout. */
    max_speed_meters_per_second?: number;
    /** Maximum torque generated by the user during the workout - mainly relevant for cycling activities. */
    max_torque_newton_meters?: number;
    /** Maximum velocity of the user during the workout - only calculated by certain providers, representing a separate quantity from speed. */
    max_velocity_meters_per_second?: number;
    /** Average normalized speed of the user during the workout - only calculated by certain providers, representing a separate quantity from speed. */
    normalized_speed_meters_per_second?: number;
    /** Array of the datapoints for the user's speed sampled throughout the workout. */
    speed_samples?: Terra.SpeedSample[];
    /** Array of the datapoints for the user's torque sampled throughout the workout. */
    torque_samples?: Terra.TorqueSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/Muscle.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Oxygen saturation measurement for muscle.
 */
export type Muscle = number;

```
</file>
<file path="terra-client-js/src/api/types/NoDataReturned.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NoDataReturned {
    status?: NoDataReturned.Status;
    message?: string;
    /** Terra User object */
    user?: Terra.TerraUser;
}

export namespace NoDataReturned {
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/NotFoundErrorBody.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NotFoundErrorBody {
    /** a detailed message describing the error */
    message?: string;
    /** indicates that an error happened (value is error) */
    status?: "error";
}

```
</file>
<file path="terra-client-js/src/api/types/Nutrition.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Nutrition {
    /** Information on drinks the user consumed throughout the day. */
    drink_samples?: Terra.DrinkSample[];
    /** Information on individual foods consumed throughout a given day. */
    meals?: Terra.Meal[];
    /** Object containing daily summary metadata. */
    metadata: Terra.NutritionMetadata;
    /** Summative nutritional information for a given day. */
    summary?: Terra.NutritionSummary;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Nutrition data event
 */
export interface NutritionEvent {
    type: "nutrition";
    /** Array of nutrition data */
    data: Terra.Nutrition[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionMacros.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NutritionMacros {
    /** Alcohol content of the associated food(s). */
    alcohol_g?: number;
    /** Calorie content of the associated food(s). */
    calories?: number;
    /** Carbohydrates content of the associated food(s). */
    carbohydrates_g?: number;
    /** Cholesterol content of the associated food(s). */
    cholesterol_mg?: number;
    /** Fat content of the associated food(s). */
    fat_g?: number;
    /** Fiber content of the associated food(s). */
    fiber_g?: number;
    /** Net carbs content of the associated food(s). */
    net_carbohydrates_g?: number;
    /** Protein content of the associated food(s). */
    protein_g?: number;
    /** Saturated fat content of the associated food(s). */
    saturated_fat_g?: number;
    /** Sodium content of the associated food(s). */
    sodium_mg?: number;
    /** Sugar content of the associated food(s). */
    sugar_g?: number;
    /** Trans fat content of the associated food(s). */
    trans_fat_g?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NutritionMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionMicros.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NutritionMicros {
    /** Biotin content of the associated food(s). */
    biotin_mg?: number;
    /** Caffeine content of the associated food(s). */
    caffeine_mg?: number;
    /** Calcium content of the associated food(s). */
    calcium_mg?: number;
    /** Chloride content of the associated food(s). */
    chloride_mg?: number;
    /** Chromium content of the associated food(s). */
    chromium_mg?: number;
    /** Copper content of the associated food(s). */
    copper_mg?: number;
    /** Folate content of the associated food(s). */
    folate_mg?: number;
    /** Folic Acid content of the associated food(s). */
    folic_acid_mg?: number;
    /** Iodine content of the associated food(s). */
    iodine_mg?: number;
    /** Iron content of the associated food(s). */
    iron_mg?: number;
    /** Magnesium content of the associated food(s). */
    magnesium_mg?: number;
    /** Manganese content of the associated food(s). */
    manganese_mg?: number;
    /** Molybdenum content of the associated food(s). */
    molybdenum_mg?: number;
    /** Niacin content of the associated food(s). */
    niacin_mg?: number;
    /** Pantothenic content of the associated food(s). */
    pantothenic_acid_mg?: number;
    /** Phosphorus content of the associated food(s). */
    phosphorus_mg?: number;
    /** Potassium content of the associated food(s). */
    potassium_mg?: number;
    /** Riboflavin content of the associated food(s). */
    riboflavin_mg?: number;
    /** Selenium content of the associated food(s). */
    selenium_mg?: number;
    /** Thiamin content of the associated food(s). */
    thiamin_mg?: number;
    /** Vitamin A content of the associated food(s). */
    vitamin_A_mg?: number;
    /** Vitamin B12 content of the associated food(s). */
    vitamin_B12_mg?: number;
    /** Vitamin B6 content of the associated food(s). */
    vitamin_B6_mg?: number;
    /** Vitamin C content of the associated food(s). */
    vitamin_C_mg?: number;
    /** Vitamin D content of the associated food(s). */
    vitamin_D_mg?: number;
    /** Vitamin D2 content of the associated food(s). */
    vitamin_D2_mg?: number;
    /** Vitamin D3 content of the associated food(s). */
    vitamin_D3_mg?: number;
    /** Vitamin E content of the associated food(s). */
    vitamin_E_mg?: number;
    /** Vitamin K content of the associated food(s). */
    vitamin_K_mg?: number;
    /** Zinc content of the associated food(s). */
    zinc_mg?: number;
    /** Cystine content of the associated food(s). */
    cystine_g?: number;
    /** Histidine content of the associated food(s). */
    histidine_g?: number;
    /** Isoleucine content of the associated food(s). */
    isoleucine_g?: number;
    /** Leucine content of the associated food(s). */
    leucine_g?: number;
    /** Lysine content of the associated food(s). */
    lysine_g?: number;
    /** Methionine content of the associated food(s). */
    methionine_g?: number;
    /** Phenylalanine content of the associated food(s). */
    phenylalanine_g?: number;
    /** Threonine content of the associated food(s). */
    threonine_g?: number;
    /** Tryptophan content of the associated food(s). */
    tryptophan_g?: number;
    /** Tyrosine content of the associated food(s). */
    tyrosine_g?: number;
    /** Valine content of the associated food(s). */
    valine_g?: number;
    /** Monounsaturated fat content of the associated food(s). */
    monounsaturated_fat_g?: number;
    /** Polyunsaturated fat content of the associated food(s). */
    polyunsaturated_fat_g?: number;
    /** Omega3 content of the associated food(s). */
    omega3_g?: number;
    /** Omega6 content of the associated food(s). */
    omega6_g?: number;
    /** Starch content of the associated food(s). */
    starch_g?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionQuantity.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NutritionQuantity {
    unit: Terra.NutritionUnits;
    amount: number;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionSummary.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NutritionSummary {
    /** Summary of macronutrient information for a given day. */
    macros?: Terra.NutritionMacros;
    /** Summary of micronutrient information for a given day. */
    micros?: Terra.NutritionMicros;
    /** Water consumption of the user for a given day. */
    water_ml?: number;
    /** Non-water drink consumption of the user for a given day. */
    drink_ml?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/NutritionUnits.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Measurement in fluid ounces, approximately 30 milliliters.
 */
export type NutritionUnits = number;

```
</file>
<file path="terra-client-js/src/api/types/NutritionWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type NutritionWebhook = Terra.NutritionEvent;

```
</file>
<file path="terra-client-js/src/api/types/Other.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Heart rate zone that doesn't fit into the standard zones or couldn't be classified.
 */
export type Other = number;

```
</file>
<file path="terra-client-js/src/api/types/OtherDeviceData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OtherDeviceData {
    /** Device manufacturer name. */
    manufacturer?: string;
    /** Hardware version of the device. */
    hardware_version?: string;
    /** Device Serial Number. */
    serial_number?: string;
    /** Device name - note that this can also be the name of the application/package which the data comes from, if coming from a data aggregator such as Google Fit. */
    name?: string;
    /** Device Software Version. */
    software_version?: string;
    activation_timestamp?: string;
    data_provided?: Terra.DeviceDataType[];
    last_upload_date?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/OtherSleepDurations.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface OtherSleepDurations {
    /** Total duration of time spent in bed. */
    duration_in_bed_seconds?: number;
    /** Total duration during which the user's state (awake, asleep, REM, etc) was unmeasurable during the sleep session. */
    duration_unmeasurable_sleep_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/OxygenData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OxygenData {
    /** Average Oxygen Saturation percentage of the user during the day (SpO2 or SmO2). */
    avg_saturation_percentage?: number;
    /** Array of Oxygen Saturation percentage datapoints sampled throughout the day. */
    saturation_samples?: Terra.OxygenSaturationSample[];
    /** Array of VO2 datapoints sampled throughout the day. */
    vo2_samples?: Terra.Vo2MaxSample[];
    /** VO2Max for the given user. */
    vo2max_ml_per_min_per_kg?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/OxygenSaturationData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OxygenSaturationData {
    /** Average Oxygen Saturation percentage of the user during the sleep session. */
    avg_saturation_percentage?: number;
    /** The end time of the recording of oxygen saturation, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time?: string;
    /** Array of Oxygen Saturation percentage datapoints sampled throughout the sleep session. */
    samples?: Terra.OxygenSaturationSample[];
    /** The start time of the recording of oxygen saturation, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/OxygenSaturationSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OxygenSaturationSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's oxygen saturation percentage - referring to either SpO2 or SmO2, based on the `type` field */
    percentage?: number;
    /** Type of oxygen saturation measurement (i.e. blood vs muscle) */
    type?: Terra.Muscle;
}

```
</file>
<file path="terra-client-js/src/api/types/PacePlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PacePlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: PacePlannedWorkoutStepTarget.TargetType;
    /** Ideal pace value to be maintained for the workout step */
    pace_minutes_per_kilometer?: number;
}

export namespace PacePlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PermissionChangeEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Permission change event
 */
export interface PermissionChangeEvent {
    type: "permission_change";
    /** User who changed permissions */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the permission change */
    message: string;
    /** API version */
    version: string;
    /** Newly added scopes */
    scopes_added: string;
    /** Removed scopes */
    scopes_removed: string;
}

```
</file>
<file path="terra-client-js/src/api/types/PermissionChangeWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PermissionChangeWebhook = Terra.PermissionChangeEvent;

```
</file>
<file path="terra-client-js/src/api/types/PilatesPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PilatesPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkout.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PlannedWorkout {
    /** List of exercises/steps/intervals for the workout plan */
    steps?: Terra.PlannedWorkoutSteps[];
    /** Metadata for the workout plan */
    metadata?: Terra.PlannedWorkoutMetadata;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PlannedWorkoutMetadata {
    /** Estimated energy expenditure for the workout */
    estimated_energy_kj?: number;
    /** Estimated speed for the workout */
    estimated_speed_meters_per_second?: number;
    /** Estimated elevation gain for the workout */
    estimated_elevation_gain_meters?: number;
    /** Estimated Training Stress Score for the workout */
    estimated_tss?: number;
    /** Estimated calorie burn for the workout */
    estimated_calories?: number;
    /** The creation datetime of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    created_date?: string;
    /** The planned start datetime, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    planned_date?: string;
    /** The name - either user-entered or given by the fitness data provider - of the associated workout plan */
    type?: PlannedWorkoutMetadata.Type;
    id?: string;
    /** Estimated workout duration */
    estimated_duration_seconds?: number;
    /** Estimated pace for the workout */
    estimated_pace_minutes_per_kilometer?: number;
    /** Name of the original source of the workout plan */
    provider?: string;
    /** */
    estimated_tscore?: number;
    /** Description of the workout */
    description?: string;
    /** Name of the workout plan */
    name?: string;
    /** Estimated distance for the workout */
    estimated_distance_meters?: number;
    /** Estimated Intensity Factor for the workout */
    estimated_if?: number;
    /** Pool length of the pool used for the workout - only relevant for swimming activity types */
    pool_length_meters?: number;
}

export namespace PlannedWorkoutMetadata {
    /**
     * The name - either user-entered or given by the fitness data provider - of the associated workout plan
     */
    export type Type =
        | "IN_VEHICLE"
        | "BIKING"
        | "STILL"
        | "UNKNOWN"
        | "TILTING"
        | "WALKING"
        | "RUNNING"
        | "AEROBICS"
        | "BADMINTON"
        | "BASEBALL"
        | "BASKETBALL"
        | "BIATHLON"
        | "HANDBIKING"
        | "MOUNTAIN_BIKING"
        | "ROAD_BIKING"
        | "SPINNING"
        | "STATIONARY_BIKING"
        | "UTILITY_BIKING"
        | "BOXING"
        | "CALISTHENICS"
        | "CIRCUIT_TRAINING"
        | "CRICKET"
        | "DANCING"
        | "ELLIPTICAL"
        | "FENCING"
        | "AMERICAN_FOOTBALL"
        | "AUSTRALIAN_FOOTBALL"
        | "ENGLISH_FOOTBALL"
        | "FRISBEE"
        | "GARDENING"
        | "GOLF"
        | "GYMNASTICS"
        | "HANDBALL"
        | "HIKING"
        | "HOCKEY"
        | "HORSEBACK_RIDING"
        | "HOUSEWORK"
        | "JUMPING_ROPE"
        | "KAYAKING"
        | "KETTLEBELL_TRAINING"
        | "KICKBOXING"
        | "KITESURFING"
        | "MARTIAL_ARTS"
        | "MEDITATION"
        | "MIXED_MARTIAL_ARTS"
        | "P90X_EXERCISES"
        | "PARAGLIDING"
        | "PILATES"
        | "POLO"
        | "RACQUETBALL"
        | "ROCK_CLIMBING"
        | "ROWING"
        | "ROWING_MACHINE"
        | "RUGBY"
        | "JOGGING"
        | "RUNNING_ON_SAND"
        | "TREADMILL_RUNNING"
        | "SAILING"
        | "SCUBA_DIVING"
        | "SKATEBOARDING"
        | "SKATING"
        | "CROSS_SKATING"
        | "INDOOR_ROLLERBLADING"
        | "SKIING"
        | "BACK_COUNTRY_SKIING"
        | "CROSS_COUNTRY_SKIING"
        | "DOWNHILL_SKIING"
        | "KITE_SKIING"
        | "ROLLER_SKIING"
        | "SLEDDING"
        | "SNOWBOARDING"
        | "SNOWMOBILE"
        | "SNOWSHOEING"
        | "SQUASH"
        | "STAIR_CLIMBING"
        | "STAIR_CLIMBING_MACHINE"
        | "STAND_UP_PADDLEBOARDING"
        | "STRENGTH_TRAINING"
        | "SURFING"
        | "SWIMMING"
        | "SWIMMING_SWIMMING_POOL"
        | "SWIMMING_OPEN_WATER"
        | "TABLE_TENNIS"
        | "TEAM_SPORTS"
        | "TENNIS"
        | "TREADMILL"
        | "VOLLEYBALL"
        | "VOLLEYBALL_BEACH"
        | "VOLLEYBALL_INDOOR"
        | "WAKEBOARDING"
        | "WALKING_FITNESS"
        | "NORDIC_WALKING"
        | "WALKING_TREADMILL"
        | "WATERPOLO"
        | "WEIGHTLIFTING"
        | "WHEELCHAIR"
        | "WINDSURFING"
        | "YOGA"
        | "ZUMBA"
        | "DIVING"
        | "ERGOMETER"
        | "ICE_SKATING"
        | "INDOOR_SKATING"
        | "CURLING"
        | "OTHER"
        | "CROSSFIT"
        | "HIIT"
        | "INTERVAL_TRAINING"
        | "WALKING_STROLLER"
        | "ELEVATOR"
        | "ESCALATOR"
        | "ARCHERY"
        | "SOFTBALL"
        | "GUIDED_BREATHING"
        | "CARDIO_TRAINING"
        | "LACROSSE"
        | "STRETCHING"
        | "TRIATHLON"
        | "INLINE_SKATING"
        | "SKY_DIVING"
        | "PADDLING"
        | "MOUNTAINEERING"
        | "FISHING"
        | "WATER_SKIING"
        | "INDOOR_RUNNING";
    export const Type = {
        InVehicle: "IN_VEHICLE",
        Biking: "BIKING",
        Still: "STILL",
        Unknown: "UNKNOWN",
        Tilting: "TILTING",
        Walking: "WALKING",
        Running: "RUNNING",
        Aerobics: "AEROBICS",
        Badminton: "BADMINTON",
        Baseball: "BASEBALL",
        Basketball: "BASKETBALL",
        Biathlon: "BIATHLON",
        Handbiking: "HANDBIKING",
        MountainBiking: "MOUNTAIN_BIKING",
        RoadBiking: "ROAD_BIKING",
        Spinning: "SPINNING",
        StationaryBiking: "STATIONARY_BIKING",
        UtilityBiking: "UTILITY_BIKING",
        Boxing: "BOXING",
        Calisthenics: "CALISTHENICS",
        CircuitTraining: "CIRCUIT_TRAINING",
        Cricket: "CRICKET",
        Dancing: "DANCING",
        Elliptical: "ELLIPTICAL",
        Fencing: "FENCING",
        AmericanFootball: "AMERICAN_FOOTBALL",
        AustralianFootball: "AUSTRALIAN_FOOTBALL",
        EnglishFootball: "ENGLISH_FOOTBALL",
        Frisbee: "FRISBEE",
        Gardening: "GARDENING",
        Golf: "GOLF",
        Gymnastics: "GYMNASTICS",
        Handball: "HANDBALL",
        Hiking: "HIKING",
        Hockey: "HOCKEY",
        HorsebackRiding: "HORSEBACK_RIDING",
        Housework: "HOUSEWORK",
        JumpingRope: "JUMPING_ROPE",
        Kayaking: "KAYAKING",
        KettlebellTraining: "KETTLEBELL_TRAINING",
        Kickboxing: "KICKBOXING",
        Kitesurfing: "KITESURFING",
        MartialArts: "MARTIAL_ARTS",
        Meditation: "MEDITATION",
        MixedMartialArts: "MIXED_MARTIAL_ARTS",
        P90XExercises: "P90X_EXERCISES",
        Paragliding: "PARAGLIDING",
        Pilates: "PILATES",
        Polo: "POLO",
        Racquetball: "RACQUETBALL",
        RockClimbing: "ROCK_CLIMBING",
        Rowing: "ROWING",
        RowingMachine: "ROWING_MACHINE",
        Rugby: "RUGBY",
        Jogging: "JOGGING",
        RunningOnSand: "RUNNING_ON_SAND",
        TreadmillRunning: "TREADMILL_RUNNING",
        Sailing: "SAILING",
        ScubaDiving: "SCUBA_DIVING",
        Skateboarding: "SKATEBOARDING",
        Skating: "SKATING",
        CrossSkating: "CROSS_SKATING",
        IndoorRollerblading: "INDOOR_ROLLERBLADING",
        Skiing: "SKIING",
        BackCountrySkiing: "BACK_COUNTRY_SKIING",
        CrossCountrySkiing: "CROSS_COUNTRY_SKIING",
        DownhillSkiing: "DOWNHILL_SKIING",
        KiteSkiing: "KITE_SKIING",
        RollerSkiing: "ROLLER_SKIING",
        Sledding: "SLEDDING",
        Snowboarding: "SNOWBOARDING",
        Snowmobile: "SNOWMOBILE",
        Snowshoeing: "SNOWSHOEING",
        Squash: "SQUASH",
        StairClimbing: "STAIR_CLIMBING",
        StairClimbingMachine: "STAIR_CLIMBING_MACHINE",
        StandUpPaddleboarding: "STAND_UP_PADDLEBOARDING",
        StrengthTraining: "STRENGTH_TRAINING",
        Surfing: "SURFING",
        Swimming: "SWIMMING",
        SwimmingSwimmingPool: "SWIMMING_SWIMMING_POOL",
        SwimmingOpenWater: "SWIMMING_OPEN_WATER",
        TableTennis: "TABLE_TENNIS",
        TeamSports: "TEAM_SPORTS",
        Tennis: "TENNIS",
        Treadmill: "TREADMILL",
        Volleyball: "VOLLEYBALL",
        VolleyballBeach: "VOLLEYBALL_BEACH",
        VolleyballIndoor: "VOLLEYBALL_INDOOR",
        Wakeboarding: "WAKEBOARDING",
        WalkingFitness: "WALKING_FITNESS",
        NordicWalking: "NORDIC_WALKING",
        WalkingTreadmill: "WALKING_TREADMILL",
        Waterpolo: "WATERPOLO",
        Weightlifting: "WEIGHTLIFTING",
        Wheelchair: "WHEELCHAIR",
        Windsurfing: "WINDSURFING",
        Yoga: "YOGA",
        Zumba: "ZUMBA",
        Diving: "DIVING",
        Ergometer: "ERGOMETER",
        IceSkating: "ICE_SKATING",
        IndoorSkating: "INDOOR_SKATING",
        Curling: "CURLING",
        Other: "OTHER",
        Crossfit: "CROSSFIT",
        Hiit: "HIIT",
        IntervalTraining: "INTERVAL_TRAINING",
        WalkingStroller: "WALKING_STROLLER",
        Elevator: "ELEVATOR",
        Escalator: "ESCALATOR",
        Archery: "ARCHERY",
        Softball: "SOFTBALL",
        GuidedBreathing: "GUIDED_BREATHING",
        CardioTraining: "CARDIO_TRAINING",
        Lacrosse: "LACROSSE",
        Stretching: "STRETCHING",
        Triathlon: "TRIATHLON",
        InlineSkating: "INLINE_SKATING",
        SkyDiving: "SKY_DIVING",
        Paddling: "PADDLING",
        Mountaineering: "MOUNTAINEERING",
        Fishing: "FISHING",
        WaterSkiing: "WATER_SKIING",
        IndoorRunning: "INDOOR_RUNNING",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutRepeatStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PlannedWorkoutRepeatStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** List of steps to be repeated for this workout step - e.g. if a user wants to schedule 5 repetitions of 100m sprints plus 20s rest in between */
    steps?: Terra.PlannedWorkoutStep[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTargets[];
    /** Planned intensity for the workout step */
    intensity?: PlannedWorkoutStep.Intensity;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDurations[];
    /** Name of workout step */
    name?: string;
}

export namespace PlannedWorkoutStep {
    /**
     * Planned intensity for the workout step
     */
    export type Intensity = "REST" | "WARMUP" | "COOLDOWN" | "RECOVERY" | "INTERVAL" | "ACTIVE";
    export const Intensity = {
        Rest: "REST",
        Warmup: "WARMUP",
        Cooldown: "COOLDOWN",
        Recovery: "RECOVERY",
        Interval: "INTERVAL",
        Active: "ACTIVE",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: PlannedWorkoutStepDuration.DurationType;
}

export namespace PlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutStepDurations.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PlannedWorkoutStepDurations =
    | Terra.PlannedWorkoutStepDurations.PlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.TimePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.PowerAbovePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.PowerBelowPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.FixedRestPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.CaloriesPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.HrAbovePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.HrBelowPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.RepsPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.DistancePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.StepsPlannedWorkoutStepDuration;

export namespace PlannedWorkoutStepDurations {
    export interface PlannedWorkoutStepDuration extends Terra.PlannedWorkoutStepDuration {
        type: "PlannedWorkoutStepDuration";
    }

    export interface TimePlannedWorkoutStepDuration extends Terra.TimePlannedWorkoutStepDuration {
        type: "TimePlannedWorkoutStepDuration";
    }

    export interface PowerAbovePlannedWorkoutStepDuration extends Terra.PowerAbovePlannedWorkoutStepDuration {
        type: "PowerAbovePlannedWorkoutStepDuration";
    }

    export interface PowerBelowPlannedWorkoutStepDuration extends Terra.PowerBelowPlannedWorkoutStepDuration {
        type: "PowerBelowPlannedWorkoutStepDuration";
    }

    export interface FixedRestPlannedWorkoutStepDuration extends Terra.FixedRestPlannedWorkoutStepDuration {
        type: "FixedRestPlannedWorkoutStepDuration";
    }

    export interface CaloriesPlannedWorkoutStepDuration extends Terra.CaloriesPlannedWorkoutStepDuration {
        type: "CaloriesPlannedWorkoutStepDuration";
    }

    export interface HrAbovePlannedWorkoutStepDuration extends Terra.HrAbovePlannedWorkoutStepDuration {
        type: "HRAbovePlannedWorkoutStepDuration";
    }

    export interface HrBelowPlannedWorkoutStepDuration extends Terra.HrBelowPlannedWorkoutStepDuration {
        type: "HRBelowPlannedWorkoutStepDuration";
    }

    export interface RepsPlannedWorkoutStepDuration extends Terra.RepsPlannedWorkoutStepDuration {
        type: "RepsPlannedWorkoutStepDuration";
    }

    export interface DistancePlannedWorkoutStepDuration extends Terra.DistancePlannedWorkoutStepDuration {
        type: "DistancePlannedWorkoutStepDuration";
    }

    export interface StepsPlannedWorkoutStepDuration extends Terra.StepsPlannedWorkoutStepDuration {
        type: "StepsPlannedWorkoutStepDuration";
    }
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: PlannedWorkoutStepTarget.TargetType;
}

export namespace PlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutStepTargets.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PlannedWorkoutStepTargets =
    | Terra.PlannedWorkoutStepTargets.PlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.CadencePlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.HrPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.PowerPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.SpeedPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.PacePlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.TssPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.IfPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.RepetitionPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.SwimStrokePlannedWorkoutStepTarget;

export namespace PlannedWorkoutStepTargets {
    export interface PlannedWorkoutStepTarget extends Terra.PlannedWorkoutStepTarget {
        type: "PlannedWorkoutStepTarget";
    }

    export interface CadencePlannedWorkoutStepTarget extends Terra.CadencePlannedWorkoutStepTarget {
        type: "CadencePlannedWorkoutStepTarget";
    }

    export interface HrPlannedWorkoutStepTarget extends Terra.HrPlannedWorkoutStepTarget {
        type: "HRPlannedWorkoutStepTarget";
    }

    export interface PowerPlannedWorkoutStepTarget extends Terra.PowerPlannedWorkoutStepTarget {
        type: "PowerPlannedWorkoutStepTarget";
    }

    export interface SpeedPlannedWorkoutStepTarget extends Terra.SpeedPlannedWorkoutStepTarget {
        type: "SpeedPlannedWorkoutStepTarget";
    }

    export interface PacePlannedWorkoutStepTarget extends Terra.PacePlannedWorkoutStepTarget {
        type: "PacePlannedWorkoutStepTarget";
    }

    export interface TssPlannedWorkoutStepTarget extends Terra.TssPlannedWorkoutStepTarget {
        type: "TSSPlannedWorkoutStepTarget";
    }

    export interface IfPlannedWorkoutStepTarget extends Terra.IfPlannedWorkoutStepTarget {
        type: "IFPlannedWorkoutStepTarget";
    }

    export interface RepetitionPlannedWorkoutStepTarget extends Terra.RepetitionPlannedWorkoutStepTarget {
        type: "RepetitionPlannedWorkoutStepTarget";
    }

    export interface SwimStrokePlannedWorkoutStepTarget extends Terra.SwimStrokePlannedWorkoutStepTarget {
        type: "SwimStrokePlannedWorkoutStepTarget";
    }
}

```
</file>
<file path="terra-client-js/src/api/types/PlannedWorkoutSteps.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PlannedWorkoutSteps =
    | Terra.PlannedWorkoutSteps.PlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.PlannedWorkoutRepeatStep
    | Terra.PlannedWorkoutSteps.SwimmingPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.CardioPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.StrengthPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.YogaPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.PilatesPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.RunningPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.CyclingPlannedWorkoutStep;

export namespace PlannedWorkoutSteps {
    export interface PlannedWorkoutStep extends Terra.PlannedWorkoutStep {
        type: "PlannedWorkoutStep";
    }

    export interface PlannedWorkoutRepeatStep extends Terra.PlannedWorkoutRepeatStep {
        type: "PlannedWorkoutRepeatStep";
    }

    export interface SwimmingPlannedWorkoutStep extends Terra.SwimmingPlannedWorkoutStep {
        type: "SwimmingPlannedWorkoutStep";
    }

    export interface CardioPlannedWorkoutStep extends Terra.CardioPlannedWorkoutStep {
        type: "CardioPlannedWorkoutStep";
    }

    export interface StrengthPlannedWorkoutStep extends Terra.StrengthPlannedWorkoutStep {
        type: "StrengthPlannedWorkoutStep";
    }

    export interface YogaPlannedWorkoutStep extends Terra.YogaPlannedWorkoutStep {
        type: "YogaPlannedWorkoutStep";
    }

    export interface PilatesPlannedWorkoutStep extends Terra.PilatesPlannedWorkoutStep {
        type: "PilatesPlannedWorkoutStep";
    }

    export interface RunningPlannedWorkoutStep extends Terra.RunningPlannedWorkoutStep {
        type: "RunningPlannedWorkoutStep";
    }

    export interface CyclingPlannedWorkoutStep extends Terra.CyclingPlannedWorkoutStep {
        type: "CyclingPlannedWorkoutStep";
    }
}

```
</file>
<file path="terra-client-js/src/api/types/PolylineMapData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PolylineMapData {
    /** The polyline representation of the user's trajectory throughout the workout */
    summary_polyline?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/PositionData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PositionData {
    /** Position of the user at the midway point of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable. */
    center_pos_lat_lng_deg?: number[];
    /** Position of the user at the end of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable. */
    end_pos_lat_lng_deg?: number[];
    /** Array of datapoints of the position of the user, sampled throughout the workout. */
    position_samples?: Terra.PositionSample[];
    /** Position of the user at the start of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable. */
    start_pos_lat_lng_deg?: number[];
}

```
</file>
<file path="terra-client-js/src/api/types/PositionSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PositionSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Position of the user a given point in time, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable */
    coords_lat_lng_deg?: unknown[];
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/PowerAbovePlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerAbovePlannedWorkoutStepDuration {
    /** Threshold power goal to complete the workout step - once the user reaches above this power level, the step will be completed */
    power_above_watts?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: PowerAbovePlannedWorkoutStepDuration.DurationType;
}

export namespace PowerAbovePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PowerBelowPlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerBelowPlannedWorkoutStepDuration {
    /** Threshold power goal to complete the workout step - once the user reaches below this power level, the step will be completed */
    power_below_watts?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: PowerBelowPlannedWorkoutStepDuration.DurationType;
}

export namespace PowerBelowPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PowerData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PowerData {
    /** Average power output of the user during the workout. */
    avg_watts?: number;
    /** Maximum power output of the user during the workout. */
    max_watts?: number;
    /** Array containing datapoints of the power output of the user sampled throughout the workout. */
    power_samples?: Terra.PowerSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/PowerPlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: PowerPlannedWorkoutStepTarget.TargetType;
    /** Maximum percentage of Functional Threshold Power for the workout step - i.e. the user is to stay under this value during the workout step */
    power_percentage_low?: number;
    /** Minimum percentage of Functional Threshold Power for the workout step - i.e. the user is to stay above this value during the workout */
    power_percentage_high?: number;
    /** Maximum power threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    power_watt_high?: number;
    /** Minimum power threshold for the workout step - i.e. the user is to stay above this value during the workout */
    power_watt_low?: number;
    power_watt?: number;
    /** Ideal percentage of user's Functional Threshold Power to be maintained workout step */
    power_percentage?: number;
}

export namespace PowerPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/PowerSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Power generated at a given instant in time, in Watts */
    watts?: number;
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/ProcessingEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Processing event returned when data is being fetched asynchronously
 */
export interface ProcessingEvent {
    type: "processing";
    /** Status of the processing */
    status: "success";
    /** Information about the processing */
    message: string;
    /** User whose data is being processed */
    user: Terra.TerraUser;
    /** Seconds to wait before retrying */
    retry_after_seconds: number;
}

```
</file>
<file path="terra-client-js/src/api/types/PulseVelocitySample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PulseVelocitySample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's Pulse Wave Velocity measurement - velocity at which the blood pressure pulse propagates through the circulatory system */
    pulse_wave_velocity_meters_per_second?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/RateLimitHitEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Rate limit hit event
 */
export interface RateLimitHitEvent {
    type: "rate_limit_hit";
    /** User whose request hit rate limits */
    user: Terra.TerraUser;
    /** Start date of the requested data range */
    start_date: string;
    /** End date of the requested data range */
    end_date: string;
    /** When the request will be retried */
    retrying_at: string;
    /** Information about the rate limit */
    message: string;
}

```
</file>
<file path="terra-client-js/src/api/types/RateLimitHitWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type RateLimitHitWebhook = Terra.RateLimitHitEvent;

```
</file>
<file path="terra-client-js/src/api/types/RateLimitRequestProcessing.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RateLimitRequestProcessing {
    message?: string;
    type?: string;
    user: Terra.TerraUser;
}

```
</file>
<file path="terra-client-js/src/api/types/RawEcgSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RawEcgSample {
    /** Potential uV in the RawECG Sample */
    potential_uV?: number;
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/ReadinessData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ReadinessData {
    /** User's readiness score for a given day, resulting from the sleep session. */
    readiness?: number;
    /** User's recovery score for a given day, resulting from the sleep session - takes Enum value. */
    recovery_level?: Terra.RecoveryLevel;
}

```
</file>
<file path="terra-client-js/src/api/types/RecoveryLevel.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Excellent recovery level.
 */
export type RecoveryLevel = number;

```
</file>
<file path="terra-client-js/src/api/types/RepetitionPlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RepetitionPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: RepetitionPlannedWorkoutStepTarget.TargetType;
    /** Number of repetitions of the workout step to be performed */
    repetitions?: number;
}

export namespace RepetitionPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/RepsPlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RepsPlannedWorkoutStepDuration {
    /** Target number of reps for the workout step - once the user completes this rep target, the step will be completed */
    reps?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: RepsPlannedWorkoutStepDuration.DurationType;
}

export namespace RepsPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/RequestProcessing.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RequestProcessing {
    /** Recommended time after which the request may be retried */
    retry_after_seconds?: number;
    message?: string;
    type?: string;
    /** Terra User object */
    user?: Terra.TerraUser;
}

```
</file>
<file path="terra-client-js/src/api/types/RespirationData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RespirationData {
    /** Object containing information on breathing rate for the sleep session. */
    breaths_data?: Terra.BreathsData;
    /** Object containing information on saturation metrics for the sleep session. */
    oxygen_saturation_data?: Terra.OxygenSaturationData;
    /** Object containing information on snoring metrics for the sleep session. */
    snoring_data?: Terra.SnoringData;
}

```
</file>
<file path="terra-client-js/src/api/types/RrIntervalSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RrIntervalSample {
    /** User's RR Interval for a specific heart beat in milliseconds. */
    rr_interval_ms?: number;
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** The heart beat value at that specific instance. */
    hr_bpm?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/RunningPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RunningPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/S3PayloadEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * S3 Upload event with data download URL
 */
export interface S3PayloadEvent {
    type: "s3_payload";
    /** Status of the upload */
    status: "success";
    /** URL to download the data */
    url: string;
    /** Time in seconds until URL expiration */
    expires_in: number;
}

```
</file>
<file path="terra-client-js/src/api/types/S3UploadWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type S3UploadWebhook = Terra.S3PayloadEvent;

```
</file>
<file path="terra-client-js/src/api/types/ScoresData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ScoresData {
    /** Activity score for the given day. */
    activity?: number;
    /** Recovery score for the given day. */
    recovery?: number;
    /** Sleep score for the given day, pertaining to the previous night's sleep. */
    sleep?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/Sleep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Sleep {
    /** Object containing additional enrichment data for the sleep session. */
    data_enrichment?: Terra.SleepDataEnrichment;
    /** Object containing information on the device which recorded data for the payload. */
    device_data?: Terra.DeviceData;
    /** Object containing information on the user's heart rate during the sleep session. */
    heart_rate_data?: Terra.HeartRateData;
    /** Object containing daily summary metadata. */
    metadata: Terra.SleepMetadata;
    /** Object containing information on the user's readiness for the day, based off the quality and duration of their sleep. */
    readiness_data?: Terra.ReadinessData;
    /** Object containing information on the user's respiration throughout the sleep session. */
    respiration_data?: Terra.RespirationData;
    /** User's sleep score */
    scores?: Sleep.Scores;
    /** Object containing information on the user's duration spent in various sleep stages. */
    sleep_durations_data?: Terra.SleepDurationsData;
    /** Object containing body temperature information of the user during the sleep recording session. */
    temperature_data?: Terra.SleepTemperatureData;
}

export namespace Sleep {
    /**
     * User's sleep score
     */
    export interface Scores {
        /** User's sleep score. */
        sleep_score?: number;
    }
}

```
</file>
<file path="terra-client-js/src/api/types/SleepDataEnrichment.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepDataEnrichment {
    sleep_contributors?: Terra.DataContributor[];
    sleep_score?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/SleepDurationsData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepDurationsData {
    /** Object containing information on the duration the user spent asleep during the sleep recording session. */
    asleep?: Terra.AsleepDurations;
    /** Object containing information on the duration the user spent awake during the sleep recording session. */
    awake?: Terra.AwakeDurations;
    /** List of sleep stage (Hypnogram) samples recorded during the user's sleep session. */
    hypnogram_samples?: Terra.SleepHypnogramSample[];
    /** Object containing information on the miscellaneous duration data for the sleep recording session. */
    other?: Terra.OtherSleepDurations;
    /** Sleep efficiency of the user given as a percentage, measured as time spent asleep divided by time spent in bed. */
    sleep_efficiency?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/SleepEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Sleep data event
 */
export interface SleepEvent {
    type: "sleep";
    /** Array of sleep data */
    data: Terra.Sleep[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}

```
</file>
<file path="terra-client-js/src/api/types/SleepHypnogramSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepHypnogramSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    level?: Terra.SleepLevel;
}

```
</file>
<file path="terra-client-js/src/api/types/SleepLevel.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * User is in REM sleep stage.
 */
export type SleepLevel = number;

```
</file>
<file path="terra-client-js/src/api/types/SleepMetadata.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepMetadata {
    /** The end time of the associated sleep session, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** Flag indicating whether the sleep session was a nap, or the user's main sleep session for the day. */
    is_nap?: boolean;
    /** The start time of the associated sleep session, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    /** A unique identifier for the sleep session. */
    summary_id?: string;
    timestamp_localization?: Terra.TimestampLocalization;
    /** The upload type for the associated sleep session, providing information on whether this was an automatic sleep or user-entered. */
    upload_type: Terra.Indeterminate;
}

```
</file>
<file path="terra-client-js/src/api/types/SleepTemperatureData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SleepTemperatureData {
    /** Variation in user's skin temperature from their baseline. */
    delta?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/SleepWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type SleepWebhook = Terra.SleepEvent;

```
</file>
<file path="terra-client-js/src/api/types/Snack.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Any light meal or snack consumed at any time, not fitting into main meal categories.
 */
export type Snack = number;

```
</file>
<file path="terra-client-js/src/api/types/SnoringData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SnoringData {
    /** The start time of the recording of snoring data, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time?: string;
    /** The end time of the recording of snoring data, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time?: string;
    /** Number of times over the sleep period when the user started snoring, as determined by the device. */
    num_snoring_events?: number;
    /** List of snoring information data points sampled throughout the sleep session. */
    samples?: Terra.SnoringSample[];
    /** Total duration for which the user was snoring. */
    total_snoring_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/SnoringSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SnoringSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Duration of snoring episode, in seconds */
    duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/SpeedPlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SpeedPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: SpeedPlannedWorkoutStepTarget.TargetType;
    /** Maximum speed threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    speed_percentage_high?: number;
    /** Minimum speed threshold for the workout step - i.e. the user is to stay above this value during the workout step */
    speed_percentage_low?: number;
    /** Ideal percentage of user's Threshold Speed, based off their Threshold Pace, to be maintained workout step. Usually, the Threshold Pace is defined as the pace one could race at for 50 to 60 minutes */
    speed_percentage?: number;
    /** Ideal speed value to be maintained for the workout step */
    speed_meters_per_second?: number;
}

export namespace SpeedPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/SpeedSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SpeedSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    speed_meters_per_second?: number;
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/StepSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StepSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    steps?: number;
    timer_duration_seconds?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/StepsPlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StepsPlannedWorkoutStepDuration {
    /** Target number of steps for the workout step - once the user performs this number of steps, the step will be completed */
    steps?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: StepsPlannedWorkoutStepDuration.DurationType;
}

export namespace StepsPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/StrainData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StrainData {
    /** Level of cardiovascular strain imposed on the user during the day. */
    strain_level?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/StrengthPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface StrengthPlannedWorkoutStep {
    /** Weight to be lifted for the exercise */
    weight_kg?: number;
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Name of strength exercise to be performed for the workout step */
    exercice_name?: string;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Type of strength exercise to be performed for the workout step */
    exercice_category?: StrengthPlannedWorkoutStep.ExerciceCategory;
    /** Name of workout step */
    name?: string;
}

export namespace StrengthPlannedWorkoutStep {
    /**
     * Type of strength exercise to be performed for the workout step
     */
    export type ExerciceCategory =
        | "UNKNOWN"
        | "BENCH_PRESS"
        | "CALF_RAISE"
        | "CARDIO"
        | "CARRY"
        | "CHOP"
        | "CORE"
        | "CRUNCH"
        | "CURL"
        | "DEADLIFT"
        | "FLYE"
        | "HIP_RAISE"
        | "HIP_STABILITY"
        | "HIP_SWING"
        | "HYPEREXTENSION"
        | "LATERAL_RAISE"
        | "LEG_CURL"
        | "LEG_RAISE"
        | "LUNGE"
        | "OLYMPIC_LIFT"
        | "PLANK"
        | "PLYO"
        | "PULL_UP"
        | "PUSH_UP"
        | "ROW"
        | "SHOULDER_PRESS"
        | "SHOULDER_STABILITY"
        | "SHRUG"
        | "SIT_UP"
        | "SQUAT"
        | "TOTAL_BODY"
        | "TRICEPS_EXTENSION"
        | "WARM_UP"
        | "RUN"
        | "BIKE"
        | "CARDIO_SENSORS";
    export const ExerciceCategory = {
        Unknown: "UNKNOWN",
        BenchPress: "BENCH_PRESS",
        CalfRaise: "CALF_RAISE",
        Cardio: "CARDIO",
        Carry: "CARRY",
        Chop: "CHOP",
        Core: "CORE",
        Crunch: "CRUNCH",
        Curl: "CURL",
        Deadlift: "DEADLIFT",
        Flye: "FLYE",
        HipRaise: "HIP_RAISE",
        HipStability: "HIP_STABILITY",
        HipSwing: "HIP_SWING",
        Hyperextension: "HYPEREXTENSION",
        LateralRaise: "LATERAL_RAISE",
        LegCurl: "LEG_CURL",
        LegRaise: "LEG_RAISE",
        Lunge: "LUNGE",
        OlympicLift: "OLYMPIC_LIFT",
        Plank: "PLANK",
        Plyo: "PLYO",
        PullUp: "PULL_UP",
        PushUp: "PUSH_UP",
        Row: "ROW",
        ShoulderPress: "SHOULDER_PRESS",
        ShoulderStability: "SHOULDER_STABILITY",
        Shrug: "SHRUG",
        SitUp: "SIT_UP",
        Squat: "SQUAT",
        TotalBody: "TOTAL_BODY",
        TricepsExtension: "TRICEPS_EXTENSION",
        WarmUp: "WARM_UP",
        Run: "RUN",
        Bike: "BIKE",
        CardioSensors: "CARDIO_SENSORS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/StressData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface StressData {
    /** Average stress level for the day. */
    avg_stress_level?: number;
    /** Total number of seconds spent in a stressed state while active during the day. */
    activity_stress_duration_seconds?: number;
    /** Total number of seconds spent in a state of low stress during the day. */
    low_stress_duration_seconds?: number;
    /** Maximum stress level recorded during the day. */
    max_stress_level?: number;
    /** Total number of seconds spent in a state of medium stress during the day. */
    medium_stress_duration_seconds?: number;
    /** Array of stress level data points sampled throughout the day. */
    samples?: Terra.StressSample[];
    /** Total number of seconds spent in a stressed state while at rest during the day. */
    rest_stress_duration_seconds?: number;
    /** Total number of seconds spent in a state of high stress during the day. */
    high_stress_duration_seconds?: number;
    /** Total number of seconds spent in a stressed state while at rest during the day. */
    stress_duration_seconds?: number;
    /** Stress rating for the day. */
    stress_rating?: Terra.High;
    /** Array of Body Battery data points sampled throughout the day. */
    body_battery_samples?: Terra.BodyBatterySample[];
}

```
</file>
<file path="terra-client-js/src/api/types/StressSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StressSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    level?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/StrokeType.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Stroke type used for the workout step (e.g. breaststroke)
 */
export type StrokeType =
    /**
     * Any swimming stroke style that doesn't fit the standard categories. */
    | "other"
    /**
     * Front crawl stroke where swimmers alternate arm movements with face in water. */
    | "freestyle"
    /**
     * Swimming stroke performed on the back with alternating arm movements. */
    | "backstroke"
    /**
     * Swimming stroke where arms move simultaneously in a heart-shaped pattern with a frog kick. */
    | "breaststroke"
    /**
     * Swimming stroke with simultaneous overhead arm movements and dolphin kick. */
    | "butterfly";
export const StrokeType = {
    Other: "other",
    Freestyle: "freestyle",
    Backstroke: "backstroke",
    Breaststroke: "breaststroke",
    Butterfly: "butterfly",
} as const;

```
</file>
<file path="terra-client-js/src/api/types/SwimStrokePlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SwimStrokePlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: SwimStrokePlannedWorkoutStepTarget.TargetType;
    /** Number of swim strokes to be performed during the workout step */
    swim_strokes?: number;
}

export namespace SwimStrokePlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/SwimmingData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SwimmingData {
    /** Total number of swimming laps performed during the day. */
    num_laps?: number;
    /** Total number of swimming strokes performed during the day. */
    num_strokes?: number;
    /** Pool length for associated with the day. */
    pool_length_meters?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/SwimmingPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SwimmingPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Workout equipment to be used during the workout step */
    equipement_type?: SwimmingPlannedWorkoutStep.EquipementType;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
    /** Stroke type used for the workout step (e.g. breaststroke) */
    stroke_type?: SwimmingPlannedWorkoutStep.StrokeType;
}

export namespace SwimmingPlannedWorkoutStep {
    /**
     * Workout equipment to be used during the workout step
     */
    export type EquipementType =
        | "NONE"
        | "SWIM_FINS"
        | "SWIM_KICKBOARD"
        | "SWIM_PADDLES"
        | "SWIM_PULL_BUOY"
        | "SWIM_SNORKEL";
    export const EquipementType = {
        None: "NONE",
        SwimFins: "SWIM_FINS",
        SwimKickboard: "SWIM_KICKBOARD",
        SwimPaddles: "SWIM_PADDLES",
        SwimPullBuoy: "SWIM_PULL_BUOY",
        SwimSnorkel: "SWIM_SNORKEL",
    } as const;
    /**
     * Stroke type used for the workout step (e.g. breaststroke)
     */
    export type StrokeType = "OTHER" | "FREESTYLE" | "BACKSTROKE" | "BREASTSTROKE" | "BUTTERFLY" | "REST";
    export const StrokeType = {
        Other: "OTHER",
        Freestyle: "FREESTYLE",
        Backstroke: "BACKSTROKE",
        Breaststroke: "BREASTSTROKE",
        Butterfly: "BUTTERFLY",
        Rest: "REST",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/TagData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface TagData {
    /** Array of user-entered tags for the day. */
    tags?: Terra.TagEntry[];
}

```
</file>
<file path="terra-client-js/src/api/types/TagEntry.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TagEntry {
    /** Time with which the tag is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp: string;
    /** Tag name, representing a certain event associated with the user's day. */
    tag_name: string;
    /** User-input notes associated with the given tag. */
    notes: string;
}

```
</file>
<file path="terra-client-js/src/api/types/TemperatureData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface TemperatureData {
    /** List of ambient temperature measurements sampled throughout the day. */
    ambient_temperature_samples?: Terra.TemperatureSample[];
    /** List of body temperature measurements sampled throughout the day. */
    body_temperature_samples?: Terra.TemperatureSample[];
    /** List of skin temperature measurements sampled throughout the day. */
    skin_temperature_samples?: Terra.TemperatureSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/TemperatureSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TemperatureSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** Temperature value in degrees Celsius. */
    temperature_celsius?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/TerraUser.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TerraUser {
    /** Terra identifier for the wearable connection */
    user_id: string;
    /** Connection data source */
    provider: string;
    /** Last time at which a webhook update was sent for the connection */
    last_webhook_update?: string;
    /** (when available) Permissions granted by the user during authentication - to be used as debugging metadata */
    scopes?: string;
    /** Connection identifier on the developer's end, used to tie connection back to a user on the developer's platform */
    reference_id?: string;
    /** whether the user is active or not (inactive users will not receive any data updates and are in considered */
    active?: boolean;
}

```
</file>
<file path="terra-client-js/src/api/types/TimePlannedWorkoutStepDuration.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TimePlannedWorkoutStepDuration {
    /** Time duration to be elapsed for the workout step */
    seconds?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: TimePlannedWorkoutStepDuration.DurationType;
}

export namespace TimePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/TimestampLocalization.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Indicates whether the timestamps in this payload are localized (LOCAL) or in UTC.
 */
export type TimestampLocalization = number;

```
</file>
<file path="terra-client-js/src/api/types/TorqueSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TorqueSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    timestamp?: string;
    /** Time elapsed since the start of the workout, subtracting time during which the recording was paused */
    timer_duration_seconds?: number;
    /** Torque generated at a given instant in time, in Newton-meters */
    torque_newton_meters?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/TrendArrow.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Glucose level is increasing rapidly.
 */
export type TrendArrow = number;

```
</file>
<file path="terra-client-js/src/api/types/TssData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface TssData {
    /** Array of TSS information sampled throughout the workout */
    TSS_samples?: Terra.TssSample[];
}

```
</file>
<file path="terra-client-js/src/api/types/TssPlannedWorkoutStepTarget.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TssPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: TssPlannedWorkoutStepTarget.TargetType;
    /** Planned Training Stress Score to be achieved for the workout step */
    tss?: number;
}

export namespace TssPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/TssSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TssSample {
    planned?: number;
    actual?: number;
    method?: string;
    intensity_factor_planned?: number;
    intensity_factor_actual?: number;
    normalized_power_watts?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/UnauthorizedErrorBody.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UnauthorizedErrorBody {
    /** a detailed message describing the error */
    message?: string;
    /** indicates that an error happened (value is error) */
    status?: UnauthorizedErrorBody.Status;
}

export namespace UnauthorizedErrorBody {
    /**
     * indicates that an error happened (value is error)
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}

```
</file>
<file path="terra-client-js/src/api/types/UploadType.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * The workout was uploaded or synced from a third-party service or application.
 */
export type UploadType = number;

```
</file>
<file path="terra-client-js/src/api/types/User.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type User = Terra.TerraUser;

```
</file>
<file path="terra-client-js/src/api/types/UserAuthWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserAuthWebhook = Terra.AuthSuccessEvent;

```
</file>
<file path="terra-client-js/src/api/types/UserAuthWebhookError.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserAuthWebhookError = Terra.AuthErrorEvent;

```
</file>
<file path="terra-client-js/src/api/types/UserAuthWebhookPayload.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserAuthWebhookPayload = Terra.UserAuthWebhookPayload.Success | Terra.UserAuthWebhookPayload.Error_;

export namespace UserAuthWebhookPayload {
    export interface Success extends Terra.AuthSuccessEvent {
        status: "success";
    }

    export interface Error_ extends Terra.AuthErrorEvent {
        status: "error";
    }
}

```
</file>
<file path="terra-client-js/src/api/types/UserDeauthWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserDeauthWebhook = Terra.DeauthEvent;

```
</file>
<file path="terra-client-js/src/api/types/UserReauthEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * User re-authentication event
 */
export interface UserReauthEvent {
    type: "user_reauth";
    /** The new user record */
    new_user: Terra.TerraUser;
    /** The old user record that will be deleted */
    old_user: Terra.TerraUser;
    /** Status of the re-authentication */
    status: "warning";
    /** Information about the re-authentication */
    message: string;
}

```
</file>
<file path="terra-client-js/src/api/types/UserReauthWebhook.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserReauthWebhook = Terra.UserReauthEvent;

```
</file>
<file path="terra-client-js/src/api/types/Vo2MaxSample.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Vo2MaxSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** User's VO2Max - maximum amount of oxygen the user's body can utilize during exercise */
    vo2max_ml_per_min_per_kg?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/WebhookEvent.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Base webhook event structure that all events extend from
 */
export interface WebhookEvent {
    /** The type of event */
    type: string;
}

```
</file>
<file path="terra-client-js/src/api/types/WebhookEventType.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Union of all possible webhook event types
 */
export type WebhookEventType =
    | Terra.HealthcheckEvent
    | Terra.AuthSuccessEvent
    | Terra.AuthErrorEvent
    | Terra.DeauthEvent
    | Terra.UserReauthEvent
    | Terra.AccessRevokedEvent
    | Terra.ConnectionErrorEvent
    | Terra.GoogleNoDatasourceEvent
    | Terra.PermissionChangeEvent
    | Terra.ProcessingEvent
    | Terra.LargeRequestProcessingEvent
    | Terra.LargeRequestSendingEvent
    | Terra.RateLimitHitEvent
    | Terra.ActivityEvent
    | Terra.AthleteEvent
    | Terra.BodyEvent
    | Terra.DailyEvent
    | Terra.MenstruationEvent
    | Terra.NutritionEvent
    | Terra.SleepEvent
    | Terra.S3PayloadEvent;

```
</file>
<file path="terra-client-js/src/api/types/WebhookEvents.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type WebhookEvents = Terra.WebhookEventType;

```
</file>
<file path="terra-client-js/src/api/types/WorkData.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface WorkData {
    /** Total work output of the user for the workout, in kilojoules. */
    work_kilojoules?: number;
}

```
</file>
<file path="terra-client-js/src/api/types/YogaPlannedWorkoutStep.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface YogaPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}

```
</file>
<file path="terra-client-js/src/api/types/index.ts">
```ts
export * from "./BadRequestErrorBody.js";
export * from "./NotFoundErrorBody.js";
export * from "./UnauthorizedErrorBody.js";
export * from "./UserAuthWebhookPayload.js";
export * from "./User.js";
export * from "./NoDataReturned.js";
export * from "./RequestProcessing.js";
export * from "./RateLimitRequestProcessing.js";
export * from "./DataSentToWebhook.js";
export * from "./Activity.js";
export * from "./Athlete.js";
export * from "./AthleteCollection.js";
export * from "./Body.js";
export * from "./Daily.js";
export * from "./Menstruation.js";
export * from "./Nutrition.js";
export * from "./Sleep.js";
export * from "./PlannedWorkoutStepTarget.js";
export * from "./CadencePlannedWorkoutStepTarget.js";
export * from "./HrPlannedWorkoutStepTarget.js";
export * from "./PowerPlannedWorkoutStepTarget.js";
export * from "./SpeedPlannedWorkoutStepTarget.js";
export * from "./PacePlannedWorkoutStepTarget.js";
export * from "./TssPlannedWorkoutStepTarget.js";
export * from "./IfPlannedWorkoutStepTarget.js";
export * from "./RepetitionPlannedWorkoutStepTarget.js";
export * from "./SwimStrokePlannedWorkoutStepTarget.js";
export * from "./PlannedWorkoutStepTargets.js";
export * from "./PlannedWorkoutStepDuration.js";
export * from "./TimePlannedWorkoutStepDuration.js";
export * from "./PowerAbovePlannedWorkoutStepDuration.js";
export * from "./PowerBelowPlannedWorkoutStepDuration.js";
export * from "./FixedRestPlannedWorkoutStepDuration.js";
export * from "./CaloriesPlannedWorkoutStepDuration.js";
export * from "./HrAbovePlannedWorkoutStepDuration.js";
export * from "./HrBelowPlannedWorkoutStepDuration.js";
export * from "./RepsPlannedWorkoutStepDuration.js";
export * from "./DistancePlannedWorkoutStepDuration.js";
export * from "./StepsPlannedWorkoutStepDuration.js";
export * from "./PlannedWorkoutStepDurations.js";
export * from "./PlannedWorkoutStep.js";
export * from "./PlannedWorkoutRepeatStep.js";
export * from "./SwimmingPlannedWorkoutStep.js";
export * from "./CardioPlannedWorkoutStep.js";
export * from "./StrengthPlannedWorkoutStep.js";
export * from "./YogaPlannedWorkoutStep.js";
export * from "./PilatesPlannedWorkoutStep.js";
export * from "./RunningPlannedWorkoutStep.js";
export * from "./CyclingPlannedWorkoutStep.js";
export * from "./PlannedWorkoutSteps.js";
export * from "./PlannedWorkoutMetadata.js";
export * from "./PlannedWorkout.js";
export * from "./DataProcessingWebhook.js";
export * from "./UserAuthWebhook.js";
export * from "./UserAuthWebhookError.js";
export * from "./PermissionChangeWebhook.js";
export * from "./UserReauthWebhook.js";
export * from "./UserDeauthWebhook.js";
export * from "./AccessRevokedWebhook.js";
export * from "./GoogleNoDataSourceWebhook.js";
export * from "./ConnectionErrorWebhook.js";
export * from "./LargeRequestSendingWebhook.js";
export * from "./LargeRequestProcessingResponse.js";
export * from "./AuthenticationFailedWebhook.js";
export * from "./HealthCheckWebhook.js";
export * from "./RateLimitHitWebhook.js";
export * from "./S3UploadWebhook.js";
export * from "./ActivityWebhook.js";
export * from "./DailyWebhook.js";
export * from "./NutritionWebhook.js";
export * from "./AthleteWebhook.js";
export * from "./SleepWebhook.js";
export * from "./MenstruationWebhook.js";
export * from "./BodyWebhook.js";
export * from "./IntegrationsResponse.js";
export * from "./IntegrationProvider.js";
export * from "./WebhookEvents.js";
export * from "./TerraUser.js";
export * from "./ActivityLevel.js";
export * from "./ActivityLevelSample.js";
export * from "./ActiveDurationsData.js";
export * from "./CalorieSample.js";
export * from "./CaloriesData.js";
export * from "./DataEnrichment.js";
export * from "./DeviceDataType.js";
export * from "./OtherDeviceData.js";
export * from "./DeviceData.js";
export * from "./DistanceSample.js";
export * from "./ElevationSample.js";
export * from "./FloorsClimbedSample.js";
export * from "./StepSample.js";
export * from "./DistanceDataDetailed.js";
export * from "./ElevationData.js";
export * from "./SwimmingData.js";
export * from "./DistanceDataSummary.js";
export * from "./DistanceData.js";
export * from "./EnergyData.js";
export * from "./HeartRateContext.js";
export * from "./HeartRateDataSample.js";
export * from "./HeartRateVariabilityDataSampleRmssd.js";
export * from "./HeartRateVariabilityDataSampleSdnn.js";
export * from "./HeartRateDataDetailed.js";
export * from "./Other.js";
export * from "./HeartRateZoneData.js";
export * from "./HeartRateDataSummary.js";
export * from "./HeartRateData.js";
export * from "./StrokeType.js";
export * from "./LapSample.js";
export * from "./LapData.js";
export * from "./MetSample.js";
export * from "./MetData.js";
export * from "./TimestampLocalization.js";
export * from "./Hurling.js";
export * from "./UploadType.js";
export * from "./ActivityMetadata.js";
export * from "./CadenceSample.js";
export * from "./SpeedSample.js";
export * from "./TorqueSample.js";
export * from "./MovementData.js";
export * from "./Muscle.js";
export * from "./OxygenSaturationSample.js";
export * from "./Vo2MaxSample.js";
export * from "./OxygenData.js";
export * from "./PolylineMapData.js";
export * from "./PositionSample.js";
export * from "./PositionData.js";
export * from "./PowerSample.js";
export * from "./PowerData.js";
export * from "./StrainData.js";
export * from "./TssSample.js";
export * from "./TssData.js";
export * from "./WorkData.js";
export * from "./WebhookEvent.js";
export * from "./LargeRequestProcessingEvent.js";
export * from "./BloodPressureSample.js";
export * from "./BloodPressureData.js";
export * from "./Inconclusive.js";
export * from "./AFibClassificationSample.js";
export * from "./RawEcgSample.js";
export * from "./EcgReading.js";
export * from "./PulseVelocitySample.js";
export * from "./RrIntervalSample.js";
export * from "./HeartData.js";
export * from "./HydrationMeasurementSample.js";
export * from "./HydrationData.js";
export * from "./Breath.js";
export * from "./KetoneSample.js";
export * from "./KetoneData.js";
export * from "./MeasurementDataSample.js";
export * from "./MeasurementsData.js";
export * from "./BodyMetadata.js";
export * from "./TemperatureSample.js";
export * from "./TemperatureData.js";
export * from "./Low.js";
export * from "./TrendArrow.js";
export * from "./GlucoseDataSample.js";
export * from "./DailyPatternSample.js";
export * from "./GlucoseData.js";
export * from "./DataContributor.js";
export * from "./DailyDataEnrichment.js";
export * from "./DailyDistanceData.js";
export * from "./DailyMetadata.js";
export * from "./ScoresData.js";
export * from "./StressSample.js";
export * from "./High.js";
export * from "./BodyBatterySample.js";
export * from "./StressData.js";
export * from "./TagEntry.js";
export * from "./TagData.js";
export * from "./MenstruationMetadata.js";
export * from "./MenstrualPhase.js";
export * from "./Had.js";
export * from "./MenstruationFlowSample.js";
export * from "./MenstruationData.js";
export * from "./DrinkSample.js";
export * from "./NutritionMicros.js";
export * from "./Snack.js";
export * from "./NutritionUnits.js";
export * from "./NutritionQuantity.js";
export * from "./NutritionMacros.js";
export * from "./Meal.js";
export * from "./NutritionMetadata.js";
export * from "./NutritionSummary.js";
export * from "./SleepDataEnrichment.js";
export * from "./Indeterminate.js";
export * from "./SleepMetadata.js";
export * from "./RecoveryLevel.js";
export * from "./ReadinessData.js";
export * from "./BreathSample.js";
export * from "./BreathsData.js";
export * from "./OxygenSaturationData.js";
export * from "./SnoringSample.js";
export * from "./SnoringData.js";
export * from "./RespirationData.js";
export * from "./AsleepDurations.js";
export * from "./AwakeDurations.js";
export * from "./SleepLevel.js";
export * from "./SleepHypnogramSample.js";
export * from "./OtherSleepDurations.js";
export * from "./SleepDurationsData.js";
export * from "./SleepTemperatureData.js";
export * from "./HealthcheckEvent.js";
export * from "./AuthEvent.js";
export * from "./AuthSuccessEvent.js";
export * from "./AuthErrorEvent.js";
export * from "./DeauthEvent.js";
export * from "./UserReauthEvent.js";
export * from "./AccessRevokedEvent.js";
export * from "./ConnectionErrorEvent.js";
export * from "./GoogleNoDatasourceEvent.js";
export * from "./ProcessingEvent.js";
export * from "./LargeRequestSendingEvent.js";
export * from "./RateLimitHitEvent.js";
export * from "./S3PayloadEvent.js";
export * from "./ActivityEvent.js";
export * from "./AthleteEvent.js";
export * from "./NutritionEvent.js";
export * from "./DailyEvent.js";
export * from "./SleepEvent.js";
export * from "./MenstruationEvent.js";
export * from "./BodyEvent.js";
export * from "./PermissionChangeEvent.js";
export * from "./WebhookEventType.js";

```
</file>
<file path="terra-client-js/src/core/fetcher/APIResponse.ts">
```ts
import { RawResponse } from "./RawResponse.js";

/**
 * The response of an API call.
 * It is a successful response or a failed response.
 */
export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
    /**
     * @deprecated Use `rawResponse` instead
     */
    headers?: Record<string, any>;
    rawResponse: RawResponse;
}

export interface FailedResponse<T> {
    ok: false;
    error: T;
    rawResponse: RawResponse;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/BinaryResponse.ts">
```ts
import { ResponseWithBody } from "./ResponseWithBody.js";

export interface BinaryResponse {
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bodyUsed) */
    bodyUsed: boolean;
    /**
     * Returns a ReadableStream of the response body.
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/body)
     */
    stream: () => ReadableStream<Uint8Array>;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/arrayBuffer) */
    arrayBuffer: () => Promise<ArrayBuffer>;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/blob) */
    blob: () => Promise<Blob>;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bytes) */
    bytes(): Promise<Uint8Array>;
}

export function getBinaryResponse(response: ResponseWithBody): BinaryResponse {
    return {
        get bodyUsed() {
            return response.bodyUsed;
        },
        stream: () => response.body,
        arrayBuffer: response.arrayBuffer.bind(response),
        blob: response.blob.bind(response),
        bytes: response.bytes.bind(response),
    };
}

```
</file>
<file path="terra-client-js/src/core/fetcher/Fetcher.ts">
```ts
import { toJson } from "../json.js";
import { APIResponse } from "./APIResponse.js";
import { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
import { Supplier } from "./Supplier.js";
import { createRequestUrl } from "./createRequestUrl.js";
import { getFetchFn } from "./getFetchFn.js";
import { getRequestBody } from "./getRequestBody.js";
import { getResponseBody } from "./getResponseBody.js";
import { makeRequest } from "./makeRequest.js";
import { requestWithRetries } from "./requestWithRetries.js";

export type FetchFunction = <R = unknown>(args: Fetcher.Args) => Promise<APIResponse<R, Fetcher.Error>>;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        contentType?: string;
        headers?: Record<string, string | Supplier<string | undefined> | undefined>;
        queryParameters?: Record<string, string | string[] | object | object[] | null>;
        body?: unknown;
        timeoutMs?: number;
        maxRetries?: number;
        withCredentials?: boolean;
        abortSignal?: AbortSignal;
        requestType?: "json" | "file" | "bytes";
        responseType?: "json" | "blob" | "sse" | "streaming" | "text" | "arrayBuffer" | "binary-response";
        duplex?: "half";
    }

    export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: "status-code";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: "non-json";
        statusCode: number;
        rawBody: string;
    }

    export interface TimeoutError {
        reason: "timeout";
    }

    export interface UnknownError {
        reason: "unknown";
        errorMessage: string;
    }
}

async function getHeaders(args: Fetcher.Args): Promise<Record<string, string>> {
    const newHeaders: Record<string, string> = {};
    if (args.body !== undefined && args.contentType != null) {
        newHeaders["Content-Type"] = args.contentType;
    }

    if (args.headers == null) {
        return newHeaders;
    }

    for (const [key, value] of Object.entries(args.headers)) {
        const result = await Supplier.get(value);
        if (typeof result === "string") {
            newHeaders[key] = result;
            continue;
        }
        if (result == null) {
            continue;
        }
        newHeaders[key] = `${result}`;
    }
    return newHeaders;
}

export async function fetcherImpl<R = unknown>(args: Fetcher.Args): Promise<APIResponse<R, Fetcher.Error>> {
    const url = createRequestUrl(args.url, args.queryParameters);
    const requestBody: BodyInit | undefined = await getRequestBody({
        body: args.body,
        type: args.requestType === "json" ? "json" : "other",
    });
    const fetchFn = await getFetchFn();

    try {
        const response = await requestWithRetries(
            async () =>
                makeRequest(
                    fetchFn,
                    url,
                    args.method,
                    await getHeaders(args),
                    requestBody,
                    args.timeoutMs,
                    args.abortSignal,
                    args.withCredentials,
                    args.duplex,
                ),
            args.maxRetries,
        );
        const responseBody = await getResponseBody(response, args.responseType);

        if (response.status >= 200 && response.status < 400) {
            return {
                ok: true,
                body: responseBody as R,
                headers: response.headers,
                rawResponse: toRawResponse(response),
            };
        } else {
            return {
                ok: false,
                error: {
                    reason: "status-code",
                    statusCode: response.status,
                    body: responseBody,
                },
                rawResponse: toRawResponse(response),
            };
        }
    } catch (error) {
        if (args.abortSignal != null && args.abortSignal.aborted) {
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: "The user aborted a request",
                },
                rawResponse: abortRawResponse,
            };
        } else if (error instanceof Error && error.name === "AbortError") {
            return {
                ok: false,
                error: {
                    reason: "timeout",
                },
                rawResponse: abortRawResponse,
            };
        } else if (error instanceof Error) {
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: error.message,
                },
                rawResponse: unknownRawResponse,
            };
        }

        return {
            ok: false,
            error: {
                reason: "unknown",
                errorMessage: toJson(error),
            },
            rawResponse: unknownRawResponse,
        };
    }
}

export const fetcher: FetchFunction = fetcherImpl;

```
</file>
<file path="terra-client-js/src/core/fetcher/Headers.ts">
```ts
let Headers: typeof globalThis.Headers;

if (typeof globalThis.Headers !== "undefined") {
    Headers = globalThis.Headers;
} else {
    Headers = class Headers implements Headers {
        private headers: Map<string, string[]>;

        constructor(init?: HeadersInit) {
            this.headers = new Map();

            if (init) {
                if (init instanceof Headers) {
                    init.forEach((value, key) => this.append(key, value));
                } else if (Array.isArray(init)) {
                    for (const [key, value] of init) {
                        if (typeof key === "string" && typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Each header entry must be a [string, string] tuple");
                        }
                    }
                } else {
                    for (const [key, value] of Object.entries(init)) {
                        if (typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Header values must be strings");
                        }
                    }
                }
            }
        }

        append(name: string, value: string): void {
            const key = name.toLowerCase();
            const existing = this.headers.get(key) || [];
            this.headers.set(key, [...existing, value]);
        }

        delete(name: string): void {
            const key = name.toLowerCase();
            this.headers.delete(key);
        }

        get(name: string): string | null {
            const key = name.toLowerCase();
            const values = this.headers.get(key);
            return values ? values.join(", ") : null;
        }

        has(name: string): boolean {
            const key = name.toLowerCase();
            return this.headers.has(key);
        }

        set(name: string, value: string): void {
            const key = name.toLowerCase();
            this.headers.set(key, [value]);
        }

        forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: unknown): void {
            const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
            this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
        }

        getSetCookie(): string[] {
            return this.headers.get("set-cookie") || [];
        }

        *entries(): HeadersIterator<[string, string]> {
            for (const [key, values] of this.headers.entries()) {
                yield [key, values.join(", ")];
            }
        }

        *keys(): HeadersIterator<string> {
            yield* this.headers.keys();
        }

        *values(): HeadersIterator<string> {
            for (const values of this.headers.values()) {
                yield values.join(", ");
            }
        }

        [Symbol.iterator](): HeadersIterator<[string, string]> {
            return this.entries();
        }
    };
}

export { Headers };

```
</file>
<file path="terra-client-js/src/core/fetcher/HttpResponsePromise.ts">
```ts
import { WithRawResponse } from "./RawResponse.js";

/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */
export class HttpResponsePromise<T> extends Promise<T> {
    private innerPromise: Promise<WithRawResponse<T>>;
    private unwrappedPromise: Promise<T> | undefined;

    private constructor(promise: Promise<WithRawResponse<T>>) {
        // Initialize with a no-op to avoid premature parsing
        super((resolve) => {
            resolve(undefined as unknown as T);
        });
        this.innerPromise = promise;
    }

    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromFunction<F extends (...args: never[]) => Promise<WithRawResponse<T>>, T>(
        fn: F,
        ...args: Parameters<F>
    ): HttpResponsePromise<T> {
        return new HttpResponsePromise<T>(fn(...args));
    }

    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */
    public static interceptFunction<
        F extends (...args: never[]) => Promise<WithRawResponse<T>>,
        T = Awaited<ReturnType<F>>["data"],
    >(fn: F): (...args: Parameters<F>) => HttpResponsePromise<T> {
        return (...args: Parameters<F>): HttpResponsePromise<T> => {
            return HttpResponsePromise.fromPromise<T>(fn(...args));
        };
    }

    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromPromise<T>(promise: Promise<WithRawResponse<T>>): HttpResponsePromise<T> {
        return new HttpResponsePromise<T>(promise);
    }

    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromExecutor<T>(
        executor: (resolve: (value: WithRawResponse<T>) => void, reject: (reason?: unknown) => void) => void,
    ): HttpResponsePromise<T> {
        const promise = new Promise<WithRawResponse<T>>(executor);
        return new HttpResponsePromise<T>(promise);
    }

    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromResult<T>(result: WithRawResponse<T>): HttpResponsePromise<T> {
        const promise = Promise.resolve(result);
        return new HttpResponsePromise<T>(promise);
    }

    private unwrap(): Promise<T> {
        if (!this.unwrappedPromise) {
            this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
        }
        return this.unwrappedPromise;
    }

    /** @inheritdoc */
    public override then<TResult1 = T, TResult2 = never>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
        onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null,
    ): Promise<TResult1 | TResult2> {
        return this.unwrap().then(onfulfilled, onrejected);
    }

    /** @inheritdoc */
    public override catch<TResult = never>(
        onrejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null,
    ): Promise<T | TResult> {
        return this.unwrap().catch(onrejected);
    }

    /** @inheritdoc */
    public override finally(onfinally?: (() => void) | null): Promise<T> {
        return this.unwrap().finally(onfinally);
    }

    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */
    public async withRawResponse(): Promise<WithRawResponse<T>> {
        return await this.innerPromise;
    }
}

```
</file>
<file path="terra-client-js/src/core/fetcher/RawResponse.ts">
```ts
import { Headers } from "./Headers.js";

/**
 * The raw response from the fetch call excluding the body.
 */
export type RawResponse = Omit<
    {
        [K in keyof Response as Response[K] extends Function ? never : K]: Response[K]; // strips out functions
    },
    "ok" | "body" | "bodyUsed"
>; // strips out body and bodyUsed

/**
 * A raw response indicating that the request was aborted.
 */
export const abortRawResponse: RawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 499,
    statusText: "Client Closed Request",
    type: "error",
    url: "",
} as const;

/**
 * A raw response indicating an unknown error.
 */
export const unknownRawResponse: RawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 0,
    statusText: "Unknown Error",
    type: "error",
    url: "",
} as const;

/**
 * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
 * excluding the `body` and `bodyUsed` fields.
 *
 * @param response - The `RawResponse` object to convert.
 * @returns A `RawResponse` object containing the extracted properties of the input response.
 */
export function toRawResponse(response: Response): RawResponse {
    return {
        headers: response.headers,
        redirected: response.redirected,
        status: response.status,
        statusText: response.statusText,
        type: response.type,
        url: response.url,
    };
}

/**
 * Creates a `RawResponse` from a standard `Response` object.
 */
export interface WithRawResponse<T> {
    readonly data: T;
    readonly rawResponse: RawResponse;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/ResponseWithBody.ts">
```ts
export type ResponseWithBody = Response & {
    body: ReadableStream<Uint8Array>;
};

export function isResponseWithBody(response: Response): response is ResponseWithBody {
    return (response as ResponseWithBody).body != null;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/Supplier.ts">
```ts
export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
    get: async <T>(supplier: Supplier<T>): Promise<T> => {
        if (typeof supplier === "function") {
            return (supplier as () => T)();
        } else {
            return supplier;
        }
    },
};

```
</file>
<file path="terra-client-js/src/core/fetcher/createRequestUrl.ts">
```ts
import qs from "qs";

export function createRequestUrl(
    baseUrl: string,
    queryParameters?: Record<string, string | string[] | object | object[] | null>,
): string {
    return Object.keys(queryParameters ?? {}).length > 0
        ? `${baseUrl}?${qs.stringify(queryParameters, { arrayFormat: "repeat" })}`
        : baseUrl;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/getFetchFn.ts">
```ts
import { RUNTIME } from "../runtime/index.js";

/**
 * Returns a fetch function based on the runtime
 */
export async function getFetchFn(): Promise<any> {
    // In Node.js 18+ environments, use native fetch
    if (RUNTIME.type === "node" && RUNTIME.parsedVersion != null && RUNTIME.parsedVersion >= 18) {
        return fetch;
    }

    // In Node.js 18 or lower environments, the SDK always uses`node-fetch`.
    if (RUNTIME.type === "node") {
        return (await import("node-fetch")).default as any;
    }

    // Otherwise the SDK uses global fetch if available,
    // and falls back to node-fetch.
    if (typeof fetch == "function") {
        return fetch;
    }

    // Defaults to node `node-fetch` if global fetch isn't available
    return (await import("node-fetch")).default as any;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/getHeader.ts">
```ts
export function getHeader(headers: Record<string, any>, header: string): string | undefined {
    for (const [headerKey, headerValue] of Object.entries(headers)) {
        if (headerKey.toLowerCase() === header.toLowerCase()) {
            return headerValue;
        }
    }
    return undefined;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/getRequestBody.ts">
```ts
import { toJson } from "../json.js";

export declare namespace GetRequestBody {
    interface Args {
        body: unknown;
        type: "json" | "file" | "bytes" | "other";
    }
}

export async function getRequestBody({ body, type }: GetRequestBody.Args): Promise<BodyInit | undefined> {
    if (type.includes("json")) {
        return toJson(body);
    } else {
        return body as BodyInit;
    }
}

```
</file>
<file path="terra-client-js/src/core/fetcher/getResponseBody.ts">
```ts
import { getBinaryResponse } from "./BinaryResponse.js";
import { isResponseWithBody } from "./ResponseWithBody.js";

import { chooseStreamWrapper } from "./stream-wrappers/chooseStreamWrapper.js";

export async function getResponseBody(response: Response, responseType?: string): Promise<unknown> {
    if (!isResponseWithBody(response)) {
        return undefined;
    }
    switch (responseType) {
        case "binary-response":
            return getBinaryResponse(response);
        case "blob":
            return await response.blob();
        case "arrayBuffer":
            return await response.arrayBuffer();
        case "sse":
            return response.body;
        case "streaming":
            return chooseStreamWrapper(response.body);

        case "text":
            return await response.text();
    }

    // if responseType is "json" or not specified, try to parse as JSON
    const text = await response.text();
    if (text.length > 0) {
        try {
            let responseBody = JSON.parse(text);
            return responseBody;
        } catch (err) {
            return {
                ok: false,
                error: {
                    reason: "non-json",
                    statusCode: response.status,
                    rawBody: text,
                },
            };
        }
    }
    return undefined;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/index.ts">
```ts
export type { APIResponse } from "./APIResponse.js";
export { fetcher } from "./Fetcher.js";
export type { Fetcher, FetchFunction } from "./Fetcher.js";
export { getHeader } from "./getHeader.js";
export { Supplier } from "./Supplier.js";
export { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
export type { RawResponse, WithRawResponse } from "./RawResponse.js";
export { HttpResponsePromise } from "./HttpResponsePromise.js";
export { BinaryResponse } from "./BinaryResponse.js";

```
</file>
<file path="terra-client-js/src/core/fetcher/makeRequest.ts">
```ts
import { anySignal, getTimeoutSignal } from "./signals.js";

export const makeRequest = async (
    fetchFn: (url: string, init: RequestInit) => Promise<Response>,
    url: string,
    method: string,
    headers: Record<string, string>,
    requestBody: BodyInit | undefined,
    timeoutMs?: number,
    abortSignal?: AbortSignal,
    withCredentials?: boolean,
    duplex?: "half",
): Promise<Response> => {
    const signals: AbortSignal[] = [];

    // Add timeout signal
    let timeoutAbortId: NodeJS.Timeout | undefined = undefined;
    if (timeoutMs != null) {
        const { signal, abortId } = getTimeoutSignal(timeoutMs);
        timeoutAbortId = abortId;
        signals.push(signal);
    }

    // Add arbitrary signal
    if (abortSignal != null) {
        signals.push(abortSignal);
    }
    let newSignals = anySignal(signals);
    const response = await fetchFn(url, {
        method: method,
        headers,
        body: requestBody,
        signal: newSignals,
        credentials: withCredentials ? "include" : undefined,
        // @ts-ignore
        duplex,
    });

    if (timeoutAbortId != null) {
        clearTimeout(timeoutAbortId);
    }

    return response;
};

```
</file>
<file path="terra-client-js/src/core/fetcher/requestWithRetries.ts">
```ts
const INITIAL_RETRY_DELAY = 1000; // in milliseconds
const MAX_RETRY_DELAY = 60000; // in milliseconds
const DEFAULT_MAX_RETRIES = 2;
const JITTER_FACTOR = 0.2; // 20% random jitter

function addJitter(delay: number): number {
    // Generate a random value between -JITTER_FACTOR and +JITTER_FACTOR
    const jitterMultiplier = 1 + (Math.random() * 2 - 1) * JITTER_FACTOR;
    return delay * jitterMultiplier;
}

export async function requestWithRetries(
    requestFn: () => Promise<Response>,
    maxRetries: number = DEFAULT_MAX_RETRIES,
): Promise<Response> {
    let response: Response = await requestFn();

    for (let i = 0; i < maxRetries; ++i) {
        if ([408, 429].includes(response.status) || response.status >= 500) {
            // Calculate base delay using exponential backoff (in milliseconds)
            const baseDelay = Math.min(INITIAL_RETRY_DELAY * Math.pow(2, i), MAX_RETRY_DELAY);

            // Add jitter to the delay
            const delayWithJitter = addJitter(baseDelay);

            await new Promise((resolve) => setTimeout(resolve, delayWithJitter));
            response = await requestFn();
        } else {
            break;
        }
    }
    return response!;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/signals.ts">
```ts
const TIMEOUT = "timeout";

export function getTimeoutSignal(timeoutMs: number): { signal: AbortSignal; abortId: NodeJS.Timeout } {
    const controller = new AbortController();
    const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
    return { signal: controller.signal, abortId };
}

/**
 * Returns an abort signal that is getting aborted when
 * at least one of the specified abort signals is aborted.
 *
 * Requires at least node.js 18.
 */
export function anySignal(...args: AbortSignal[] | [AbortSignal[]]): AbortSignal {
    // Allowing signals to be passed either as array
    // of signals or as multiple arguments.
    const signals = (args.length === 1 && Array.isArray(args[0]) ? args[0] : args) as AbortSignal[];

    const controller = new AbortController();

    for (const signal of signals) {
        if (signal.aborted) {
            // Exiting early if one of the signals
            // is already aborted.
            controller.abort((signal as any)?.reason);
            break;
        }

        // Listening for signals and removing the listeners
        // when at least one symbol is aborted.
        signal.addEventListener("abort", () => controller.abort((signal as any)?.reason), {
            signal: controller.signal,
        });
    }

    return controller.signal;
}

```
</file>
<file path="terra-client-js/src/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper.ts">
```ts
import type { Writable } from "readable-stream";

import { EventCallback, StreamWrapper } from "./chooseStreamWrapper.js";

export class Node18UniversalStreamWrapper<ReadFormat extends Uint8Array | Uint16Array | Uint32Array>
    implements
        StreamWrapper<Node18UniversalStreamWrapper<ReadFormat> | Writable | WritableStream<ReadFormat>, ReadFormat>
{
    private readableStream: ReadableStream<ReadFormat>;
    private reader: ReadableStreamDefaultReader<ReadFormat>;
    private events: Record<string, EventCallback[] | undefined>;
    private paused: boolean;
    private resumeCallback: ((value?: unknown) => void) | null;
    private encoding: string | null;

    constructor(readableStream: ReadableStream<ReadFormat>) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: [],
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }

    public on(event: string, callback: EventCallback): void {
        this.events[event]?.push(callback);
    }

    public off(event: string, callback: EventCallback): void {
        this.events[event] = this.events[event]?.filter((cb) => cb !== callback);
    }

    public pipe(
        dest: Node18UniversalStreamWrapper<ReadFormat> | Writable | WritableStream<ReadFormat>,
    ): Node18UniversalStreamWrapper<ReadFormat> | Writable | WritableStream<ReadFormat> {
        this.on("data", async (chunk) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._write(chunk);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.write(chunk).then(() => writer.releaseLock());
            } else {
                dest.write(chunk);
            }
        });

        this.on("end", async () => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._end();
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.close();
            } else {
                dest.end();
            }
        });

        this.on("error", async (error) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._error(error);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.abort(error);
            } else {
                dest.destroy(error);
            }
        });

        this._startReading();

        return dest;
    }

    public pipeTo(
        dest: Node18UniversalStreamWrapper<ReadFormat> | Writable | WritableStream<ReadFormat>,
    ): Node18UniversalStreamWrapper<ReadFormat> | Writable | WritableStream<ReadFormat> {
        return this.pipe(dest);
    }

    public unpipe(dest: Node18UniversalStreamWrapper<ReadFormat> | Writable | WritableStream<ReadFormat>): void {
        this.off("data", async (chunk) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._write(chunk);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.write(chunk).then(() => writer.releaseLock());
            } else {
                dest.write(chunk);
            }
        });

        this.off("end", async () => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._end();
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.close();
            } else {
                dest.end();
            }
        });

        this.off("error", async (error) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._error(error);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.abort(error);
            } else {
                dest.destroy(error);
            }
        });
    }

    public destroy(error?: Error): void {
        this.reader
            .cancel(error)
            .then(() => {
                this._emit("close");
            })
            .catch((err) => {
                this._emit("error", err);
            });
    }

    public pause(): void {
        this.paused = true;
        this._emit("pause");
    }

    public resume(): void {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }

    public get isPaused(): boolean {
        return this.paused;
    }

    public async read(): Promise<ReadFormat | undefined> {
        if (this.paused) {
            await new Promise((resolve) => {
                this.resumeCallback = resolve;
            });
        }
        const { done, value } = await this.reader.read();

        if (done) {
            return undefined;
        }
        return value;
    }

    public setEncoding(encoding: string): void {
        this.encoding = encoding;
    }

    public async text(): Promise<string> {
        const chunks: ReadFormat[] = [];

        while (true) {
            const { done, value } = await this.reader.read();
            if (done) {
                break;
            }
            if (value) {
                chunks.push(value);
            }
        }

        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(await new Blob(chunks).arrayBuffer());
    }

    public async json<T>(): Promise<T> {
        const text = await this.text();
        return JSON.parse(text);
    }

    private _write(chunk: ReadFormat): void {
        this._emit("data", chunk);
    }

    private _end(): void {
        this._emit("end");
    }

    private _error(error: any): void {
        this._emit("error", error);
    }

    private _emit(event: string, data?: any): void {
        if (this.events[event]) {
            for (const callback of this.events[event] || []) {
                callback(data);
            }
        }
    }

    private async _startReading(): Promise<void> {
        try {
            this._emit("readable");
            while (true) {
                if (this.paused) {
                    await new Promise((resolve) => {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    this._emit("end");
                    this._emit("close");
                    break;
                }
                if (value) {
                    this._emit("data", value);
                }
            }
        } catch (error) {
            this._emit("error", error);
        }
    }

    [Symbol.asyncIterator](): AsyncIterableIterator<ReadFormat> {
        return {
            next: async () => {
                if (this.paused) {
                    await new Promise((resolve) => {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}

```
</file>
<file path="terra-client-js/src/core/fetcher/stream-wrappers/NodePre18StreamWrapper.ts">
```ts
import type { Readable, Writable } from "readable-stream";

import { EventCallback, StreamWrapper } from "./chooseStreamWrapper.js";

export class NodePre18StreamWrapper implements StreamWrapper<Writable, Buffer> {
    private readableStream: Readable;
    private encoding: string | undefined;

    constructor(readableStream: Readable) {
        this.readableStream = readableStream;
    }

    public on(event: string, callback: EventCallback): void {
        this.readableStream.on(event, callback);
    }

    public off(event: string, callback: EventCallback): void {
        this.readableStream.off(event, callback);
    }

    public pipe(dest: Writable): Writable {
        this.readableStream.pipe(dest);
        return dest;
    }

    public pipeTo(dest: Writable): Writable {
        return this.pipe(dest);
    }

    public unpipe(dest?: Writable): void {
        if (dest) {
            this.readableStream.unpipe(dest);
        } else {
            this.readableStream.unpipe();
        }
    }

    public destroy(error?: Error): void {
        this.readableStream.destroy(error);
    }

    public pause(): void {
        this.readableStream.pause();
    }

    public resume(): void {
        this.readableStream.resume();
    }

    public get isPaused(): boolean {
        return this.readableStream.isPaused();
    }

    public async read(): Promise<Buffer | undefined> {
        return new Promise((resolve, reject) => {
            const chunk = this.readableStream.read();
            if (chunk) {
                resolve(chunk);
            } else {
                this.readableStream.once("readable", () => {
                    const chunk = this.readableStream.read();
                    resolve(chunk);
                });
                this.readableStream.once("error", reject);
            }
        });
    }

    public setEncoding(encoding?: string): void {
        this.readableStream.setEncoding(encoding as BufferEncoding);
        this.encoding = encoding;
    }

    public async text(): Promise<string> {
        const chunks: Uint8Array[] = [];
        const encoder = new TextEncoder();
        this.readableStream.setEncoding((this.encoding || "utf-8") as BufferEncoding);

        for await (const chunk of this.readableStream) {
            chunks.push(encoder.encode(chunk));
        }

        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(Buffer.concat(chunks));
    }

    public async json<T>(): Promise<T> {
        const text = await this.text();
        return JSON.parse(text);
    }

    public [Symbol.asyncIterator](): AsyncIterableIterator<Buffer> {
        const readableStream = this.readableStream;
        const iterator = readableStream[Symbol.asyncIterator]();

        // Create and return an async iterator that yields buffers
        return {
            async next(): Promise<IteratorResult<Buffer>> {
                const { value, done } = await iterator.next();
                return { value: value as Buffer, done };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}

```
</file>
<file path="terra-client-js/src/core/fetcher/stream-wrappers/UndiciStreamWrapper.ts">
```ts
import { StreamWrapper } from "./chooseStreamWrapper.js";

type EventCallback = (data?: any) => void;

export class UndiciStreamWrapper<ReadFormat extends Uint8Array | Uint16Array | Uint32Array>
    implements StreamWrapper<UndiciStreamWrapper<ReadFormat> | WritableStream<ReadFormat>, ReadFormat>
{
    private readableStream: ReadableStream<ReadFormat>;
    private reader: ReadableStreamDefaultReader<ReadFormat>;
    private events: Record<string, EventCallback[] | undefined>;
    private paused: boolean;
    private resumeCallback: ((value?: unknown) => void) | null;
    private encoding: string | null;

    constructor(readableStream: ReadableStream<ReadFormat>) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: [],
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }

    public on(event: string, callback: EventCallback): void {
        this.events[event]?.push(callback);
    }

    public off(event: string, callback: EventCallback): void {
        this.events[event] = this.events[event]?.filter((cb) => cb !== callback);
    }

    public pipe(
        dest: UndiciStreamWrapper<ReadFormat> | WritableStream<ReadFormat>,
    ): UndiciStreamWrapper<ReadFormat> | WritableStream<ReadFormat> {
        this.on("data", (chunk) => {
            if (dest instanceof UndiciStreamWrapper) {
                dest._write(chunk);
            } else {
                const writer = dest.getWriter();
                writer.write(chunk).then(() => writer.releaseLock());
            }
        });

        this.on("end", () => {
            if (dest instanceof UndiciStreamWrapper) {
                dest._end();
            } else {
                const writer = dest.getWriter();
                writer.close();
            }
        });

        this.on("error", (error) => {
            if (dest instanceof UndiciStreamWrapper) {
                dest._error(error);
            } else {
                const writer = dest.getWriter();
                writer.abort(error);
            }
        });

        this._startReading();

        return dest;
    }

    public pipeTo(
        dest: UndiciStreamWrapper<ReadFormat> | WritableStream<ReadFormat>,
    ): UndiciStreamWrapper<ReadFormat> | WritableStream<ReadFormat> {
        return this.pipe(dest);
    }

    public unpipe(dest: UndiciStreamWrapper<ReadFormat> | WritableStream): void {
        this.off("data", (chunk) => {
            if (dest instanceof UndiciStreamWrapper) {
                dest._write(chunk);
            } else {
                const writer = dest.getWriter();
                writer.write(chunk).then(() => writer.releaseLock());
            }
        });

        this.off("end", () => {
            if (dest instanceof UndiciStreamWrapper) {
                dest._end();
            } else {
                const writer = dest.getWriter();
                writer.close();
            }
        });

        this.off("error", (error) => {
            if (dest instanceof UndiciStreamWrapper) {
                dest._error(error);
            } else {
                const writer = dest.getWriter();
                writer.abort(error);
            }
        });
    }

    public destroy(error?: Error): void {
        this.reader
            .cancel(error)
            .then(() => {
                this._emit("close");
            })
            .catch((err) => {
                this._emit("error", err);
            });
    }

    public pause(): void {
        this.paused = true;
        this._emit("pause");
    }

    public resume(): void {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }

    public get isPaused(): boolean {
        return this.paused;
    }

    public async read(): Promise<ReadFormat | undefined> {
        if (this.paused) {
            await new Promise((resolve) => {
                this.resumeCallback = resolve;
            });
        }
        const { done, value } = await this.reader.read();
        if (done) {
            return undefined;
        }
        return value;
    }

    public setEncoding(encoding: string): void {
        this.encoding = encoding;
    }

    public async text(): Promise<string> {
        const chunks: BlobPart[] = [];

        while (true) {
            const { done, value } = await this.reader.read();
            if (done) {
                break;
            }
            if (value) {
                chunks.push(value);
            }
        }

        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(await new Blob(chunks).arrayBuffer());
    }

    public async json<T>(): Promise<T> {
        const text = await this.text();
        return JSON.parse(text);
    }

    private _write(chunk: ReadFormat): void {
        this._emit("data", chunk);
    }

    private _end(): void {
        this._emit("end");
    }

    private _error(error: any): void {
        this._emit("error", error);
    }

    private _emit(event: string, data?: any): void {
        if (this.events[event]) {
            for (const callback of this.events[event] || []) {
                callback(data);
            }
        }
    }

    private async _startReading(): Promise<void> {
        try {
            this._emit("readable");
            while (true) {
                if (this.paused) {
                    await new Promise((resolve) => {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    this._emit("end");
                    this._emit("close");
                    break;
                }
                if (value) {
                    this._emit("data", value);
                }
            }
        } catch (error) {
            this._emit("error", error);
        }
    }

    [Symbol.asyncIterator](): AsyncIterableIterator<ReadFormat> {
        return {
            next: async () => {
                if (this.paused) {
                    await new Promise((resolve) => {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}

```
</file>
<file path="terra-client-js/src/core/fetcher/stream-wrappers/chooseStreamWrapper.ts">
```ts
import type { Readable } from "readable-stream";

import { RUNTIME } from "../../runtime/index.js";

export type EventCallback = (data?: any) => void;

export interface StreamWrapper<WritableStream, ReadFormat> {
    setEncoding(encoding?: string): void;
    on(event: string, callback: EventCallback): void;
    off(event: string, callback: EventCallback): void;
    pipe(dest: WritableStream): WritableStream;
    pipeTo(dest: WritableStream): WritableStream;
    unpipe(dest?: WritableStream): void;
    destroy(error?: Error): void;
    pause(): void;
    resume(): void;
    get isPaused(): boolean;
    read(): Promise<ReadFormat | undefined>;
    text(): Promise<string>;
    json<T>(): Promise<T>;
    [Symbol.asyncIterator](): AsyncIterableIterator<ReadFormat>;
}

export async function chooseStreamWrapper(responseBody: any): Promise<Promise<StreamWrapper<any, any>>> {
    if (RUNTIME.type === "node" && RUNTIME.parsedVersion != null && RUNTIME.parsedVersion >= 18) {
        return new (await import("./Node18UniversalStreamWrapper.js")).Node18UniversalStreamWrapper(
            responseBody as ReadableStream,
        );
    } else if (RUNTIME.type !== "node" && typeof fetch === "function") {
        return new (await import("./UndiciStreamWrapper.js")).UndiciStreamWrapper(responseBody as ReadableStream);
    } else {
        return new (await import("./NodePre18StreamWrapper.js")).NodePre18StreamWrapper(responseBody as Readable);
    }
}

```
</file>
<file path="terra-client-js/src/core/headers.ts">
```ts
import * as core from "./index.js";

export function mergeHeaders(
    ...headersArray: (Record<string, string | core.Supplier<string | undefined> | undefined> | undefined)[]
): Record<string, string | core.Supplier<string | undefined>> {
    const result: Record<string, string | core.Supplier<string | undefined>> = {};

    for (const [key, value] of headersArray
        .filter((headers) => headers != null)
        .flatMap((headers) => Object.entries(headers))) {
        if (value != null) {
            result[key] = value;
        } else if (key in result) {
            delete result[key];
        }
    }

    return result;
}

export function mergeOnlyDefinedHeaders(
    ...headersArray: (Record<string, string | core.Supplier<string | undefined> | undefined> | undefined)[]
): Record<string, string | core.Supplier<string | undefined>> {
    const result: Record<string, string | core.Supplier<string | undefined>> = {};

    for (const [key, value] of headersArray
        .filter((headers) => headers != null)
        .flatMap((headers) => Object.entries(headers))) {
        if (value != null) {
            result[key] = value;
        }
    }

    return result;
}

```
</file>
<file path="terra-client-js/src/core/index.ts">
```ts
export * from "./fetcher/index.js";
export * from "./runtime/index.js";

```
</file>
<file path="terra-client-js/src/core/json.ts">
```ts
/**
 * Serialize a value to JSON
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @returns JSON string
 */
export const toJson = (
    value: unknown,
    replacer?: (this: unknown, key: string, value: unknown) => unknown,
    space?: string | number,
): string => {
    return JSON.stringify(value, replacer, space);
};

/**
 * Parse JSON string to object, array, or other type
 * @param text A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
 * @returns Parsed object, array, or other type
 */
export function fromJson<T = unknown>(
    text: string,
    reviver?: (this: unknown, key: string, value: unknown) => unknown,
): T {
    return JSON.parse(text, reviver);
}

```
</file>
<file path="terra-client-js/src/core/runtime/index.ts">
```ts
export { RUNTIME } from "./runtime.js";

```
</file>
<file path="terra-client-js/src/core/runtime/runtime.ts">
```ts
interface DenoGlobal {
    version: {
        deno: string;
    };
}

interface BunGlobal {
    version: string;
}

declare const Deno: DenoGlobal | undefined;
declare const Bun: BunGlobal | undefined;
declare const EdgeRuntime: string | undefined;
declare const self: typeof globalThis.self & {
    importScripts?: unknown;
};

/**
 * A constant that indicates which environment and version the SDK is running in.
 */
export const RUNTIME: Runtime = evaluateRuntime();

export interface Runtime {
    type: "browser" | "web-worker" | "deno" | "bun" | "node" | "react-native" | "unknown" | "workerd" | "edge-runtime";
    version?: string;
    parsedVersion?: number;
}

function evaluateRuntime(): Runtime {
    /**
     * A constant that indicates whether the environment the code is running is a Web Browser.
     */
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    if (isBrowser) {
        return {
            type: "browser",
            version: window.navigator.userAgent,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Cloudflare.
     * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
     */
    const isCloudflare = typeof globalThis !== "undefined" && globalThis?.navigator?.userAgent === "Cloudflare-Workers";
    if (isCloudflare) {
        return {
            type: "workerd",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Edge Runtime.
     * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
     */
    const isEdgeRuntime = typeof EdgeRuntime === "string";
    if (isEdgeRuntime) {
        return {
            type: "edge-runtime",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */
    const isWebWorker =
        typeof self === "object" &&
        typeof self?.importScripts === "function" &&
        (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
            self.constructor?.name === "ServiceWorkerGlobalScope" ||
            self.constructor?.name === "SharedWorkerGlobalScope");
    if (isWebWorker) {
        return {
            type: "web-worker",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Deno.
     * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
     */
    const isDeno =
        typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    if (isDeno) {
        return {
            type: "deno",
            version: Deno.version.deno,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */
    const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    if (isBun) {
        return {
            type: "bun",
            version: Bun.version,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Node.JS.
     */
    const isNode =
        typeof process !== "undefined" &&
        "version" in process &&
        !!process.version &&
        "versions" in process &&
        !!process.versions?.node;
    if (isNode) {
        return {
            type: "node",
            version: process.versions.node,
            parsedVersion: Number(process.versions.node.split(".")[0]),
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is in React-Native.
     * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
     */
    const isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
    if (isReactNative) {
        return {
            type: "react-native",
        };
    }

    return {
        type: "unknown",
    };
}

```
</file>
<file path="terra-client-js/src/environments.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export const TerraEnvironment = {
    Default: "https://api.tryterra.co/v2",
} as const;

export type TerraEnvironment = typeof TerraEnvironment.Default;

```
</file>
<file path="terra-client-js/src/errors/TerraError.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../core/index.js";
import { toJson } from "../core/json.js";

export class TerraError extends Error {
    public readonly statusCode?: number;
    public readonly body?: unknown;
    public readonly rawResponse?: core.RawResponse;

    constructor({
        message,
        statusCode,
        body,
        rawResponse,
    }: {
        message?: string;
        statusCode?: number;
        body?: unknown;
        rawResponse?: core.RawResponse;
    }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, TerraError.prototype);
        this.statusCode = statusCode;
        this.body = body;
        this.rawResponse = rawResponse;
    }
}

function buildMessage({
    message,
    statusCode,
    body,
}: {
    message: string | undefined;
    statusCode: number | undefined;
    body: unknown | undefined;
}): string {
    let lines: string[] = [];
    if (message != null) {
        lines.push(message);
    }

    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }

    if (body != null) {
        lines.push(`Body: ${toJson(body, undefined, 2)}`);
    }

    return lines.join("\n");
}

```
</file>
<file path="terra-client-js/src/errors/TerraTimeoutError.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class TerraTimeoutError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, TerraTimeoutError.prototype);
    }
}

```
</file>
<file path="terra-client-js/src/errors/index.ts">
```ts
export { TerraError } from "./TerraError.js";
export { TerraTimeoutError } from "./TerraTimeoutError.js";

```
</file>
<file path="terra-client-js/src/index.ts">
```ts
export * as Terra from "./api/index.js";
export { TerraError, TerraTimeoutError } from "./errors/index.js";
export { TerraClient } from "./Client.js";
export { TerraEnvironment } from "./environments.js";

```
</file>
<file path="terra-client-js/src/version.ts">
```ts
export const SDK_VERSION = "2.0.2";

```
</file>
<file path="terra-client-js/tests/custom.test.ts">
```ts
/**
 * This is a custom test file, if you wish to add more tests
 * to your SDK.
 * Be sure to mark this file in `.fernignore`.
 *
 * If you include example requests/responses in your fern definition,
 * you will have tests automatically generated for you.
 */
describe("test", () => {
    it("default", () => {
        expect(true).toBe(true);
    });
});

```
</file>
<file path="terra-client-js/tests/mock-server/MockServer.ts">
```ts
import { RequestHandlerOptions } from "msw";
import type { SetupServer } from "msw/node";

import { mockEndpointBuilder } from "./mockEndpointBuilder";

export interface MockServerOptions {
    baseUrl: string;
    server: SetupServer;
}

export class MockServer {
    private readonly server: SetupServer;
    public readonly baseUrl: string;

    constructor({ baseUrl, server }: MockServerOptions) {
        this.baseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
        this.server = server;
    }

    public mockEndpoint(options?: RequestHandlerOptions): ReturnType<typeof mockEndpointBuilder> {
        const builder = mockEndpointBuilder({
            once: options?.once,
            onBuild: (handler) => {
                this.server.use(handler);
            },
        }).baseUrl(this.baseUrl);
        return builder;
    }
}

```
</file>
<file path="terra-client-js/tests/mock-server/MockServerPool.ts">
```ts
import { setupServer } from "msw/node";

import { fromJson, toJson } from "../../src/core/json";
import { MockServer } from "./MockServer";
import { randomBaseUrl } from "./randomBaseUrl";

const mswServer = setupServer();
interface MockServerOptions {
    baseUrl?: string;
}

async function formatHttpRequest(request: Request, id?: string): Promise<string> {
    try {
        const clone = request.clone();
        const headers = [...clone.headers.entries()].map(([k, v]) => `${k}: ${v}`).join("\n");

        let body = "";
        try {
            const contentType = clone.headers.get("content-type");
            if (contentType?.includes("application/json")) {
                body = toJson(fromJson(await clone.text()), undefined, 2);
            } else if (clone.body) {
                body = await clone.text();
            }
        } catch (e) {
            body = "(unable to parse body)";
        }

        const title = id ? `### Request ${id} ###\n` : "";
        const firstLine = `${title}${request.method} ${request.url.toString()} HTTP/1.1`;

        return `\n${firstLine}\n${headers}\n\n${body || "(no body)"}\n`;
    } catch (e) {
        return `Error formatting request: ${e}`;
    }
}

async function formatHttpResponse(response: Response, id?: string): Promise<string> {
    try {
        const clone = response.clone();
        const headers = [...clone.headers.entries()].map(([k, v]) => `${k}: ${v}`).join("\n");

        let body = "";
        try {
            const contentType = clone.headers.get("content-type");
            if (contentType?.includes("application/json")) {
                body = toJson(fromJson(await clone.text()), undefined, 2);
            } else if (clone.body) {
                body = await clone.text();
            }
        } catch (e) {
            body = "(unable to parse body)";
        }

        const title = id ? `### Response for ${id} ###\n` : "";
        const firstLine = `${title}HTTP/1.1 ${response.status} ${response.statusText}`;

        return `\n${firstLine}\n${headers}\n\n${body || "(no body)"}\n`;
    } catch (e) {
        return `Error formatting response: ${e}`;
    }
}

class MockServerPool {
    private servers: MockServer[] = [];

    public createServer(options?: Partial<MockServerOptions>): MockServer {
        const baseUrl = options?.baseUrl || randomBaseUrl();
        const server = new MockServer({ baseUrl, server: mswServer });
        this.servers.push(server);
        return server;
    }

    public getServers(): MockServer[] {
        return [...this.servers];
    }

    public listen(): void {
        const onUnhandledRequest = process.env.LOG_LEVEL === "debug" ? "warn" : "bypass";
        mswServer.listen({ onUnhandledRequest });

        if (process.env.LOG_LEVEL === "debug") {
            mswServer.events.on("request:start", async ({ request, requestId }) => {
                const formattedRequest = await formatHttpRequest(request, requestId);
                console.debug("request:start\n" + formattedRequest);
            });

            mswServer.events.on("request:unhandled", async ({ request, requestId }) => {
                const formattedRequest = await formatHttpRequest(request, requestId);
                console.debug("request:unhandled\n" + formattedRequest);
            });

            mswServer.events.on("response:mocked", async ({ request, response, requestId }) => {
                const formattedResponse = await formatHttpResponse(response, requestId);
                console.debug("response:mocked\n" + formattedResponse);
            });
        }
    }

    public close(): void {
        this.servers = [];
        mswServer.close();
    }
}

export const mockServerPool = new MockServerPool();

```
</file>
<file path="terra-client-js/tests/mock-server/mockEndpointBuilder.ts">
```ts
import { DefaultBodyType, HttpHandler, HttpResponse, HttpResponseResolver, http } from "msw";

import { toJson } from "../../src/core/json";
import { withHeaders } from "./withHeaders";
import { withJson } from "./withJson";

type HttpMethod = "all" | "get" | "post" | "put" | "delete" | "patch" | "options" | "head";

interface MethodStage {
    baseUrl(baseUrl: string): MethodStage;
    all(path: string): RequestHeadersStage;
    get(path: string): RequestHeadersStage;
    post(path: string): RequestHeadersStage;
    put(path: string): RequestHeadersStage;
    delete(path: string): RequestHeadersStage;
    patch(path: string): RequestHeadersStage;
    options(path: string): RequestHeadersStage;
    head(path: string): RequestHeadersStage;
}

interface RequestHeadersStage extends RequestBodyStage, ResponseStage {
    header(name: string, value: string): RequestHeadersStage;
    headers(headers: Record<string, string>): RequestBodyStage;
}

interface RequestBodyStage extends ResponseStage {
    jsonBody(body: unknown): ResponseStage;
}

interface ResponseStage {
    respondWith(): ResponseStatusStage;
}
interface ResponseStatusStage {
    statusCode(statusCode: number): ResponseHeaderStage;
}

interface ResponseHeaderStage extends ResponseBodyStage, BuildStage {
    header(name: string, value: string): ResponseHeaderStage;
    headers(headers: Record<string, string>): ResponseHeaderStage;
}

interface ResponseBodyStage {
    jsonBody(body: unknown): BuildStage;
}

interface BuildStage {
    build(): HttpHandler;
}

export interface HttpHandlerBuilderOptions {
    onBuild?: (handler: HttpHandler) => void;
    once?: boolean;
}

class RequestBuilder implements MethodStage, RequestHeadersStage, RequestBodyStage, ResponseStage {
    private method: HttpMethod = "get";
    private _baseUrl: string = "";
    private path: string = "/";
    private readonly predicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[] = [];
    private readonly handlerOptions?: HttpHandlerBuilderOptions;

    constructor(options?: HttpHandlerBuilderOptions) {
        this.handlerOptions = options;
    }

    baseUrl(baseUrl: string): MethodStage {
        this._baseUrl = baseUrl;
        return this;
    }

    all(path: string): RequestHeadersStage {
        this.method = "all";
        this.path = path;
        return this;
    }

    get(path: string): RequestHeadersStage {
        this.method = "get";
        this.path = path;
        return this;
    }

    post(path: string): RequestHeadersStage {
        this.method = "post";
        this.path = path;
        return this;
    }

    put(path: string): RequestHeadersStage {
        this.method = "put";
        this.path = path;
        return this;
    }

    delete(path: string): RequestHeadersStage {
        this.method = "delete";
        this.path = path;
        return this;
    }

    patch(path: string): RequestHeadersStage {
        this.method = "patch";
        this.path = path;
        return this;
    }

    options(path: string): RequestHeadersStage {
        this.method = "options";
        this.path = path;
        return this;
    }

    head(path: string): RequestHeadersStage {
        this.method = "head";
        this.path = path;
        return this;
    }

    header(name: string, value: string): RequestHeadersStage {
        this.predicates.push((resolver) => withHeaders({ [name]: value }, resolver));
        return this;
    }

    headers(headers: Record<string, string>): RequestBodyStage {
        this.predicates.push((resolver) => withHeaders(headers, resolver));
        return this;
    }

    jsonBody(body: unknown): ResponseStage {
        this.predicates.push((resolver) => withJson(body, resolver));
        return this;
    }

    respondWith(): ResponseStatusStage {
        return new ResponseBuilder(this.method, this.buildPath(), this.predicates, this.handlerOptions);
    }

    private buildPath(): string {
        if (this._baseUrl.endsWith("/") && this.path.startsWith("/")) {
            return this._baseUrl + this.path.slice(1);
        }
        if (!this._baseUrl.endsWith("/") && !this.path.startsWith("/")) {
            return this._baseUrl + "/" + this.path;
        }
        return this._baseUrl + this.path;
    }
}

class ResponseBuilder implements ResponseStatusStage, ResponseHeaderStage, ResponseBodyStage, BuildStage {
    private readonly method: HttpMethod;
    private readonly path: string;
    private readonly requestPredicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[];
    private readonly handlerOptions?: HttpHandlerBuilderOptions;

    private responseStatusCode: number = 200;
    private responseHeaders: Record<string, string> = {};
    private responseBody: DefaultBodyType = undefined;

    constructor(
        method: HttpMethod,
        path: string,
        requestPredicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[],
        options?: HttpHandlerBuilderOptions,
    ) {
        this.method = method;
        this.path = path;
        this.requestPredicates = requestPredicates;
        this.handlerOptions = options;
    }

    public statusCode(code: number): ResponseHeaderStage {
        this.responseStatusCode = code;
        return this;
    }

    public header(name: string, value: string): ResponseHeaderStage {
        this.responseHeaders[name] = value;
        return this;
    }

    public headers(headers: Record<string, string>): ResponseHeaderStage {
        this.responseHeaders = { ...this.responseHeaders, ...headers };
        return this;
    }

    public jsonBody(body: unknown): BuildStage {
        this.responseBody = toJson(body);
        return this;
    }

    public build(): HttpHandler {
        const responseResolver: HttpResponseResolver = () => {
            return new HttpResponse(this.responseBody, {
                status: this.responseStatusCode,
                headers: this.responseHeaders,
            });
        };

        const finalResolver = this.requestPredicates.reduceRight((acc, predicate) => predicate(acc), responseResolver);

        const handler = http[this.method](this.path, finalResolver, this.handlerOptions);
        this.handlerOptions?.onBuild?.(handler);
        return handler;
    }
}

export function mockEndpointBuilder(options?: HttpHandlerBuilderOptions): MethodStage {
    return new RequestBuilder(options);
}

```
</file>
<file path="terra-client-js/tests/mock-server/randomBaseUrl.ts">
```ts
export function randomBaseUrl(): string {
    const randomString = Math.random().toString(36).substring(2, 15);
    return `http://${randomString}.localhost`;
}

```
</file>
<file path="terra-client-js/tests/mock-server/setup.ts">
```ts
import { afterAll, beforeAll } from "@jest/globals";

import { mockServerPool } from "./MockServerPool";

beforeAll(() => {
    mockServerPool.listen();
});
afterAll(() => {
    mockServerPool.close();
});

```
</file>
<file path="terra-client-js/tests/mock-server/withHeaders.ts">
```ts
import { HttpResponseResolver, passthrough } from "msw";

/**
 * Creates a request matcher that validates if request headers match specified criteria
 * @param expectedHeaders - Headers to match against
 * @param resolver - Response resolver to execute if headers match
 */
export function withHeaders(
    expectedHeaders: Record<string, string | RegExp | ((value: string) => boolean)>,
    resolver: HttpResponseResolver,
): HttpResponseResolver {
    return (args) => {
        const { request } = args;
        const { headers } = request;

        const mismatches: Record<
            string,
            { actual: string | null; expected: string | RegExp | ((value: string) => boolean) }
        > = {};

        for (const [key, expectedValue] of Object.entries(expectedHeaders)) {
            const actualValue = headers.get(key);

            if (actualValue === null) {
                mismatches[key] = { actual: null, expected: expectedValue };
                continue;
            }

            if (typeof expectedValue === "function") {
                if (!expectedValue(actualValue)) {
                    mismatches[key] = { actual: actualValue, expected: expectedValue };
                }
            } else if (expectedValue instanceof RegExp) {
                if (!expectedValue.test(actualValue)) {
                    mismatches[key] = { actual: actualValue, expected: expectedValue };
                }
            } else if (expectedValue !== actualValue) {
                mismatches[key] = { actual: actualValue, expected: expectedValue };
            }
        }

        if (Object.keys(mismatches).length > 0) {
            const formattedMismatches = formatHeaderMismatches(mismatches);
            console.error("Header mismatch:", formattedMismatches);
            return passthrough();
        }

        return resolver(args);
    };
}

function formatHeaderMismatches(
    mismatches: Record<string, { actual: string | null; expected: string | RegExp | ((value: string) => boolean) }>,
): Record<string, { actual: string | null; expected: string }> {
    const formatted: Record<string, { actual: string | null; expected: string }> = {};

    for (const [key, { actual, expected }] of Object.entries(mismatches)) {
        formatted[key] = {
            actual,
            expected:
                expected instanceof RegExp
                    ? expected.toString()
                    : typeof expected === "function"
                      ? "[Function]"
                      : expected,
        };
    }

    return formatted;
}

```
</file>
<file path="terra-client-js/tests/mock-server/withJson.ts">
```ts
import { HttpResponseResolver, passthrough } from "msw";

import { fromJson, toJson } from "../../src/core/json";

/**
 * Creates a request matcher that validates if the request JSON body exactly matches the expected object
 * @param expectedBody - The exact body object to match against
 * @param resolver - Response resolver to execute if body matches
 */
export function withJson(expectedBody: unknown, resolver: HttpResponseResolver): HttpResponseResolver {
    return async (args) => {
        const { request } = args;

        let clonedRequest: Request;
        let actualBody: unknown;
        try {
            clonedRequest = request.clone();
            actualBody = fromJson(await clonedRequest.text());
        } catch (error) {
            console.error("Error processing request body:", error);
            return passthrough();
        }

        const mismatches = findMismatches(actualBody, expectedBody);
        if (Object.keys(mismatches).length > 0) {
            console.error("JSON body mismatch:", toJson(mismatches, undefined, 2));
            return passthrough();
        }

        return resolver(args);
    };
}

function findMismatches(actual: any, expected: any): Record<string, { actual: any; expected: any }> {
    const mismatches: Record<string, { actual: any; expected: any }> = {};

    if (typeof actual !== typeof expected) {
        if (areEquivalent(actual, expected)) {
            return {};
        }
        return { value: { actual, expected } };
    }

    if (typeof actual !== "object" || actual === null || expected === null) {
        if (actual !== expected) {
            if (areEquivalent(actual, expected)) {
                return {};
            }
            return { value: { actual, expected } };
        }
        return {};
    }

    if (Array.isArray(actual) && Array.isArray(expected)) {
        if (actual.length !== expected.length) {
            return { length: { actual: actual.length, expected: expected.length } };
        }

        const arrayMismatches: Record<string, { actual: any; expected: any }> = {};
        for (let i = 0; i < actual.length; i++) {
            const itemMismatches = findMismatches(actual[i], expected[i]);
            if (Object.keys(itemMismatches).length > 0) {
                for (const [mismatchKey, mismatchValue] of Object.entries(itemMismatches)) {
                    arrayMismatches[`[${i}]${mismatchKey === "value" ? "" : "." + mismatchKey}`] = mismatchValue;
                }
            }
        }
        return arrayMismatches;
    }

    const actualKeys = Object.keys(actual);
    const expectedKeys = Object.keys(expected);

    const allKeys = new Set([...actualKeys, ...expectedKeys]);

    for (const key of allKeys) {
        if (!expectedKeys.includes(key)) {
            mismatches[key] = { actual: actual[key], expected: undefined };
        } else if (!actualKeys.includes(key)) {
            mismatches[key] = { actual: undefined, expected: expected[key] };
        } else if (
            typeof actual[key] === "object" &&
            actual[key] !== null &&
            typeof expected[key] === "object" &&
            expected[key] !== null
        ) {
            const nestedMismatches = findMismatches(actual[key], expected[key]);
            if (Object.keys(nestedMismatches).length > 0) {
                for (const [nestedKey, nestedValue] of Object.entries(nestedMismatches)) {
                    mismatches[`${key}${nestedKey === "value" ? "" : "." + nestedKey}`] = nestedValue;
                }
            }
        } else if (actual[key] !== expected[key]) {
            if (areEquivalent(actual[key], expected[key])) {
                continue;
            }
            mismatches[key] = { actual: actual[key], expected: expected[key] };
        }
    }

    return mismatches;
}

function areEquivalent(actual: unknown, expected: unknown): boolean {
    if (actual === expected) {
        return true;
    }
    if (isEquivalentBigInt(actual, expected)) {
        return true;
    }
    if (isEquivalentDatetime(actual, expected)) {
        return true;
    }
    return false;
}

function isEquivalentBigInt(actual: unknown, expected: unknown) {
    if (typeof actual === "number") {
        actual = BigInt(actual);
    }
    if (typeof expected === "number") {
        expected = BigInt(expected);
    }
    if (typeof actual === "bigint" && typeof expected === "bigint") {
        return actual === expected;
    }
    return false;
}

function isEquivalentDatetime(str1: unknown, str2: unknown): boolean {
    if (typeof str1 !== "string" || typeof str2 !== "string") {
        return false;
    }
    const isoDatePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?Z$/;
    if (!isoDatePattern.test(str1) || !isoDatePattern.test(str2)) {
        return false;
    }

    try {
        const date1 = new Date(str1).getTime();
        const date2 = new Date(str2).getTime();
        return date1 === date2;
    } catch {
        return false;
    }
}

```
</file>
<file path="terra-client-js/tests/unit/fetcher/Fetcher.test.ts">
```ts
import fs from "fs";
import stream from "stream";
import { join } from "path";

import { Fetcher, fetcherImpl } from "../../../src/core/fetcher/Fetcher";
import { BinaryResponse } from "../../../src/core";

describe("Test fetcherImpl", () => {
    it("should handle successful request", async () => {
        const mockArgs: Fetcher.Args = {
            url: "https://httpbin.org/post",
            method: "POST",
            headers: { "X-Test": "x-test-header" },
            body: { data: "test" },
            contentType: "application/json",
            requestType: "json",
            responseType: "json",
        };

        global.fetch = jest.fn().mockResolvedValue(
            new Response(JSON.stringify({ data: "test" }), {
                status: 200,
                statusText: "OK",
            }),
        );

        const result = await fetcherImpl(mockArgs);
        expect(result.ok).toBe(true);
        if (result.ok) {
            expect(result.body).toEqual({ data: "test" });
        }

        expect(global.fetch).toHaveBeenCalledWith(
            "https://httpbin.org/post",
            expect.objectContaining({
                method: "POST",
                headers: expect.objectContaining({ "X-Test": "x-test-header" }),
                body: JSON.stringify({ data: "test" }),
            }),
        );
    });

    it("should send octet stream", async () => {
        const url = "https://httpbin.org/post/file";
        const mockArgs: Fetcher.Args = {
            url,
            method: "POST",
            headers: { "X-Test": "x-test-header" },
            contentType: "application/octet-stream",
            requestType: "bytes",
            responseType: "json",
            body: fs.createReadStream(join(__dirname, "test-file.txt")),
        };

        global.fetch = jest.fn().mockResolvedValue(
            new Response(JSON.stringify({ data: "test" }), {
                status: 200,
                statusText: "OK",
            }),
        );

        const result = await fetcherImpl(mockArgs);

        expect(global.fetch).toHaveBeenCalledWith(
            url,
            expect.objectContaining({
                method: "POST",
                headers: expect.objectContaining({ "X-Test": "x-test-header" }),
                body: expect.any(fs.ReadStream),
            }),
        );
        expect(result.ok).toBe(true);
        if (result.ok) {
            expect(result.body).toEqual({ data: "test" });
        }
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/HttpResponsePromise.test.ts">
```ts
import { beforeEach, describe, expect, it, jest } from "@jest/globals";

import { HttpResponsePromise } from "../../../src/core/fetcher/HttpResponsePromise";
import { RawResponse, WithRawResponse } from "../../../src/core/fetcher/RawResponse";

describe("HttpResponsePromise", () => {
    const mockRawResponse: RawResponse = {
        headers: new Headers(),
        redirected: false,
        status: 200,
        statusText: "OK",
        type: "basic" as ResponseType,
        url: "https://example.com",
    };
    const mockData = { id: "123", name: "test" };
    const mockWithRawResponse: WithRawResponse<typeof mockData> = {
        data: mockData,
        rawResponse: mockRawResponse,
    };

    describe("fromFunction", () => {
        it("should create an HttpResponsePromise from a function", async () => {
            const mockFn = jest
                .fn<(arg1: string, arg2: string) => Promise<WithRawResponse<typeof mockData>>>()
                .mockResolvedValue(mockWithRawResponse);

            const responsePromise = HttpResponsePromise.fromFunction(mockFn, "arg1", "arg2");

            const result = await responsePromise;
            expect(result).toEqual(mockData);
            expect(mockFn).toHaveBeenCalledWith("arg1", "arg2");

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("fromPromise", () => {
        it("should create an HttpResponsePromise from a promise", async () => {
            const promise = Promise.resolve(mockWithRawResponse);

            const responsePromise = HttpResponsePromise.fromPromise(promise);

            const result = await responsePromise;
            expect(result).toEqual(mockData);

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("fromExecutor", () => {
        it("should create an HttpResponsePromise from an executor function", async () => {
            const responsePromise = HttpResponsePromise.fromExecutor((resolve) => {
                resolve(mockWithRawResponse);
            });

            const result = await responsePromise;
            expect(result).toEqual(mockData);

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("fromResult", () => {
        it("should create an HttpResponsePromise from a result", async () => {
            const responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);

            const result = await responsePromise;
            expect(result).toEqual(mockData);

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("Promise methods", () => {
        let responsePromise: HttpResponsePromise<typeof mockData>;

        beforeEach(() => {
            responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);
        });

        it("should support then() method", async () => {
            const result = await responsePromise.then((data) => ({
                ...data,
                modified: true,
            }));

            expect(result).toEqual({
                ...mockData,
                modified: true,
            });
        });

        it("should support catch() method", async () => {
            const errorResponsePromise = HttpResponsePromise.fromExecutor((_, reject) => {
                reject(new Error("Test error"));
            });

            const catchSpy = jest.fn();
            await errorResponsePromise.catch(catchSpy);

            expect(catchSpy).toHaveBeenCalled();
            const error = catchSpy.mock.calls[0]?.[0];
            expect(error).toBeInstanceOf(Error);
            expect((error as Error).message).toBe("Test error");
        });

        it("should support finally() method", async () => {
            const finallySpy = jest.fn();
            await responsePromise.finally(finallySpy);

            expect(finallySpy).toHaveBeenCalled();
        });
    });

    describe("withRawResponse", () => {
        it("should return both data and raw response", async () => {
            const responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);

            const result = await responsePromise.withRawResponse();

            expect(result).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/RawResponse.test.ts">
```ts
import { describe, expect, it } from "@jest/globals";

import { toRawResponse } from "../../../src/core/fetcher/RawResponse";

describe("RawResponse", () => {
    describe("toRawResponse", () => {
        it("should convert Response to RawResponse by removing body, bodyUsed, and ok properties", () => {
            const mockHeaders = new Headers({ "content-type": "application/json" });
            const mockResponse = {
                body: "test body",
                bodyUsed: false,
                ok: true,
                headers: mockHeaders,
                redirected: false,
                status: 200,
                statusText: "OK",
                type: "basic" as ResponseType,
                url: "https://example.com",
            };

            const result = toRawResponse(mockResponse as unknown as Response);

            expect("body" in result).toBe(false);
            expect("bodyUsed" in result).toBe(false);
            expect("ok" in result).toBe(false);
            expect(result.headers).toBe(mockHeaders);
            expect(result.redirected).toBe(false);
            expect(result.status).toBe(200);
            expect(result.statusText).toBe("OK");
            expect(result.type).toBe("basic");
            expect(result.url).toBe("https://example.com");
        });
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/createRequestUrl.test.ts">
```ts
import { createRequestUrl } from "../../../src/core/fetcher/createRequestUrl";

describe("Test createRequestUrl", () => {
    it("should return the base URL when no query parameters are provided", () => {
        const baseUrl = "https://api.example.com";
        expect(createRequestUrl(baseUrl)).toBe(baseUrl);
    });

    it("should append simple query parameters", () => {
        const baseUrl = "https://api.example.com";
        const queryParams = { key: "value", another: "param" };
        expect(createRequestUrl(baseUrl, queryParams)).toBe("https://api.example.com?key=value&another=param");
    });

    it("should handle array query parameters", () => {
        const baseUrl = "https://api.example.com";
        const queryParams = { items: ["a", "b", "c"] };
        expect(createRequestUrl(baseUrl, queryParams)).toBe("https://api.example.com?items=a&items=b&items=c");
    });

    it("should handle object query parameters", () => {
        const baseUrl = "https://api.example.com";
        const queryParams = { filter: { name: "John", age: 30 } };
        expect(createRequestUrl(baseUrl, queryParams)).toBe(
            "https://api.example.com?filter%5Bname%5D=John&filter%5Bage%5D=30",
        );
    });

    it("should handle mixed types of query parameters", () => {
        const baseUrl = "https://api.example.com";
        const queryParams = {
            simple: "value",
            array: ["x", "y"],
            object: { key: "value" },
        };
        expect(createRequestUrl(baseUrl, queryParams)).toBe(
            "https://api.example.com?simple=value&array=x&array=y&object%5Bkey%5D=value",
        );
    });

    it("should handle empty query parameters object", () => {
        const baseUrl = "https://api.example.com";
        expect(createRequestUrl(baseUrl, {})).toBe(baseUrl);
    });

    it("should encode special characters in query parameters", () => {
        const baseUrl = "https://api.example.com";
        const queryParams = { special: "a&b=c d" };
        expect(createRequestUrl(baseUrl, queryParams)).toBe("https://api.example.com?special=a%26b%3Dc%20d");
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/getFetchFn.test.ts">
```ts
import { getFetchFn } from "../../../src/core/fetcher/getFetchFn";
import { RUNTIME } from "../../../src/core/runtime";

describe("Test for getFetchFn", () => {
    it("should get node-fetch function", async () => {
        if (RUNTIME.type == "node") {
            if (RUNTIME.parsedVersion != null && RUNTIME.parsedVersion >= 18) {
                expect(await getFetchFn()).toBe(fetch);
            } else {
                expect(await getFetchFn()).toEqual((await import("node-fetch")).default as any);
            }
        }
    });

    it("should get fetch function", async () => {
        if (RUNTIME.type == "browser") {
            const fetchFn = await getFetchFn();
            expect(typeof fetchFn).toBe("function");
            expect(fetchFn.name).toBe("fetch");
        }
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/getRequestBody.test.ts">
```ts
import { getRequestBody } from "../../../src/core/fetcher/getRequestBody";
import { RUNTIME } from "../../../src/core/runtime";

describe("Test getRequestBody", () => {
    it("should return FormData as is in Node environment", async () => {
        if (RUNTIME.type === "node") {
            const formData = new (await import("formdata-node")).FormData();
            formData.append("key", "value");
            const result = await getRequestBody({
                body: formData,
                type: "file",
            });
            expect(result).toBe(formData);
        }
    });

    it("should stringify body if not FormData in Node environment", async () => {
        if (RUNTIME.type === "node") {
            const body = { key: "value" };
            const result = await getRequestBody({
                body,
                type: "json",
            });
            expect(result).toBe('{"key":"value"}');
        }
    });

    it("should return FormData in browser environment", async () => {
        if (RUNTIME.type === "browser") {
            const formData = new (await import("form-data")).default();
            formData.append("key", "value");
            const result = await getRequestBody({
                body: formData,
                type: "file",
            });
            expect(result).toBe(formData);
        }
    });

    it("should stringify body if not FormData in browser environment", async () => {
        if (RUNTIME.type === "browser") {
            const body = { key: "value" };
            const result = await getRequestBody({
                body,
                type: "json",
            });
            expect(result).toBe('{"key":"value"}');
        }
    });

    it("should return the Uint8Array", async () => {
        const input = new Uint8Array([1, 2, 3]);
        const result = await getRequestBody({
            body: input,
            type: "bytes",
        });
        expect(result).toBe(input);
    });

    it("should return the input for content-type 'application/x-www-form-urlencoded'", async () => {
        const input = "key=value&another=param";
        const result = await getRequestBody({
            body: input,
            type: "other",
        });
        expect(result).toBe(input);
    });

    it("should JSON stringify objects", async () => {
        const input = { key: "value" };
        const result = await getRequestBody({
            body: input,
            type: "json",
        });
        expect(result).toBe('{"key":"value"}');
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/getResponseBody.test.ts">
```ts
import { RUNTIME } from "../../../src/core/runtime";
import { getResponseBody } from "../../../src/core/fetcher/getResponseBody";

import { chooseStreamWrapper } from "../../../src/core/fetcher/stream-wrappers/chooseStreamWrapper";

describe("Test getResponseBody", () => {
    it("should handle blob response type", async () => {
        const mockBlob = new Blob(["test"], { type: "text/plain" });
        const mockResponse = new Response(mockBlob);
        const result = await getResponseBody(mockResponse, "blob");
        // @ts-expect-error
        expect(result.constructor.name).toBe("Blob");
    });

    it("should handle sse response type", async () => {
        if (RUNTIME.type === "node") {
            const mockStream = new ReadableStream();
            const mockResponse = new Response(mockStream);
            const result = await getResponseBody(mockResponse, "sse");
            expect(result).toBe(mockStream);
        }
    });

    it("should handle streaming response type", async () => {
        if (RUNTIME.type === "node") {
            const mockStream = new ReadableStream();
            const mockResponse = new Response(mockStream);
            const result = await getResponseBody(mockResponse, "streaming");
            // need to reinstantiate string as a result of locked state in Readable Stream after registration with Response
            expect(JSON.stringify(result)).toBe(JSON.stringify(await chooseStreamWrapper(new ReadableStream())));
        }
    });

    it("should handle text response type", async () => {
        const mockResponse = new Response("test text");
        const result = await getResponseBody(mockResponse, "text");
        expect(result).toBe("test text");
    });

    it("should handle JSON response", async () => {
        const mockJson = { key: "value" };
        const mockResponse = new Response(JSON.stringify(mockJson));
        const result = await getResponseBody(mockResponse);
        expect(result).toEqual(mockJson);
    });

    it("should handle empty response", async () => {
        const mockResponse = new Response("");
        const result = await getResponseBody(mockResponse);
        expect(result).toBeUndefined();
    });

    it("should handle non-JSON response", async () => {
        const mockResponse = new Response("invalid json");
        const result = await getResponseBody(mockResponse);
        expect(result).toEqual({
            ok: false,
            error: {
                reason: "non-json",
                statusCode: 200,
                rawBody: "invalid json",
            },
        });
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/makeRequest.test.ts">
```ts
import { makeRequest } from "../../../src/core/fetcher/makeRequest";

describe("Test makeRequest", () => {
    const mockPostUrl = "https://httpbin.org/post";
    const mockGetUrl = "https://httpbin.org/get";
    const mockHeaders = { "Content-Type": "application/json" };
    const mockBody = JSON.stringify({ key: "value" });

    let mockFetch: jest.Mock;

    beforeEach(() => {
        mockFetch = jest.fn();
        mockFetch.mockResolvedValue(new Response(JSON.stringify({ test: "successful" }), { status: 200 }));
    });

    it("should handle POST request correctly", async () => {
        const response = await makeRequest(mockFetch, mockPostUrl, "POST", mockHeaders, mockBody);
        const responseBody = await response.json();
        expect(responseBody).toEqual({ test: "successful" });
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
        expect(calledUrl).toBe(mockPostUrl);
        expect(calledOptions).toEqual(
            expect.objectContaining({
                method: "POST",
                headers: mockHeaders,
                body: mockBody,
                credentials: undefined,
            }),
        );
        expect(calledOptions.signal).toBeDefined();
        expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
    });

    it("should handle GET request correctly", async () => {
        const response = await makeRequest(mockFetch, mockGetUrl, "GET", mockHeaders, undefined);
        const responseBody = await response.json();
        expect(responseBody).toEqual({ test: "successful" });
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
        expect(calledUrl).toBe(mockGetUrl);
        expect(calledOptions).toEqual(
            expect.objectContaining({
                method: "GET",
                headers: mockHeaders,
                body: undefined,
                credentials: undefined,
            }),
        );
        expect(calledOptions.signal).toBeDefined();
        expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/requestWithRetries.test.ts">
```ts
import { requestWithRetries } from "../../../src/core/fetcher/requestWithRetries";

describe("requestWithRetries", () => {
    let mockFetch: jest.Mock;
    let originalMathRandom: typeof Math.random;
    let setTimeoutSpy: jest.SpyInstance;

    beforeEach(() => {
        mockFetch = jest.fn();
        originalMathRandom = Math.random;

        // Mock Math.random for consistent jitter
        Math.random = jest.fn(() => 0.5);

        jest.useFakeTimers({ doNotFake: ["nextTick"] });
    });

    afterEach(() => {
        Math.random = originalMathRandom;
        jest.clearAllMocks();
        jest.clearAllTimers();
    });

    it("should retry on retryable status codes", async () => {
        setTimeoutSpy = jest.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        const retryableStatuses = [408, 429, 500, 502];
        let callCount = 0;

        mockFetch.mockImplementation(async () => {
            if (callCount < retryableStatuses.length) {
                return new Response("", { status: retryableStatuses[callCount++] });
            }
            return new Response("", { status: 200 });
        });

        const responsePromise = requestWithRetries(() => mockFetch(), retryableStatuses.length);
        await jest.runAllTimersAsync();
        const response = await responsePromise;

        expect(mockFetch).toHaveBeenCalledTimes(retryableStatuses.length + 1);
        expect(response.status).toBe(200);
    });

    it("should respect maxRetries limit", async () => {
        setTimeoutSpy = jest.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        const maxRetries = 2;
        mockFetch.mockResolvedValue(new Response("", { status: 500 }));

        const responsePromise = requestWithRetries(() => mockFetch(), maxRetries);
        await jest.runAllTimersAsync();
        const response = await responsePromise;

        expect(mockFetch).toHaveBeenCalledTimes(maxRetries + 1);
        expect(response.status).toBe(500);
    });

    it("should not retry on success status codes", async () => {
        setTimeoutSpy = jest.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        const successStatuses = [200, 201, 202];

        for (const status of successStatuses) {
            mockFetch.mockReset();
            setTimeoutSpy.mockClear();
            mockFetch.mockResolvedValueOnce(new Response("", { status }));

            const responsePromise = requestWithRetries(() => mockFetch(), 3);
            await jest.runAllTimersAsync();
            await responsePromise;

            expect(mockFetch).toHaveBeenCalledTimes(1);
            expect(setTimeoutSpy).not.toHaveBeenCalled();
        }
    });

    it("should apply correct exponential backoff with jitter", async () => {
        setTimeoutSpy = jest.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        mockFetch.mockResolvedValue(new Response("", { status: 500 }));
        const maxRetries = 3;
        const expectedDelays = [1000, 2000, 4000];

        const responsePromise = requestWithRetries(() => mockFetch(), maxRetries);
        await jest.runAllTimersAsync();
        await responsePromise;

        // Verify setTimeout calls
        expect(setTimeoutSpy).toHaveBeenCalledTimes(expectedDelays.length);

        expectedDelays.forEach((delay, index) => {
            expect(setTimeoutSpy).toHaveBeenNthCalledWith(index + 1, expect.any(Function), delay);
        });

        expect(mockFetch).toHaveBeenCalledTimes(maxRetries + 1);
    });

    it("should handle concurrent retries independently", async () => {
        setTimeoutSpy = jest.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        mockFetch
            .mockResolvedValueOnce(new Response("", { status: 500 }))
            .mockResolvedValueOnce(new Response("", { status: 500 }))
            .mockResolvedValueOnce(new Response("", { status: 200 }))
            .mockResolvedValueOnce(new Response("", { status: 200 }));

        const promise1 = requestWithRetries(() => mockFetch(), 1);
        const promise2 = requestWithRetries(() => mockFetch(), 1);

        await jest.runAllTimersAsync();
        const [response1, response2] = await Promise.all([promise1, promise2]);

        expect(response1.status).toBe(200);
        expect(response2.status).toBe(200);
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/signals.test.ts">
```ts
import { anySignal, getTimeoutSignal } from "../../../src/core/fetcher/signals";

describe("Test getTimeoutSignal", () => {
    beforeEach(() => {
        jest.useFakeTimers();
    });

    afterEach(() => {
        jest.useRealTimers();
    });

    it("should return an object with signal and abortId", () => {
        const { signal, abortId } = getTimeoutSignal(1000);

        expect(signal).toBeDefined();
        expect(abortId).toBeDefined();
        expect(signal).toBeInstanceOf(AbortSignal);
        expect(signal.aborted).toBe(false);
    });

    it("should create a signal that aborts after the specified timeout", () => {
        const timeoutMs = 5000;
        const { signal } = getTimeoutSignal(timeoutMs);

        expect(signal.aborted).toBe(false);

        jest.advanceTimersByTime(timeoutMs - 1);
        expect(signal.aborted).toBe(false);

        jest.advanceTimersByTime(1);
        expect(signal.aborted).toBe(true);
    });
});

describe("Test anySignal", () => {
    it("should return an AbortSignal", () => {
        const signal = anySignal(new AbortController().signal);
        expect(signal).toBeInstanceOf(AbortSignal);
    });

    it("should abort when any of the input signals is aborted", () => {
        const controller1 = new AbortController();
        const controller2 = new AbortController();
        const signal = anySignal(controller1.signal, controller2.signal);

        expect(signal.aborted).toBe(false);
        controller1.abort();
        expect(signal.aborted).toBe(true);
    });

    it("should handle an array of signals", () => {
        const controller1 = new AbortController();
        const controller2 = new AbortController();
        const signal = anySignal([controller1.signal, controller2.signal]);

        expect(signal.aborted).toBe(false);
        controller2.abort();
        expect(signal.aborted).toBe(true);
    });

    it("should abort immediately if one of the input signals is already aborted", () => {
        const controller1 = new AbortController();
        const controller2 = new AbortController();
        controller1.abort();

        const signal = anySignal(controller1.signal, controller2.signal);
        expect(signal.aborted).toBe(true);
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/stream-wrappers/Node18UniversalStreamWrapper.test.ts">
```ts
import { Node18UniversalStreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper";

describe("Node18UniversalStreamWrapper", () => {
    it("should set encoding to utf-8", async () => {
        const rawStream = new ReadableStream();
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const setEncodingSpy = jest.spyOn(stream, "setEncoding");

        stream.setEncoding("utf-8");

        expect(setEncodingSpy).toHaveBeenCalledWith("utf-8");
    });

    it("should register an event listener for readable", async () => {
        const rawStream = new ReadableStream();
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const onSpy = jest.spyOn(stream, "on");

        stream.on("readable", () => {});

        expect(onSpy).toHaveBeenCalledWith("readable", expect.any(Function));
    });

    it("should remove an event listener for data", async () => {
        const rawStream = new ReadableStream();
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const offSpy = jest.spyOn(stream, "off");

        const fn = () => {};
        stream.on("data", fn);
        stream.off("data", fn);

        expect(offSpy).toHaveBeenCalledWith("data", expect.any(Function));
    });

    it("should write to dest when calling pipe to writable stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const dest = new WritableStream({
            write(chunk) {
                expect(chunk).toEqual(new TextEncoder().encode("test"));
            },
        });

        stream.pipe(dest);
    });

    it("should write to dest when calling pipe to node writable stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const dest = new (await import("readable-stream")).Writable({
            write(chunk, encoding, callback) {
                expect(chunk.toString()).toEqual("test");
                callback();
            },
        });

        stream.pipe(dest);
    });

    it("should write nothing when calling pipe and unpipe", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const buffer: Uint8Array[] = [];
        const dest = new WritableStream({
            write(chunk) {
                buffer.push(chunk);
            },
        });

        stream.pipe(dest);
        stream.unpipe(dest);
        expect(buffer).toEqual([]);
    });

    it("should destroy the stream", async () => {
        const rawStream = new ReadableStream();
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const destroySpy = jest.spyOn(stream, "destroy");

        stream.destroy();

        expect(destroySpy).toHaveBeenCalled();
    });

    it("should pause and resume the stream", async () => {
        const rawStream = new ReadableStream();
        const stream = new Node18UniversalStreamWrapper(rawStream);
        const pauseSpy = jest.spyOn(stream, "pause");
        const resumeSpy = jest.spyOn(stream, "resume");

        expect(stream.isPaused).toBe(false);
        stream.pause();
        expect(stream.isPaused).toBe(true);
        stream.resume();

        expect(pauseSpy).toHaveBeenCalled();
        expect(resumeSpy).toHaveBeenCalled();
    });

    it("should read the stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new Node18UniversalStreamWrapper(rawStream);

        expect(await stream.read()).toEqual(new TextEncoder().encode("test"));
        expect(await stream.read()).toEqual(new TextEncoder().encode("test"));
    });

    it("should read the stream as text", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new Node18UniversalStreamWrapper(rawStream);

        const data = await stream.text();

        expect(data).toEqual("testtest");
    });

    it("should read the stream as json", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode(JSON.stringify({ test: "test" })));
                controller.close();
            },
        });
        const stream = new Node18UniversalStreamWrapper(rawStream);

        const data = await stream.json();

        expect(data).toEqual({ test: "test" });
    });

    it("should allow use with async iterable stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        let data = "";
        const stream = new Node18UniversalStreamWrapper(rawStream);
        for await (const chunk of stream) {
            data += new TextDecoder().decode(chunk);
        }

        expect(data).toEqual("testtest");
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/stream-wrappers/NodePre18StreamWrapper.test.ts">
```ts
import { NodePre18StreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/NodePre18StreamWrapper";

describe("NodePre18StreamWrapper", () => {
    it("should set encoding to utf-8", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const setEncodingSpy = jest.spyOn(stream, "setEncoding");

        stream.setEncoding("utf-8");

        expect(setEncodingSpy).toHaveBeenCalledWith("utf-8");
    });

    it("should register an event listener for readable", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const onSpy = jest.spyOn(stream, "on");

        stream.on("readable", () => {});

        expect(onSpy).toHaveBeenCalledWith("readable", expect.any(Function));
    });

    it("should remove an event listener for data", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const offSpy = jest.spyOn(stream, "off");

        const fn = () => {};
        stream.on("data", fn);
        stream.off("data", fn);

        expect(offSpy).toHaveBeenCalledWith("data", expect.any(Function));
    });

    it("should write to dest when calling pipe to node writable stream", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const dest = new (await import("readable-stream")).Writable({
            write(chunk, encoding, callback) {
                expect(chunk.toString()).toEqual("test");
                callback();
            },
        });

        stream.pipe(dest);
    });

    it("should write nothing when calling pipe and unpipe", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const buffer: Uint8Array[] = [];
        const dest = new (await import("readable-stream")).Writable({
            write(chunk, encoding, callback) {
                buffer.push(chunk);
                callback();
            },
        });
        stream.pipe(dest);
        stream.unpipe();

        expect(buffer).toEqual([]);
    });

    it("should destroy the stream", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const destroySpy = jest.spyOn(stream, "destroy");

        stream.destroy();

        expect(destroySpy).toHaveBeenCalledWith();
    });

    it("should pause the stream and resume", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);
        const pauseSpy = jest.spyOn(stream, "pause");

        stream.pause();
        expect(stream.isPaused).toBe(true);
        stream.resume();
        expect(stream.isPaused).toBe(false);

        expect(pauseSpy).toHaveBeenCalledWith();
    });

    it("should read the stream", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);

        expect(await stream.read()).toEqual("test");
        expect(await stream.read()).toEqual("test");
    });

    it("should read the stream as text", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        const stream = new NodePre18StreamWrapper(rawStream);

        const data = await stream.text();

        expect(data).toEqual("testtest");
    });

    it("should read the stream as json", async () => {
        const rawStream = (await import("readable-stream")).Readable.from([JSON.stringify({ test: "test" })]);
        const stream = new NodePre18StreamWrapper(rawStream);

        const data = await stream.json();

        expect(data).toEqual({ test: "test" });
    });

    it("should allow use with async iterable stream", async () => {
        const rawStream = (await import("readable-stream")).Readable.from(["test", "test"]);
        let data = "";
        const stream = new NodePre18StreamWrapper(rawStream);
        for await (const chunk of stream) {
            data += chunk;
        }

        expect(data).toEqual("testtest");
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/stream-wrappers/UndiciStreamWrapper.test.ts">
```ts
import { UndiciStreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/UndiciStreamWrapper";

describe("UndiciStreamWrapper", () => {
    it("should set encoding to utf-8", async () => {
        const rawStream = new ReadableStream();
        const stream = new UndiciStreamWrapper(rawStream);
        const setEncodingSpy = jest.spyOn(stream, "setEncoding");

        stream.setEncoding("utf-8");

        expect(setEncodingSpy).toHaveBeenCalledWith("utf-8");
    });

    it("should register an event listener for readable", async () => {
        const rawStream = new ReadableStream();
        const stream = new UndiciStreamWrapper(rawStream);
        const onSpy = jest.spyOn(stream, "on");

        stream.on("readable", () => {});

        expect(onSpy).toHaveBeenCalledWith("readable", expect.any(Function));
    });

    it("should remove an event listener for data", async () => {
        const rawStream = new ReadableStream();
        const stream = new UndiciStreamWrapper(rawStream);
        const offSpy = jest.spyOn(stream, "off");

        const fn = () => {};
        stream.on("data", fn);
        stream.off("data", fn);

        expect(offSpy).toHaveBeenCalledWith("data", expect.any(Function));
    });

    it("should write to dest when calling pipe to writable stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new UndiciStreamWrapper(rawStream);
        const dest = new WritableStream({
            write(chunk) {
                expect(chunk).toEqual(new TextEncoder().encode("test"));
            },
        });

        stream.pipe(dest);
    });

    it("should write nothing when calling pipe and unpipe", async () => {
        const rawStream = new ReadableStream();
        const stream = new UndiciStreamWrapper(rawStream);
        const buffer: Uint8Array[] = [];
        const dest = new WritableStream({
            write(chunk) {
                buffer.push(chunk);
            },
        });
        stream.pipe(dest);
        stream.unpipe(dest);

        expect(buffer).toEqual([]);
    });

    it("should destroy the stream", async () => {
        const rawStream = new ReadableStream();
        const stream = new UndiciStreamWrapper(rawStream);
        const destroySpy = jest.spyOn(stream, "destroy");

        stream.destroy();

        expect(destroySpy).toHaveBeenCalled();
    });

    it("should pause and resume the stream", async () => {
        const rawStream = new ReadableStream();
        const stream = new UndiciStreamWrapper(rawStream);
        const pauseSpy = jest.spyOn(stream, "pause");
        const resumeSpy = jest.spyOn(stream, "resume");

        expect(stream.isPaused).toBe(false);
        stream.pause();
        expect(stream.isPaused).toBe(true);
        stream.resume();

        expect(pauseSpy).toHaveBeenCalled();
        expect(resumeSpy).toHaveBeenCalled();
    });

    it("should read the stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new UndiciStreamWrapper(rawStream);

        expect(await stream.read()).toEqual(new TextEncoder().encode("test"));
        expect(await stream.read()).toEqual(new TextEncoder().encode("test"));
    });

    it("should read the stream as text", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        const stream = new UndiciStreamWrapper(rawStream);

        const data = await stream.text();

        expect(data).toEqual("testtest");
    });

    it("should read the stream as json", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode(JSON.stringify({ test: "test" })));
                controller.close();
            },
        });
        const stream = new UndiciStreamWrapper(rawStream);

        const data = await stream.json();

        expect(data).toEqual({ test: "test" });
    });

    it("should allow use with async iterable stream", async () => {
        const rawStream = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode("test"));
                controller.enqueue(new TextEncoder().encode("test"));
                controller.close();
            },
        });
        let data = "";
        const stream = new UndiciStreamWrapper(rawStream);
        for await (const chunk of stream) {
            data += new TextDecoder().decode(chunk);
        }

        expect(data).toEqual("testtest");
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/stream-wrappers/chooseStreamWrapper.test.ts">
```ts
import { Node18UniversalStreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper";
import { NodePre18StreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/NodePre18StreamWrapper";
import { UndiciStreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/UndiciStreamWrapper";
import { chooseStreamWrapper } from "../../../../src/core/fetcher/stream-wrappers/chooseStreamWrapper";
import { RUNTIME } from "../../../../src/core/runtime";

describe("chooseStreamWrapper", () => {
    beforeEach(() => {
        RUNTIME.type = "unknown";
        RUNTIME.parsedVersion = 0;
    });

    it('should return a Node18UniversalStreamWrapper when RUNTIME.type is "node" and RUNTIME.parsedVersion is not null and RUNTIME.parsedVersion is greater than or equal to 18', async () => {
        const expected = new Node18UniversalStreamWrapper(new ReadableStream());
        RUNTIME.type = "node";
        RUNTIME.parsedVersion = 18;

        const result = await chooseStreamWrapper(new ReadableStream());

        expect(JSON.stringify(result)).toBe(JSON.stringify(expected));
    });

    it('should return a NodePre18StreamWrapper when RUNTIME.type is "node" and RUNTIME.parsedVersion is not null and RUNTIME.parsedVersion is less than 18', async () => {
        const stream = await import("readable-stream");
        const expected = new NodePre18StreamWrapper(new stream.Readable());

        RUNTIME.type = "node";
        RUNTIME.parsedVersion = 16;

        const result = await chooseStreamWrapper(new stream.Readable());

        expect(JSON.stringify(result)).toEqual(JSON.stringify(expected));
    });

    it('should return a Undici when RUNTIME.type is not "node"', async () => {
        const expected = new UndiciStreamWrapper(new ReadableStream());
        RUNTIME.type = "browser";

        const result = await chooseStreamWrapper(new ReadableStream());

        expect(JSON.stringify(result)).toEqual(JSON.stringify(expected));
    });
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/stream-wrappers/webpack.test.ts">
```ts
import webpack from "webpack";

describe("test env compatibility", () => {
    test("webpack", () => {
        return new Promise<void>((resolve, reject) => {
            webpack(
                {
                    mode: "production",
                    entry: "./src/index.ts",
                    module: {
                        rules: [
                            {
                                test: /\.tsx?$/,
                                use: "ts-loader",
                                exclude: /node_modules/,
                            },
                        ],
                    },
                    resolve: {
                        extensions: [".tsx", ".ts", ".jsx", ".js"],
                        extensionAlias: {
                            ".js": [".ts", ".js"],
                            ".jsx": [".tsx", ".jsx"],
                        },
                    },
                },
                (err, stats) => {
                    try {
                        expect(err).toBe(null);
                        if (stats?.hasErrors()) {
                            console.log(stats?.toString());
                        }
                        expect(stats?.hasErrors()).toBe(false);
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                },
            );
        });
    }, 180_000);
});

```
</file>
<file path="terra-client-js/tests/unit/fetcher/test-file.txt">
```txt
This is a test file!

```
</file>
<file path="terra-client-js/tests/wire/activity.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Activity", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    active_durations_data: {
                        activity_seconds: 1800,
                        inactivity_seconds: 600,
                        low_intensity_seconds: 900,
                        moderate_intensity_seconds: 600,
                        num_continuous_inactive_periods: 3,
                        rest_seconds: 120,
                        vigorous_intensity_seconds: 300,
                    },
                    cheat_detection: 0,
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    energy_data: { energy_kilojoules: 1200, energy_planned_kilojoules: 1150 },
                    MET_data: {
                        avg_level: 3.8,
                        num_high_intensity_minutes: 10,
                        num_inactive_minutes: 5,
                        num_low_intensity_minutes: 15,
                        num_moderate_intensity_minutes: 25,
                    },
                    metadata: {
                        city: "San Francisco",
                        country: "United States",
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        name: "Morning Run",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        state: "California",
                        summary_id: "123e4567-e89b-12d3-a456-426614174000",
                        timestamp_localization: 0,
                        type: 1.1,
                        upload_type: 1.1,
                    },
                    movement_data: {
                        adjusted_max_speed_meters_per_second: 4.2,
                        avg_cadence_rpm: 85,
                        avg_pace_minutes_per_kilometer: 6.2,
                        avg_speed_meters_per_second: 3.2,
                        avg_torque_newton_meters: 40,
                        avg_velocity_meters_per_second: 3,
                        max_cadence_rpm: 110,
                        max_pace_minutes_per_kilometer: 6.5,
                        max_speed_meters_per_second: 4.5,
                        max_torque_newton_meters: 55.5,
                        max_velocity_meters_per_second: 4.5,
                        normalized_speed_meters_per_second: 3.8,
                    },
                    oxygen_data: { avg_saturation_percentage: 98, vo2max_ml_per_min_per_kg: 45.5 },
                    polyline_map_data: { summary_polyline: "}_p~iF~ps|U_ulLnnqC_mqNvxq`@" },
                    power_data: { avg_watts: 185, max_watts: 350 },
                    strain_data: { strain_level: 14.5 },
                    work_data: { work_kilojoules: 450.5 },
                },
            ],
            type: "type",
        };
        server.mockEndpoint().get("/activity").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.activity.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    active_durations_data: {
                        activity_seconds: 1800,
                        inactivity_seconds: 600,
                        low_intensity_seconds: 900,
                        moderate_intensity_seconds: 600,
                        num_continuous_inactive_periods: 3,
                        rest_seconds: 120,
                        vigorous_intensity_seconds: 300,
                    },
                    cheat_detection: 0,
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    energy_data: {
                        energy_kilojoules: 1200,
                        energy_planned_kilojoules: 1150,
                    },
                    MET_data: {
                        avg_level: 3.8,
                        num_high_intensity_minutes: 10,
                        num_inactive_minutes: 5,
                        num_low_intensity_minutes: 15,
                        num_moderate_intensity_minutes: 25,
                    },
                    metadata: {
                        city: "San Francisco",
                        country: "United States",
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        name: "Morning Run",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        state: "California",
                        summary_id: "123e4567-e89b-12d3-a456-426614174000",
                        timestamp_localization: 0,
                        type: 1.1,
                        upload_type: 1.1,
                    },
                    movement_data: {
                        adjusted_max_speed_meters_per_second: 4.2,
                        avg_cadence_rpm: 85,
                        avg_pace_minutes_per_kilometer: 6.2,
                        avg_speed_meters_per_second: 3.2,
                        avg_torque_newton_meters: 40,
                        avg_velocity_meters_per_second: 3,
                        max_cadence_rpm: 110,
                        max_pace_minutes_per_kilometer: 6.5,
                        max_speed_meters_per_second: 4.5,
                        max_torque_newton_meters: 55.5,
                        max_velocity_meters_per_second: 4.5,
                        normalized_speed_meters_per_second: 3.8,
                    },
                    oxygen_data: {
                        avg_saturation_percentage: 98,
                        vo2max_ml_per_min_per_kg: 45.5,
                    },
                    polyline_map_data: {
                        summary_polyline: "}_p~iF~ps|U_ulLnnqC_mqNvxq`@",
                    },
                    power_data: {
                        avg_watts: 185,
                        max_watts: 350,
                    },
                    strain_data: {
                        strain_level: 14.5,
                    },
                    work_data: {
                        work_kilojoules: 450.5,
                    },
                },
            ],
            type: "type",
        });
    });

    test("write", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        summary_id: "123e4567-e89b-12d3-a456-426614174000",
                        type: 1.1,
                        upload_type: 1.1,
                    },
                },
            ],
        };
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/activity")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.activity.write({
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        summary_id: "123e4567-e89b-12d3-a456-426614174000",
                        type: 1.1,
                        upload_type: 1.1,
                    },
                },
            ],
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/athlete.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Athlete", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            athlete: {
                age: 28,
                country: "United States",
                bio: "Passionate runner and cyclist",
                state: "California",
                last_name: "Smith",
                sex: "male",
                city: "San Francisco",
                email: "user@example.com",
                date_of_birth: "1999-11-23",
                first_name: "John",
                gender: "male",
                joined_provider: "2023-01-15",
                devices: [
                    {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                ],
            },
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            type: "athlete",
        };
        server.mockEndpoint().get("/athlete").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.athlete.fetch({
            user_id: "user_id",
        });
        expect(response).toEqual({
            type: "athlete",
            athlete: {
                age: 28,
                country: "United States",
                bio: "Passionate runner and cyclist",
                state: "California",
                last_name: "Smith",
                sex: "male",
                city: "San Francisco",
                email: "user@example.com",
                date_of_birth: "1999-11-23",
                first_name: "John",
                gender: "male",
                joined_provider: "2023-01-15",
                devices: [
                    {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                ],
            },
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/authentication.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Authentication", () => {
    test("authenticateuser", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            status: "success",
            user_id: "23dc2540-7139-44c6-8158-f81196e2cf2e",
            auth_url:
                "https://www.fitbit.com/oauth2/authorize?response_type=code&client_id=23BBG9&scope=settings+nutrition+sleep+heartrate+electrocardiogram+weight+respiratory_rate+oxygen_saturation+profile+temperature+cardio_fitness+activity+location&state=bLqqjPie9ptwoWm6VBxHCu6JkkoWJp",
        };
        server
            .mockEndpoint()
            .post("/auth/authenticateUser")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.authentication.authenticateuser({
            resource: "resource",
        });
        expect(response).toEqual({
            status: "success",
            user_id: "23dc2540-7139-44c6-8158-f81196e2cf2e",
            auth_url:
                "https://www.fitbit.com/oauth2/authorize?response_type=code&client_id=23BBG9&scope=settings+nutrition+sleep+heartrate+electrocardiogram+weight+respiratory_rate+oxygen_saturation+profile+temperature+cardio_fitness+activity+location&state=bLqqjPie9ptwoWm6VBxHCu6JkkoWJp",
        });
    });

    test("generatewidgetsession", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            session_id: "23dc2540-7139-44c6-8158-f81196e2cf2e",
            url: "https://widget.tryterra.co/session/344d475f-296a-489a-a88c-54183671dafd",
            status: "success",
            expires_in: 900,
        };
        server
            .mockEndpoint()
            .post("/auth/generateWidgetSession")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.authentication.generatewidgetsession();
        expect(response).toEqual({
            session_id: "23dc2540-7139-44c6-8158-f81196e2cf2e",
            url: "https://widget.tryterra.co/session/344d475f-296a-489a-a88c-54183671dafd",
            status: "success",
            expires_in: 900,
        });
    });

    test("deauthenticateuser", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = { status: "success" };
        server
            .mockEndpoint()
            .delete("/auth/deauthenticateUser")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.authentication.deauthenticateuser({
            user_id: "user_id",
        });
        expect(response).toEqual({
            status: "success",
        });
    });

    test("generateauthtoken", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            status: "success",
            token: "250c68b9c21b78e40e7a3285a2d538d3bc24aabd3b4c76a782fb0a571ca4501d",
            expires_in: 180,
        };
        server
            .mockEndpoint()
            .post("/auth/generateAuthToken")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.authentication.generateauthtoken();
        expect(response).toEqual({
            status: "success",
            token: "250c68b9c21b78e40e7a3285a2d538d3bc24aabd3b4c76a782fb0a571ca4501d",
            expires_in: 180,
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/body.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Body", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    hydration_data: { day_total_water_consumption_ml: 2500 },
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                    },
                    oxygen_data: { avg_saturation_percentage: 98, vo2max_ml_per_min_per_kg: 45.5 },
                    glucose_data: { day_avg_blood_glucose_mg_per_dL: 92.5 },
                },
            ],
            type: "type",
        };
        server.mockEndpoint().get("/body").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.body.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    hydration_data: {
                        day_total_water_consumption_ml: 2500,
                    },
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                    },
                    oxygen_data: {
                        avg_saturation_percentage: 98,
                        vo2max_ml_per_min_per_kg: 45.5,
                    },
                    glucose_data: {
                        day_avg_blood_glucose_mg_per_dL: 92.5,
                    },
                },
            ],
            type: "type",
        });
    });

    test("write", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                    },
                },
            ],
        };
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/body")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.body.write({
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                    },
                },
            ],
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        });
    });

    test("delete", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            processed_data: [{ id: "id", response_code: 1 }],
        };
        server
            .mockEndpoint()
            .delete("/body")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.body.delete({
            user_id: "user_id",
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            processed_data: [
                {
                    id: "id",
                    response_code: 1,
                },
            ],
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/daily.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Daily", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    active_durations_data: {
                        activity_seconds: 1800,
                        inactivity_seconds: 600,
                        low_intensity_seconds: 900,
                        moderate_intensity_seconds: 600,
                        num_continuous_inactive_periods: 3,
                        rest_seconds: 120,
                        vigorous_intensity_seconds: 300,
                    },
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    distance_data: { distance_meters: 8500, floors_climbed: 15, steps: 12000 },
                    MET_data: {
                        avg_level: 3.8,
                        num_high_intensity_minutes: 10,
                        num_inactive_minutes: 5,
                        num_low_intensity_minutes: 15,
                        num_moderate_intensity_minutes: 25,
                    },
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                        upload_type: 1.1,
                    },
                    oxygen_data: { avg_saturation_percentage: 98, vo2max_ml_per_min_per_kg: 45.5 },
                    scores: { activity: 92, recovery: 78, sleep: 85 },
                    strain_data: { strain_level: 14.5 },
                    stress_data: {
                        avg_stress_level: 45.5,
                        activity_stress_duration_seconds: 3600,
                        low_stress_duration_seconds: 28800,
                        max_stress_level: 85,
                        medium_stress_duration_seconds: 7200,
                        rest_stress_duration_seconds: 1800,
                        high_stress_duration_seconds: 900,
                        stress_duration_seconds: 5400,
                    },
                    tag_data: {
                        tags: [
                            {
                                timestamp: "1999-11-23T09:00:00.000000+02:00",
                                tag_name: "hot_shower",
                                notes: "Felt refreshed after",
                            },
                        ],
                    },
                },
            ],
            type: "type",
        };
        server.mockEndpoint().get("/daily").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.daily.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    active_durations_data: {
                        activity_seconds: 1800,
                        inactivity_seconds: 600,
                        low_intensity_seconds: 900,
                        moderate_intensity_seconds: 600,
                        num_continuous_inactive_periods: 3,
                        rest_seconds: 120,
                        vigorous_intensity_seconds: 300,
                    },
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    distance_data: {
                        distance_meters: 8500,
                        floors_climbed: 15,
                        steps: 12000,
                    },
                    MET_data: {
                        avg_level: 3.8,
                        num_high_intensity_minutes: 10,
                        num_inactive_minutes: 5,
                        num_low_intensity_minutes: 15,
                        num_moderate_intensity_minutes: 25,
                    },
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                        upload_type: 1.1,
                    },
                    oxygen_data: {
                        avg_saturation_percentage: 98,
                        vo2max_ml_per_min_per_kg: 45.5,
                    },
                    scores: {
                        activity: 92,
                        recovery: 78,
                        sleep: 85,
                    },
                    strain_data: {
                        strain_level: 14.5,
                    },
                    stress_data: {
                        avg_stress_level: 45.5,
                        activity_stress_duration_seconds: 3600,
                        low_stress_duration_seconds: 28800,
                        max_stress_level: 85,
                        medium_stress_duration_seconds: 7200,
                        rest_stress_duration_seconds: 1800,
                        high_stress_duration_seconds: 900,
                        stress_duration_seconds: 5400,
                    },
                    tag_data: {
                        tags: [
                            {
                                timestamp: "1999-11-23T09:00:00.000000+02:00",
                                tag_name: "hot_shower",
                                notes: "Felt refreshed after",
                            },
                        ],
                    },
                },
            ],
            type: "type",
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/integrations.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Integrations", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = { providers: ["FITBIT"], sdk_resource: ["APPLE"], status: "success" };
        server.mockEndpoint().get("/integrations").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.integrations.fetch();
        expect(response).toEqual({
            providers: ["FITBIT"],
            sdk_resource: ["APPLE"],
            status: "success",
        });
    });

    test("detailedfetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            status: "success",
            providers: [
                {
                    provider: "MAPMYFITNESS",
                    name: "MapMyFitness",
                    icon: "https://api.tryterra.co/v2/static/assets/img/app_icons/mapmyfitness.webp",
                    setup: "API_KEYS_MANAGED",
                    enabled: true,
                    types: {
                        activity: true,
                        body: false,
                        nutrition: false,
                        daily: false,
                        sleep: false,
                        menstruation: false,
                    },
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/integrations/detailed")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.integrations.detailedfetch();
        expect(response).toEqual({
            status: "success",
            providers: [
                {
                    provider: "MAPMYFITNESS",
                    name: "MapMyFitness",
                    icon: "https://api.tryterra.co/v2/static/assets/img/app_icons/mapmyfitness.webp",
                    setup: "API_KEYS_MANAGED",
                    enabled: true,
                    types: {
                        activity: true,
                        body: false,
                        nutrition: false,
                        daily: false,
                        sleep: false,
                        menstruation: false,
                    },
                },
            ],
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/menstruation.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Menstruation", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                    },
                    menstruation_data: {
                        period_length_days: 5,
                        length_of_current_phase_days: 5,
                        days_until_next_phase: 23,
                        period_start_date: "2022-11-28",
                        predicted_cycle_length_days: 28,
                        day_in_cycle: 24,
                        last_updated_time: "2022-12-12T14:03:05.000000-05:00",
                        cycle_length_days: "28",
                        is_predicted_cycle: "true",
                    },
                },
            ],
            type: "type",
        };
        server.mockEndpoint().get("/menstruation").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.menstruation.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                    },
                    menstruation_data: {
                        period_length_days: 5,
                        length_of_current_phase_days: 5,
                        days_until_next_phase: 23,
                        period_start_date: "2022-11-28",
                        predicted_cycle_length_days: 28,
                        day_in_cycle: 24,
                        last_updated_time: "2022-12-12T14:03:05.000000-05:00",
                        cycle_length_days: "28",
                        is_predicted_cycle: "true",
                    },
                },
            ],
            type: "type",
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/nutrition.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Nutrition", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    drink_samples: [
                        {
                            timestamp: "2022-11-23T09:00:00.000000+02:00",
                            drink_volume: 250,
                            drink_unit: "ml",
                            drink_name: "Water",
                        },
                    ],
                    meals: [
                        {
                            micros: {
                                biotin_mg: 0.03,
                                caffeine_mg: 95,
                                calcium_mg: 1000,
                                chloride_mg: 2300,
                                chromium_mg: 0.035,
                                copper_mg: 0.9,
                                folate_mg: 0.4,
                                folic_acid_mg: 0.4,
                                iodine_mg: 0.15,
                                iron_mg: 8.5,
                                magnesium_mg: 320,
                                manganese_mg: 2.3,
                                molybdenum_mg: 0.045,
                                niacin_mg: 16,
                                pantothenic_acid_mg: 5,
                                phosphorus_mg: 1000,
                                potassium_mg: 3500,
                                riboflavin_mg: 1.3,
                                selenium_mg: 0.055,
                                thiamin_mg: 1.2,
                                vitamin_A_mg: 0.9,
                                vitamin_B12_mg: 0.0024,
                                vitamin_B6_mg: 1.7,
                                vitamin_C_mg: 90,
                                vitamin_D_mg: 0.02,
                                vitamin_D2_mg: 0.01,
                                vitamin_D3_mg: 0.015,
                                vitamin_E_mg: 15,
                                vitamin_K_mg: 0.12,
                                zinc_mg: 11,
                                cystine_g: 0.3,
                                histidine_g: 0.6,
                                isoleucine_g: 0.8,
                                leucine_g: 1.2,
                                lysine_g: 0.9,
                                methionine_g: 0.6,
                                phenylalanine_g: 0.9,
                                threonine_g: 0.5,
                                tryptophan_g: 0.3,
                                tyrosine_g: 0.7,
                                valine_g: 0.8,
                                monounsaturated_fat_g: 15,
                                polyunsaturated_fat_g: 13,
                                omega3_g: 1.6,
                                omega6_g: 17,
                                starch_g: 25,
                            },
                            type: 1.1,
                            id: "food_123",
                            timestamp: "2022-12-12T08:53:00.000000+02:00",
                            quantity: { unit: 1.1, amount: 1.1 },
                            name: "Oatmeal",
                            macros: {
                                alcohol_g: 14,
                                calories: 2000,
                                carbohydrates_g: 300,
                                cholesterol_mg: 300,
                                fat_g: 65,
                                fiber_g: 25,
                                net_carbohydrates_g: 275,
                                protein_g: 50,
                                saturated_fat_g: 20,
                                sodium_mg: 2300,
                                sugar_g: 25,
                                trans_fat_g: 2,
                            },
                        },
                    ],
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                    },
                    summary: { water_ml: 2000, drink_ml: 500 },
                },
            ],
            type: "type",
        };
        server.mockEndpoint().get("/nutrition").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.nutrition.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    drink_samples: [
                        {
                            timestamp: "2022-11-23T09:00:00.000000+02:00",
                            drink_volume: 250,
                            drink_unit: "ml",
                            drink_name: "Water",
                        },
                    ],
                    meals: [
                        {
                            micros: {
                                biotin_mg: 0.03,
                                caffeine_mg: 95,
                                calcium_mg: 1000,
                                chloride_mg: 2300,
                                chromium_mg: 0.035,
                                copper_mg: 0.9,
                                folate_mg: 0.4,
                                folic_acid_mg: 0.4,
                                iodine_mg: 0.15,
                                iron_mg: 8.5,
                                magnesium_mg: 320,
                                manganese_mg: 2.3,
                                molybdenum_mg: 0.045,
                                niacin_mg: 16,
                                pantothenic_acid_mg: 5,
                                phosphorus_mg: 1000,
                                potassium_mg: 3500,
                                riboflavin_mg: 1.3,
                                selenium_mg: 0.055,
                                thiamin_mg: 1.2,
                                vitamin_A_mg: 0.9,
                                vitamin_B12_mg: 0.0024,
                                vitamin_B6_mg: 1.7,
                                vitamin_C_mg: 90,
                                vitamin_D_mg: 0.02,
                                vitamin_D2_mg: 0.01,
                                vitamin_D3_mg: 0.015,
                                vitamin_E_mg: 15,
                                vitamin_K_mg: 0.12,
                                zinc_mg: 11,
                                cystine_g: 0.3,
                                histidine_g: 0.6,
                                isoleucine_g: 0.8,
                                leucine_g: 1.2,
                                lysine_g: 0.9,
                                methionine_g: 0.6,
                                phenylalanine_g: 0.9,
                                threonine_g: 0.5,
                                tryptophan_g: 0.3,
                                tyrosine_g: 0.7,
                                valine_g: 0.8,
                                monounsaturated_fat_g: 15,
                                polyunsaturated_fat_g: 13,
                                omega3_g: 1.6,
                                omega6_g: 17,
                                starch_g: 25,
                            },
                            type: 1.1,
                            id: "food_123",
                            timestamp: "2022-12-12T08:53:00.000000+02:00",
                            quantity: {
                                unit: 1.1,
                                amount: 1.1,
                            },
                            name: "Oatmeal",
                            macros: {
                                alcohol_g: 14,
                                calories: 2000,
                                carbohydrates_g: 300,
                                cholesterol_mg: 300,
                                fat_g: 65,
                                fiber_g: 25,
                                net_carbohydrates_g: 275,
                                protein_g: 50,
                                saturated_fat_g: 20,
                                sodium_mg: 2300,
                                sugar_g: 25,
                                trans_fat_g: 2,
                            },
                        },
                    ],
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                        timestamp_localization: 0,
                    },
                    summary: {
                        water_ml: 2000,
                        drink_ml: 500,
                    },
                },
            ],
            type: "type",
        });
    });

    test("write", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                    },
                },
            ],
        };
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/nutrition")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.nutrition.write({
            data: [
                {
                    metadata: {
                        end_time: "2022-10-28T10:00:00.000000+01:00",
                        start_time: "1999-11-23T09:00:00.000000+02:00",
                    },
                },
            ],
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        });
    });

    test("delete", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            processed_data: [{ id: "id", response_code: 1 }],
        };
        server
            .mockEndpoint()
            .delete("/nutrition")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.nutrition.delete({
            user_id: "user_id",
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            processed_data: [
                {
                    id: "id",
                    response_code: 1,
                },
            ],
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/plannedworkout.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Plannedworkout", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [{ steps: [{ type: "PlannedWorkoutStep" }] }],
            type: "type",
        };
        server.mockEndpoint().get("/plannedWorkout").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.plannedworkout.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    steps: [
                        {
                            type: "PlannedWorkoutStep",
                        },
                    ],
                },
            ],
            type: "type",
        });
    });

    test("write", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = { data: [{}] };
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/plannedWorkout")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.plannedworkout.write({
            data: [{}],
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            log_ids: ["log_ids"],
            message: "message",
        });
    });

    test("delete", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            processed_data: [{ id: "id", response_code: 1 }],
        };
        server
            .mockEndpoint()
            .delete("/plannedWorkout")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.plannedworkout.delete({
            user_id: "user_id",
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            processed_data: [
                {
                    id: "id",
                    response_code: 1,
                },
            ],
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/sleep.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("Sleep", () => {
    test("fetch", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    metadata: {
                        end_time: "2022-11-24T08:00:00.000000+01:00",
                        is_nap: false,
                        start_time: "1999-11-23T22:00:00.000000+02:00",
                        timestamp_localization: 0,
                        upload_type: 1.1,
                    },
                    readiness_data: { readiness: 85 },
                    sleep_durations_data: { sleep_efficiency: 87.5 },
                    temperature_data: { delta: 0.5 },
                },
            ],
            type: "type",
        };
        server.mockEndpoint().get("/sleep").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.sleep.fetch({
            user_id: "user_id",
            start_date: 1,
        });
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            data: [
                {
                    device_data: {
                        activation_timestamp: "2022-12-25T00:00:00.000000+05:00",
                        hardware_version: "v2.1",
                        manufacturer: "Garmin",
                        name: "Forerunner 945",
                        serial_number: "GR123456789",
                        software_version: "5.2.1",
                    },
                    metadata: {
                        end_time: "2022-11-24T08:00:00.000000+01:00",
                        is_nap: false,
                        start_time: "1999-11-23T22:00:00.000000+02:00",
                        timestamp_localization: 0,
                        upload_type: 1.1,
                    },
                    readiness_data: {
                        readiness: 85,
                    },
                    sleep_durations_data: {
                        sleep_efficiency: 87.5,
                    },
                    temperature_data: {
                        delta: 0.5,
                    },
                },
            ],
            type: "type",
        });
    });
});

```
</file>
<file path="terra-client-js/tests/wire/user.test.ts">
```ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { TerraClient } from "../../src/Client";

describe("User", () => {
    test("modifyuser", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            status: "success",
        };
        server
            .mockEndpoint()
            .patch("/users/user_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.modifyuser("user_id");
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            status: "success",
        });
    });

    test("getinfoforuserid", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            status: "success",
            is_authenticated: true,
        };
        server.mockEndpoint().get("/userInfo").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.user.getinfoforuserid();
        expect(response).toEqual({
            user: {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
            status: "success",
            is_authenticated: true,
        });
    });

    test("getalluserids", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            users: [
                {
                    user_id: "123e4567-e89b-12d3-a456-426614174000",
                    provider: "FITBIT",
                    last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                    scopes: "activity:read,sleep:read",
                    reference_id: "user123@email.com",
                    active: true,
                },
            ],
        };
        server.mockEndpoint().get("/subscriptions").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.user.getalluserids();
        expect(response).toEqual({
            users: [
                {
                    user_id: "123e4567-e89b-12d3-a456-426614174000",
                    provider: "FITBIT",
                    last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                    scopes: "activity:read,sleep:read",
                    reference_id: "user123@email.com",
                    active: true,
                },
            ],
        });
    });

    test("getinfoformultipleuserids", async () => {
        const server = mockServerPool.createServer();
        const client = new TerraClient({ apiKey: "test", devId: "test", environment: server.baseUrl });
        const rawRequestBody = ["string"];
        const rawResponseBody = [
            {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
        ];
        server
            .mockEndpoint()
            .post("/bulkUserInfo")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getinfoformultipleuserids(["string"]);
        expect(response).toEqual([
            {
                user_id: "123e4567-e89b-12d3-a456-426614174000",
                provider: "FITBIT",
                last_webhook_update: "2022-12-12T10:00:00.000000+00:00",
                scopes: "activity:read,sleep:read",
                reference_id: "user123@email.com",
                active: true,
            },
        ]);
    });
});

```
</file>
</files>