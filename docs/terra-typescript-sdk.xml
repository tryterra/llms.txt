<?xml version="1.0" ?>
<root name="terra-typescript-sdk">
  <directory name="terra-typescript-sdk">
    <file name=".fernignore">src/wrapper
src/index.ts
src/core/crypto</file>
    <file name=".prettierrc.yml">tabWidth: 4
printWidth: 120
</file>
    <file name="README.md"># Terra TypeScript Library

The Terra TypeScript library provides convenient access to the Terra API from TypeScript.

## Installation

```sh
npm i -s terra
```

## Reference

A full reference for this library is available [here](./reference.md).

## Usage

Instantiate and use the client with the following:

```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_API_KEY", devId: "YOUR_DEV_ID" });
await client.authentication.authenticateuser({
    resource: "resource",
});
```

## Request And Response Types

The SDK exports all request and response types as TypeScript interfaces. Simply import them with the
following namespace:

```typescript
import { Terra } from "terra";

const request: Terra.AuthenticationAuthenticateUserRequest = {
    ...
};
```

## Exception Handling

When the API returns a non-success status code (4xx or 5xx response), a subclass of the following error
will be thrown.

```typescript
import { TerraError } from "terra";

try {
    await client.authentication.authenticateuser(...);
} catch (err) {
    if (err instanceof TerraError) {
        console.log(err.statusCode);
        console.log(err.message);
        console.log(err.body);
        console.log(err.rawResponse);
    }
}
```

## Advanced

### Additional Headers

If you would like to send additional headers as part of the request, use the `headers` request option.

```typescript
const response = await client.authentication.authenticateuser(..., {
    headers: {
        'X-Custom-Header': 'custom value'
    }
});
```

### Retries

The SDK is instrumented with automatic retries with exponential backoff. A request will be retried as long
as the request is deemed retryable and the number of retry attempts has not grown larger than the configured
retry limit (default: 2).

A request is deemed retryable when any of the following HTTP status codes is returned:

- [408](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408) (Timeout)
- [429](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429) (Too Many Requests)
- [5XX](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500) (Internal Server Errors)

Use the `maxRetries` request option to configure this behavior.

```typescript
const response = await client.authentication.authenticateuser(..., {
    maxRetries: 0 // override maxRetries at the request level
});
```

### Timeouts

The SDK defaults to a 60 second timeout. Use the `timeoutInSeconds` option to configure this behavior.

```typescript
const response = await client.authentication.authenticateuser(..., {
    timeoutInSeconds: 30 // override timeout to 30s
});
```

### Aborting Requests

The SDK allows users to abort requests at any point by passing in an abort signal.

```typescript
const controller = new AbortController();
const response = await client.authentication.authenticateuser(..., {
    abortSignal: controller.signal
});
controller.abort(); // aborts the request
```

### Access Raw Response Data

The SDK provides access to raw response data, including headers, through the `.withRawResponse()` method.
The `.withRawResponse()` method returns a promise that results to an object with a `data` and a `rawResponse` property.

```typescript
const { data, rawResponse } = await client.authentication.authenticateuser(...).withRawResponse();

console.log(data);
console.log(rawResponse.headers['X-My-Header']);
```

### Runtime Compatibility

The SDK defaults to `node-fetch` but will use the global fetch client if present. The SDK works in the following
runtimes:

- Node.js 18+
- Vercel
- Cloudflare Workers
- Deno v1.25+
- Bun 1.0+
- React Native

### Customizing Fetch Client

The SDK provides a way for you to customize the underlying HTTP client / Fetch function. If you're running in an
unsupported environment, this provides a way for you to break glass and ensure the SDK works.

```typescript
import { TerraClient } from "terra";

const client = new TerraClient({
    ...
    fetcher: // provide your implementation here
});
```

## Contributing

While we value open-source contributions to this SDK, this library is generated programmatically.
Additions made directly to this library would have to be moved over to our generation code,
otherwise they would be overwritten upon the next generated release. Feel free to open a PR as
a proof of concept, but know that we will not be able to merge it as-is. We suggest opening
an issue first to discuss with us!

On the other hand, contributions to the README are always very welcome!
</file>
    <file name="jest.config.mjs">/** @type {import('jest').Config} */
export default {
    preset: "ts-jest",
    testEnvironment: "node",
    moduleNameMapper: {
        "(.+)\.js$": "$1",
    },
    setupFilesAfterEnv: ["&lt;rootDir&gt;/tests/mock-server/setup.ts"],
};
</file>
    <file name="reference.md"># Reference

## Authentication

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.authentication.&lt;a href="/src/api/resources/authentication/client/Client.ts"&gt;authenticateuser&lt;/a&gt;({ ...params }) -&gt; Terra.AuthenticationAuthenticateUserResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Creates a login link that allows end users to connect their fitness tracking account

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.authentication.authenticateuser({
    resource: "resource",
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.AuthenticationAuthenticateUserRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Authentication.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.authentication.&lt;a href="/src/api/resources/authentication/client/Client.ts"&gt;generatewidgetsession&lt;/a&gt;({ ...params }) -&gt; Terra.AuthenticationGenerateWidgetSessionResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.authentication.generatewidgetsession();
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.WidgetSessionParams`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Authentication.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.authentication.&lt;a href="/src/api/resources/authentication/client/Client.ts"&gt;deauthenticateuser&lt;/a&gt;({ ...params }) -&gt; Terra.AuthenticationDeauthenticateUserResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Deletes all records of the user on Terra's end, revoking Terra's access to their data

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.authentication.deauthenticateuser({
    user_id: "user_id",
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.AuthenticationDeauthenticateUserRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Authentication.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.authentication.&lt;a href="/src/api/resources/authentication/client/Client.ts"&gt;generateauthtoken&lt;/a&gt;() -&gt; Terra.AuthenticationGenerateAuthTokenResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.authentication.generateauthtoken();
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Authentication.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## User

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.user.&lt;a href="/src/api/resources/user/client/Client.ts"&gt;modifyuser&lt;/a&gt;(userId, { ...params }) -&gt; Terra.UserModifyUserResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Update a Terra user's reference_id or active status

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.user.modifyuser("user_id");
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**userId:** `string` — Terra user ID to update

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.UserModifyUserRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `User.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.user.&lt;a href="/src/api/resources/user/client/Client.ts"&gt;getinfoforuserid&lt;/a&gt;({ ...params }) -&gt; Terra.UserGetInfoForUserIdResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.user.getinfoforuserid();
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.UserGetInfoForUserIdRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `User.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.user.&lt;a href="/src/api/resources/user/client/Client.ts"&gt;getalluserids&lt;/a&gt;({ ...params }) -&gt; Terra.UserGetAllUserIDsResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.user.getalluserids();
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.UserGetAllUserIDsRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `User.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.user.&lt;a href="/src/api/resources/user/client/Client.ts"&gt;getinfoformultipleuserids&lt;/a&gt;({ ...params }) -&gt; Terra.TerraUser[]&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to query for information for multiple Terra User IDs

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.user.getinfoformultipleuserids(["string"]);
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `string[]`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `User.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Activity

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.activity.&lt;a href="/src/api/resources/activity/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.ActivityFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.activity.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.ActivityFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Activity.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.activity.&lt;a href="/src/api/resources/activity/client/Client.ts"&gt;write&lt;/a&gt;({ ...params }) -&gt; Terra.ActivityWriteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to post activity data to a provider. Available for Wahoo

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.activity.write({
    data: [
        {
            metadata: {
                end_time: "2022-10-28T10:00:00.000000+01:00",
                start_time: "1999-11-23T09:00:00.000000+02:00",
                summary_id: "123e4567-e89b-12d3-a456-426614174000",
                type: "0",
                upload_type: "0",
            },
        },
    ],
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.ActivityWriteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Activity.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Athlete

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.athlete.&lt;a href="/src/api/resources/athlete/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.AthleteFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches relevant profile info such as first &amp; last name, birth date etc. for a given user ID

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.athlete.fetch({
    user_id: "user_id",
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.AthleteFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Athlete.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Body

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.body.&lt;a href="/src/api/resources/body/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.BodyFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.body.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.BodyFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Body.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.body.&lt;a href="/src/api/resources/body/client/Client.ts"&gt;write&lt;/a&gt;({ ...params }) -&gt; Terra.BodyWriteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to post body data to a provider. Available for Google Fit

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.body.write({
    data: [
        {
            metadata: {
                end_time: "2022-10-28T10:00:00.000000+01:00",
                start_time: "1999-11-23T09:00:00.000000+02:00",
            },
        },
    ],
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.BodyWriteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Body.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.body.&lt;a href="/src/api/resources/body/client/Client.ts"&gt;delete&lt;/a&gt;({ ...params }) -&gt; Terra.BodyDeleteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to delete Body metrics the user has registered on their account

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.body.delete({
    user_id: "user_id",
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.BodyDeleteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Body.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Daily

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.daily.&lt;a href="/src/api/resources/daily/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.DailyFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.daily.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.DailyFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Daily.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Menstruation

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.menstruation.&lt;a href="/src/api/resources/menstruation/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.MenstruationFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.menstruation.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.MenstruationFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Menstruation.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Nutrition

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.nutrition.&lt;a href="/src/api/resources/nutrition/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.NutritionFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.nutrition.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.NutritionFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Nutrition.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.nutrition.&lt;a href="/src/api/resources/nutrition/client/Client.ts"&gt;write&lt;/a&gt;({ ...params }) -&gt; Terra.NutritionWriteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to post nutrition logs to a provider. Available for Fitbit

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.nutrition.write({
    data: [
        {
            metadata: {
                end_time: "2022-10-28T10:00:00.000000+01:00",
                start_time: "1999-11-23T09:00:00.000000+02:00",
            },
        },
    ],
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.NutritionWriteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Nutrition.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.nutrition.&lt;a href="/src/api/resources/nutrition/client/Client.ts"&gt;delete&lt;/a&gt;({ ...params }) -&gt; Terra.NutritionDeleteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to delete nutrition logs the user has registered on their account

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.nutrition.delete({
    user_id: "user_id",
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.NutritionDeleteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Nutrition.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Sleep

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.sleep.&lt;a href="/src/api/resources/sleep/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.SleepFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.sleep.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.SleepFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Sleep.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Plannedworkout

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.plannedworkout.&lt;a href="/src/api/resources/plannedworkout/client/Client.ts"&gt;fetch&lt;/a&gt;({ ...params }) -&gt; Terra.PlannedWorkoutFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to get workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.plannedworkout.fetch({
    user_id: "user_id",
    start_date: 1,
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.PlannedWorkoutFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Plannedworkout.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.plannedworkout.&lt;a href="/src/api/resources/plannedworkout/client/Client.ts"&gt;write&lt;/a&gt;({ ...params }) -&gt; Terra.PlannedWorkoutWriteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to post workout plans users can follow on their wearable. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.plannedworkout.write({
    data: [{}],
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.PlannedWorkoutWriteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Plannedworkout.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.plannedworkout.&lt;a href="/src/api/resources/plannedworkout/client/Client.ts"&gt;delete&lt;/a&gt;({ ...params }) -&gt; Terra.PlannedWorkoutDeleteResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Used to delete workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.plannedworkout.delete({
    user_id: "user_id",
});
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.PlannedWorkoutDeleteRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Plannedworkout.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

## Integrations

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.integrations.&lt;a href="/src/api/resources/integrations/client/Client.ts"&gt;fetch&lt;/a&gt;() -&gt; Terra.IntegrationsFetchResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Retrieve a list of all available provider integrations on the API.

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.integrations.fetch();
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Integrations.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;&lt;code&gt;client.integrations.&lt;a href="/src/api/resources/integrations/client/Client.ts"&gt;detailedfetch&lt;/a&gt;({ ...params }) -&gt; Terra.IntegrationsResponse&lt;/code&gt;&lt;/summary&gt;
&lt;dl&gt;
&lt;dd&gt;

#### 📝 Description

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### 🔌 Usage

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

```typescript
await client.integrations.detailedfetch();
```

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

#### ⚙️ Parameters

&lt;dl&gt;
&lt;dd&gt;

&lt;dl&gt;
&lt;dd&gt;

**request:** `Terra.IntegrationsDetailedFetchRequest`

&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dd&gt;

**requestOptions:** `Integrations.RequestOptions`

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;/dd&gt;
&lt;/dl&gt;
&lt;/details&gt;
</file>
    <file name="resolved-snippet-templates.md">```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.authenticateuser({
  resource: "resource",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.authenticateuser({
  resource: "resource",
  language: "language",
  reference_id: "reference_id",
  auth_success_redirect_url: "auth_success_redirect_url",
  auth_failure_redirect_url: "auth_failure_redirect_url",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
undefined;

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.generatewidgetsession({
  providers: "providers",
  language: "language",
  reference_id: "reference_id",
  auth_success_redirect_url: "auth_success_redirect_url",
  auth_failure_redirect_url: "auth_failure_redirect_url",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.deauthenticateuser({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.deauthenticateuser({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.generateauthtoken();

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.authentication.generateauthtoken();

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.user.modifyuser("user_id");

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.user.modifyuser("user_id", {
  reference_id: "reference_id",
  active: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
undefined;

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.user.getinfoforuserid({
  user_id: "user_id",
  reference_id: "reference_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
undefined;

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.user.getalluserids({
  page: 1,
  per_page: 1,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.user.getinfoformultipleuserids(
	{
		[
			"string"
		]
	}
)

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.user.getinfoformultipleuserids(
	{
		[
			"string",
			"string"
		]
	}
)

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.activity.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.activity.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
  with_samples: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.activity.write({
  data: [
    {
      metadata: {
        end_time: "2022-10-28T10:00:00.000000+01:00",
        start_time: "1999-11-23T09:00:00.000000+02:00",
        summary_id: "123e4567-e89b-12d3-a456-426614174000",
        type: "0",
        upload_type: "0",
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.activity.write({
  data: [
    {
      active_durations_data: {
        activity_seconds: 1.1,
        inactivity_seconds: 1.1,
        low_intensity_seconds: 1.1,
        moderate_intensity_seconds: 1.1,
        num_continuous_inactive_periods: 1,
        rest_seconds: 1.1,
        vigorous_intensity_seconds: 1.1,
        standing_hours_count: 1.1,
        standing_seconds: 1.1,
      },
      calories_data: {
        BMR_calories: 1,
        net_activity_calories: 1,
        net_intake_calories: 1,
        total_burned_calories: 1,
      },
      cheat_detection: 1,
      data_enrichment: {
        stress_score: 1,
      },
      device_data: {
        activation_timestamp: "activation_timestamp",
        hardware_version: "hardware_version",
        last_upload_date: "last_upload_date",
        manufacturer: "manufacturer",
        name: "name",
        sensor_state: "sensor_state",
        serial_number: "serial_number",
        software_version: "software_version",
      },
      distance_data: {
        summary: {
          distance_meters: 1,
          elevation: {
            avg_meters: 1.1,
            gain_actual_meters: 1.1,
            gain_planned_meters: 1.1,
            loss_actual_meters: 1.1,
            max_meters: 1.1,
            min_meters: 1.1,
          },
          floors_climbed: 1,
          steps: 1,
          swimming: {
            num_laps: 1,
            num_strokes: 1,
            pool_length_meters: 1,
          },
        },
      },
      energy_data: {
        energy_kilojoules: 1.1,
        energy_planned_kilojoules: 1.1,
      },
      heart_rate_data: {
        summary: {
          avg_hr_bpm: 1.1,
          avg_hrv_rmssd: 1.1,
          avg_hrv_sdnn: 1.1,
          max_hr_bpm: 1.1,
          min_hr_bpm: 1.1,
          resting_hr_bpm: 1.1,
          user_max_hr_bpm: 1.1,
        },
      },
      MET_data: {
        avg_level: 1.1,
        num_high_intensity_minutes: 1.1,
        num_inactive_minutes: 1.1,
        num_low_intensity_minutes: 1.1,
        num_moderate_intensity_minutes: 1.1,
      },
      metadata: {
        city: "city",
        country: "country",
        end_time: "end_time",
        name: "name",
        start_time: "start_time",
        state: "state",
        summary_id: "summary_id",
        timestamp_localization: 1.1,
        type: "0",
        upload_type: "0",
      },
      movement_data: {
        adjusted_max_speed_meters_per_second: 1.1,
        avg_cadence_rpm: 1.1,
        avg_pace_minutes_per_kilometer: 1.1,
        avg_speed_meters_per_second: 1.1,
        avg_torque_newton_meters: 1.1,
        avg_velocity_meters_per_second: 1.1,
        max_cadence_rpm: 1.1,
        max_pace_minutes_per_kilometer: 1.1,
        max_speed_meters_per_second: 1.1,
        max_torque_newton_meters: 1.1,
        max_velocity_meters_per_second: 1.1,
        normalized_speed_meters_per_second: 1.1,
      },
      oxygen_data: {
        avg_saturation_percentage: 1.1,
        vo2max_ml_per_min_per_kg: 1.1,
      },
      polyline_map_data: {
        summary_polyline: "summary_polyline",
      },
      power_data: {
        avg_watts: 1.1,
        max_watts: 1.1,
      },
      strain_data: {
        strain_level: 1.1,
      },
      work_data: {
        work_kilojoules: 1.1,
      },
    },
    {
      active_durations_data: {
        activity_seconds: 1.1,
        inactivity_seconds: 1.1,
        low_intensity_seconds: 1.1,
        moderate_intensity_seconds: 1.1,
        num_continuous_inactive_periods: 1,
        rest_seconds: 1.1,
        vigorous_intensity_seconds: 1.1,
        standing_hours_count: 1.1,
        standing_seconds: 1.1,
      },
      calories_data: {
        BMR_calories: 1,
        net_activity_calories: 1,
        net_intake_calories: 1,
        total_burned_calories: 1,
      },
      cheat_detection: 1,
      data_enrichment: {
        stress_score: 1,
      },
      device_data: {
        activation_timestamp: "activation_timestamp",
        hardware_version: "hardware_version",
        last_upload_date: "last_upload_date",
        manufacturer: "manufacturer",
        name: "name",
        sensor_state: "sensor_state",
        serial_number: "serial_number",
        software_version: "software_version",
      },
      distance_data: {
        summary: {
          distance_meters: 1,
          elevation: {
            avg_meters: 1.1,
            gain_actual_meters: 1.1,
            gain_planned_meters: 1.1,
            loss_actual_meters: 1.1,
            max_meters: 1.1,
            min_meters: 1.1,
          },
          floors_climbed: 1,
          steps: 1,
          swimming: {
            num_laps: 1,
            num_strokes: 1,
            pool_length_meters: 1,
          },
        },
      },
      energy_data: {
        energy_kilojoules: 1.1,
        energy_planned_kilojoules: 1.1,
      },
      heart_rate_data: {
        summary: {
          avg_hr_bpm: 1.1,
          avg_hrv_rmssd: 1.1,
          avg_hrv_sdnn: 1.1,
          max_hr_bpm: 1.1,
          min_hr_bpm: 1.1,
          resting_hr_bpm: 1.1,
          user_max_hr_bpm: 1.1,
        },
      },
      MET_data: {
        avg_level: 1.1,
        num_high_intensity_minutes: 1.1,
        num_inactive_minutes: 1.1,
        num_low_intensity_minutes: 1.1,
        num_moderate_intensity_minutes: 1.1,
      },
      metadata: {
        city: "city",
        country: "country",
        end_time: "end_time",
        name: "name",
        start_time: "start_time",
        state: "state",
        summary_id: "summary_id",
        timestamp_localization: 1.1,
        type: "0",
        upload_type: "0",
      },
      movement_data: {
        adjusted_max_speed_meters_per_second: 1.1,
        avg_cadence_rpm: 1.1,
        avg_pace_minutes_per_kilometer: 1.1,
        avg_speed_meters_per_second: 1.1,
        avg_torque_newton_meters: 1.1,
        avg_velocity_meters_per_second: 1.1,
        max_cadence_rpm: 1.1,
        max_pace_minutes_per_kilometer: 1.1,
        max_speed_meters_per_second: 1.1,
        max_torque_newton_meters: 1.1,
        max_velocity_meters_per_second: 1.1,
        normalized_speed_meters_per_second: 1.1,
      },
      oxygen_data: {
        avg_saturation_percentage: 1.1,
        vo2max_ml_per_min_per_kg: 1.1,
      },
      polyline_map_data: {
        summary_polyline: "summary_polyline",
      },
      power_data: {
        avg_watts: 1.1,
        max_watts: 1.1,
      },
      strain_data: {
        strain_level: 1.1,
      },
      work_data: {
        work_kilojoules: 1.1,
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.athlete.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.athlete.fetch({
  user_id: "user_id",
  to_webhook: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.body.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.body.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
  with_samples: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.body.write({
  data: [
    {
      metadata: {
        end_time: "2022-10-28T10:00:00.000000+01:00",
        start_time: "1999-11-23T09:00:00.000000+02:00",
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.body.write({
  data: [
    {
      device_data: {
        activation_timestamp: "activation_timestamp",
        hardware_version: "hardware_version",
        last_upload_date: "last_upload_date",
        manufacturer: "manufacturer",
        name: "name",
        sensor_state: "sensor_state",
        serial_number: "serial_number",
        software_version: "software_version",
      },
      heart_data: {
        heart_rate_data: {
          summary: {
            avg_hr_bpm: 1.1,
            avg_hrv_rmssd: 1.1,
            avg_hrv_sdnn: 1.1,
            max_hr_bpm: 1.1,
            min_hr_bpm: 1.1,
            resting_hr_bpm: 1.1,
            user_max_hr_bpm: 1.1,
          },
        },
      },
      hydration_data: {
        day_total_water_consumption_ml: 1.1,
      },
      metadata: {
        end_time: "end_time",
        start_time: "start_time",
        timestamp_localization: 1.1,
      },
      oxygen_data: {
        avg_saturation_percentage: 1.1,
        vo2max_ml_per_min_per_kg: 1.1,
      },
      glucose_data: {
        day_avg_blood_glucose_mg_per_dL: 1.1,
        gmi: 1.1,
        time_in_range: 1.1,
        sensor_usage: 1,
      },
    },
    {
      device_data: {
        activation_timestamp: "activation_timestamp",
        hardware_version: "hardware_version",
        last_upload_date: "last_upload_date",
        manufacturer: "manufacturer",
        name: "name",
        sensor_state: "sensor_state",
        serial_number: "serial_number",
        software_version: "software_version",
      },
      heart_data: {
        heart_rate_data: {
          summary: {
            avg_hr_bpm: 1.1,
            avg_hrv_rmssd: 1.1,
            avg_hrv_sdnn: 1.1,
            max_hr_bpm: 1.1,
            min_hr_bpm: 1.1,
            resting_hr_bpm: 1.1,
            user_max_hr_bpm: 1.1,
          },
        },
      },
      hydration_data: {
        day_total_water_consumption_ml: 1.1,
      },
      metadata: {
        end_time: "end_time",
        start_time: "start_time",
        timestamp_localization: 1.1,
      },
      oxygen_data: {
        avg_saturation_percentage: 1.1,
        vo2max_ml_per_min_per_kg: 1.1,
      },
      glucose_data: {
        day_avg_blood_glucose_mg_per_dL: 1.1,
        gmi: 1.1,
        time_in_range: 1.1,
        sensor_usage: 1,
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.body.delete({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.body.delete({
  user_id: "user_id",
  log_ids: ["log_ids", "log_ids"],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.daily.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.daily.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
  with_samples: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.menstruation.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.menstruation.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
  with_samples: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.nutrition.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.nutrition.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
  with_samples: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.nutrition.write({
  data: [
    {
      metadata: {
        end_time: "2022-10-28T10:00:00.000000+01:00",
        start_time: "1999-11-23T09:00:00.000000+02:00",
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.nutrition.write({
  data: [
    {
      metadata: {
        end_time: "end_time",
        start_time: "start_time",
        timestamp_localization: 1.1,
      },
      summary: {
        macros: {
          alcohol_g: 1.1,
          calories: 1.1,
          carbohydrates_g: 1.1,
          cholesterol_mg: 1.1,
          fat_g: 1.1,
          fiber_g: 1.1,
          net_carbohydrates_g: 1.1,
          protein_g: 1.1,
          saturated_fat_g: 1.1,
          sodium_mg: 1.1,
          sugar_g: 1.1,
          trans_fat_g: 1.1,
        },
        micros: {
          biotin_mg: 1.1,
          caffeine_mg: 1.1,
          calcium_mg: 1.1,
          chloride_mg: 1.1,
          chromium_mg: 1.1,
          copper_mg: 1.1,
          folate_mg: 1.1,
          folic_acid_mg: 1.1,
          iodine_mg: 1.1,
          iron_mg: 1.1,
          magnesium_mg: 1.1,
          manganese_mg: 1.1,
          molybdenum_mg: 1.1,
          niacin_mg: 1.1,
          pantothenic_acid_mg: 1.1,
          phosphorus_mg: 1.1,
          potassium_mg: 1.1,
          riboflavin_mg: 1.1,
          selenium_mg: 1.1,
          thiamin_mg: 1.1,
          vitamin_A_mg: 1.1,
          vitamin_B12_mg: 1.1,
          vitamin_B6_mg: 1.1,
          vitamin_C_mg: 1.1,
          vitamin_D_mg: 1.1,
          vitamin_D2_mg: 1.1,
          vitamin_D3_mg: 1.1,
          vitamin_E_mg: 1.1,
          vitamin_K_mg: 1.1,
          zinc_mg: 1.1,
          cystine_g: 1.1,
          histidine_g: 1.1,
          isoleucine_g: 1.1,
          leucine_g: 1.1,
          lysine_g: 1.1,
          methionine_g: 1.1,
          phenylalanine_g: 1.1,
          threonine_g: 1.1,
          tryptophan_g: 1.1,
          tyrosine_g: 1.1,
          valine_g: 1.1,
          monounsaturated_fat_g: 1.1,
          polyunsaturated_fat_g: 1.1,
          omega3_g: 1.1,
          omega6_g: 1.1,
          starch_g: 1.1,
        },
        water_ml: 1.1,
        drink_ml: 1.1,
      },
    },
    {
      metadata: {
        end_time: "end_time",
        start_time: "start_time",
        timestamp_localization: 1.1,
      },
      summary: {
        macros: {
          alcohol_g: 1.1,
          calories: 1.1,
          carbohydrates_g: 1.1,
          cholesterol_mg: 1.1,
          fat_g: 1.1,
          fiber_g: 1.1,
          net_carbohydrates_g: 1.1,
          protein_g: 1.1,
          saturated_fat_g: 1.1,
          sodium_mg: 1.1,
          sugar_g: 1.1,
          trans_fat_g: 1.1,
        },
        micros: {
          biotin_mg: 1.1,
          caffeine_mg: 1.1,
          calcium_mg: 1.1,
          chloride_mg: 1.1,
          chromium_mg: 1.1,
          copper_mg: 1.1,
          folate_mg: 1.1,
          folic_acid_mg: 1.1,
          iodine_mg: 1.1,
          iron_mg: 1.1,
          magnesium_mg: 1.1,
          manganese_mg: 1.1,
          molybdenum_mg: 1.1,
          niacin_mg: 1.1,
          pantothenic_acid_mg: 1.1,
          phosphorus_mg: 1.1,
          potassium_mg: 1.1,
          riboflavin_mg: 1.1,
          selenium_mg: 1.1,
          thiamin_mg: 1.1,
          vitamin_A_mg: 1.1,
          vitamin_B12_mg: 1.1,
          vitamin_B6_mg: 1.1,
          vitamin_C_mg: 1.1,
          vitamin_D_mg: 1.1,
          vitamin_D2_mg: 1.1,
          vitamin_D3_mg: 1.1,
          vitamin_E_mg: 1.1,
          vitamin_K_mg: 1.1,
          zinc_mg: 1.1,
          cystine_g: 1.1,
          histidine_g: 1.1,
          isoleucine_g: 1.1,
          leucine_g: 1.1,
          lysine_g: 1.1,
          methionine_g: 1.1,
          phenylalanine_g: 1.1,
          threonine_g: 1.1,
          tryptophan_g: 1.1,
          tyrosine_g: 1.1,
          valine_g: 1.1,
          monounsaturated_fat_g: 1.1,
          polyunsaturated_fat_g: 1.1,
          omega3_g: 1.1,
          omega6_g: 1.1,
          starch_g: 1.1,
        },
        water_ml: 1.1,
        drink_ml: 1.1,
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.nutrition.delete({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.nutrition.delete({
  user_id: "user_id",
  data: ["data", "data"],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.sleep.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.sleep.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
  with_samples: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.plannedworkout.fetch({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.plannedworkout.fetch({
  user_id: "user_id",
  end_date: 1,
  to_webhook: true,
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.plannedworkout.write({
  data: [
    {
      metadata: {
        type: "IN_VEHICLE",
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.plannedworkout.write({
  data: [
    {
      metadata: {
        estimated_energy_kj: 1.1,
        estimated_speed_meters_per_second: 1.1,
        estimated_elevation_gain_meters: 1.1,
        estimated_tss: 1.1,
        estimated_calories: 1,
        created_date: "2024-01-15T09:30:00Z",
        planned_date: "2024-01-15T09:30:00Z",
        type: "IN_VEHICLE",
        id: "id",
        estimated_duration_seconds: 1,
        estimated_pace_minutes_per_kilometer: 1.1,
        provider: "provider",
        estimated_tscore: 1.1,
        description: "description",
        name: "name",
        estimated_distance_meters: 1,
        estimated_if: 1.1,
        pool_length_meters: 1,
      },
    },
    {
      metadata: {
        estimated_energy_kj: 1.1,
        estimated_speed_meters_per_second: 1.1,
        estimated_elevation_gain_meters: 1.1,
        estimated_tss: 1.1,
        estimated_calories: 1,
        created_date: "2024-01-15T09:30:00Z",
        planned_date: "2024-01-15T09:30:00Z",
        type: "IN_VEHICLE",
        id: "id",
        estimated_duration_seconds: 1,
        estimated_pace_minutes_per_kilometer: 1.1,
        provider: "provider",
        estimated_tscore: 1.1,
        description: "description",
        name: "name",
        estimated_distance_meters: 1,
        estimated_if: 1.1,
        pool_length_meters: 1,
      },
    },
  ],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.plannedworkout.delete({
  user_id: "user_id",
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.plannedworkout.delete({
  user_id: "user_id",
  data: ["data", "data"],
});

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.integrations.fetch();

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.integrations.fetch();

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
undefined;

```


```typescript
import { TerraClient } from "terra";

const client = new TerraClient({ apiKey: "YOUR_AUTHORIZATION" });
await client.integrations.detailedfetch({
  sdk: true,
});

```


</file>
    <directory name="src">
      <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "./environments.js";
import * as core from "./core/index.js";
import { mergeHeaders } from "./core/headers.js";
import { Authentication } from "./api/resources/authentication/client/Client.js";
import { User } from "./api/resources/user/client/Client.js";
import { Activity } from "./api/resources/activity/client/Client.js";
import { Athlete } from "./api/resources/athlete/client/Client.js";
import { Body } from "./api/resources/body/client/Client.js";
import { Daily } from "./api/resources/daily/client/Client.js";
import { Menstruation } from "./api/resources/menstruation/client/Client.js";
import { Nutrition } from "./api/resources/nutrition/client/Client.js";
import { Sleep } from "./api/resources/sleep/client/Client.js";
import { Plannedworkout } from "./api/resources/plannedworkout/client/Client.js";
import { Integrations } from "./api/resources/integrations/client/Client.js";

export declare namespace TerraClient {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class TerraClient {
    protected readonly _options: TerraClient.Options;
    protected _authentication: Authentication | undefined;
    protected _user: User | undefined;
    protected _activity: Activity | undefined;
    protected _athlete: Athlete | undefined;
    protected _body: Body | undefined;
    protected _daily: Daily | undefined;
    protected _menstruation: Menstruation | undefined;
    protected _nutrition: Nutrition | undefined;
    protected _sleep: Sleep | undefined;
    protected _plannedworkout: Plannedworkout | undefined;
    protected _integrations: Integrations | undefined;

    constructor(_options: TerraClient.Options) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "dev-id": _options?.devId,
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "terra",
                    "X-Fern-SDK-Version": "0.0.1",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    public get authentication(): Authentication {
        return (this._authentication ??= new Authentication(this._options));
    }

    public get user(): User {
        return (this._user ??= new User(this._options));
    }

    public get activity(): Activity {
        return (this._activity ??= new Activity(this._options));
    }

    public get athlete(): Athlete {
        return (this._athlete ??= new Athlete(this._options));
    }

    public get body(): Body {
        return (this._body ??= new Body(this._options));
    }

    public get daily(): Daily {
        return (this._daily ??= new Daily(this._options));
    }

    public get menstruation(): Menstruation {
        return (this._menstruation ??= new Menstruation(this._options));
    }

    public get nutrition(): Nutrition {
        return (this._nutrition ??= new Nutrition(this._options));
    }

    public get sleep(): Sleep {
        return (this._sleep ??= new Sleep(this._options));
    }

    public get plannedworkout(): Plannedworkout {
        return (this._plannedworkout ??= new Plannedworkout(this._options));
    }

    public get integrations(): Integrations {
        return (this._integrations ??= new Integrations(this._options));
    }
}
</file>
      <file name="environments.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export const TerraEnvironment = {
    Default: "https://api.tryterra.co/v2",
} as const;

export type TerraEnvironment = typeof TerraEnvironment.Default;
</file>
      <file name="index.ts">export * as Terra from "./api/index.js";
export { TerraClient } from "./Client.js";
export { TerraEnvironment } from "./environments.js";
export { TerraError, TerraTimeoutError } from "./errors/index.js";
export { WebhooksHelper } from "./wrapper/WebhooksHelper";</file>
      <file name="version.ts">export const SDK_VERSION = "0.0.1";
</file>
      <directory name="api">
        <file name="index.ts">export * from "./resources/index.js";
export * from "./types/index.js";
export * from "./errors/index.js";
</file>
        <directory name="errors">
          <file name="BadRequestError.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../errors/index.js";
import * as core from "../../core/index.js";

export class BadRequestError extends errors.TerraError {
    constructor(body?: unknown, rawResponse?: core.RawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, BadRequestError.prototype);
    }
}
</file>
          <file name="NotFoundError.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../errors/index.js";
import * as core from "../../core/index.js";

export class NotFoundError extends errors.TerraError {
    constructor(body?: unknown, rawResponse?: core.RawResponse) {
        super({
            message: "NotFoundError",
            statusCode: 404,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }
}
</file>
          <file name="UnauthorizedError.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../errors/index.js";
import * as core from "../../core/index.js";

export class UnauthorizedError extends errors.TerraError {
    constructor(body?: unknown, rawResponse?: core.RawResponse) {
        super({
            message: "UnauthorizedError",
            statusCode: 401,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, UnauthorizedError.prototype);
    }
}
</file>
          <file name="index.ts">export * from "./BadRequestError.js";
export * from "./NotFoundError.js";
export * from "./UnauthorizedError.js";
</file>
        </directory>
        <directory name="resources">
          <file name="index.ts">export * as authentication from "./authentication/index.js";
export * from "./authentication/types/index.js";
export * as user from "./user/index.js";
export * from "./user/types/index.js";
export * as activity from "./activity/index.js";
export * from "./activity/types/index.js";
export * as athlete from "./athlete/index.js";
export * from "./athlete/types/index.js";
export * as body from "./body/index.js";
export * from "./body/types/index.js";
export * as daily from "./daily/index.js";
export * from "./daily/types/index.js";
export * as menstruation from "./menstruation/index.js";
export * from "./menstruation/types/index.js";
export * as nutrition from "./nutrition/index.js";
export * from "./nutrition/types/index.js";
export * as sleep from "./sleep/index.js";
export * from "./sleep/types/index.js";
export * as plannedworkout from "./plannedworkout/index.js";
export * from "./plannedworkout/types/index.js";
export * as integrations from "./integrations/index.js";
export * from "./integrations/types/index.js";
export * from "./authentication/client/requests/index.js";
export * from "./user/client/requests/index.js";
export * from "./activity/client/requests/index.js";
export * from "./athlete/client/requests/index.js";
export * from "./body/client/requests/index.js";
export * from "./daily/client/requests/index.js";
export * from "./menstruation/client/requests/index.js";
export * from "./nutrition/client/requests/index.js";
export * from "./sleep/client/requests/index.js";
export * from "./plannedworkout/client/requests/index.js";
export * from "./integrations/client/requests/index.js";
</file>
          <directory name="activity">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Activity {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Activity {
    protected readonly _options: Activity.Options;

    constructor(_options: Activity.Options) {
        this._options = _options;
    }

    /**
     * Fetches completed workout sessions, with a defined start and end time and activity type (e.g. running, cycling, etc.)
     *
     * @param {Terra.ActivityFetchRequest} request
     * @param {Activity.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.activity.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.ActivityFetchRequest,
        requestOptions?: Activity.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.ActivityFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.ActivityFetchRequest,
        requestOptions?: Activity.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.ActivityFetchResponse&gt;&gt; {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "activity",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.ActivityFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /activity.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post activity data to a provider. Available for Wahoo
     *
     * @param {Terra.ActivityWriteRequest} request
     * @param {Activity.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.activity.write({
     *         data: [{
     *                 metadata: {
     *                     end_time: "2022-10-28T10:00:00.000000+01:00",
     *                     start_time: "1999-11-23T09:00:00.000000+02:00",
     *                     summary_id: "123e4567-e89b-12d3-a456-426614174000",
     *                     type: "0",
     *                     upload_type: "0"
     *                 }
     *             }]
     *     })
     */
    public write(
        request: Terra.ActivityWriteRequest,
        requestOptions?: Activity.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.ActivityWriteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.ActivityWriteRequest,
        requestOptions?: Activity.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.ActivityWriteResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "activity",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.ActivityWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /activity.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="ActivityFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface ActivityFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.ActivityFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}
</file>
                <file name="ActivityWriteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{
 *                 metadata: {
 *                     end_time: "2022-10-28T10:00:00.000000+01:00",
 *                     start_time: "1999-11-23T09:00:00.000000+02:00",
 *                     summary_id: "123e4567-e89b-12d3-a456-426614174000",
 *                     type: "0",
 *                     upload_type: "0"
 *                 }
 *             }]
 *     }
 */
export interface ActivityWriteRequest {
    /** List of user-tracked workouts to post to data provider */
    data: Terra.Activity[];
}
</file>
                <file name="index.ts">export { type ActivityFetchRequest } from "./ActivityFetchRequest.js";
export { type ActivityWriteRequest } from "./ActivityWriteRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="ActivityFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ActivityFetchRequestStartDate = number | string;
</file>
              <file name="ActivityFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type ActivityFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Activity[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;
</file>
              <file name="ActivityWriteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface ActivityWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}
</file>
              <file name="index.ts">export * from "./ActivityFetchRequestStartDate.js";
export * from "./ActivityFetchResponse.js";
export * from "./ActivityWriteResponse.js";
</file>
            </directory>
          </directory>
          <directory name="athlete">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Athlete {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Athlete {
    protected readonly _options: Athlete.Options;

    constructor(_options: Athlete.Options) {
        this._options = _options;
    }

    /**
     * Fetches relevant profile info such as first &amp; last name, birth date etc. for a given user ID
     *
     * @param {Terra.AthleteFetchRequest} request
     * @param {Athlete.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.athlete.fetch({
     *         user_id: "user_id"
     *     })
     */
    public fetch(
        request: Terra.AthleteFetchRequest,
        requestOptions?: Athlete.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.AthleteFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.AthleteFetchRequest,
        requestOptions?: Athlete.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.AthleteFetchResponse&gt;&gt; {
        const { user_id: userId, to_webhook: toWebhook } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "athlete",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.AthleteFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /athlete.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="AthleteFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface AthleteFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
}
</file>
                <file name="index.ts">export { type AthleteFetchRequest } from "./AthleteFetchRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="AthleteFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type AthleteFetchResponse =
    | Terra.AthleteFetchResponse.Athlete
    | Terra.AthleteFetchResponse.NoData
    | Terra.AthleteFetchResponse.Webhook;

export namespace AthleteFetchResponse {
    export interface Athlete extends Terra.AthleteCollection {
        type: "athlete";
    }

    export interface NoData extends Terra.NoDataReturned {
        type: "no_data";
    }

    export interface Webhook extends Terra.DataSentToWebhook {
        type: "webhook";
    }
}
</file>
              <file name="index.ts">export * from "./AthleteFetchResponse.js";
</file>
            </directory>
          </directory>
          <directory name="authentication">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Authentication {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Authentication {
    protected readonly _options: Authentication.Options;

    constructor(_options: Authentication.Options) {
        this._options = _options;
    }

    /**
     * Creates a login link that allows end users to connect their fitness tracking account
     *
     * @param {Terra.AuthenticationAuthenticateUserRequest} request
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.authentication.authenticateuser({
     *         resource: "resource"
     *     })
     */
    public authenticateuser(
        request: Terra.AuthenticationAuthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.AuthenticationAuthenticateUserResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__authenticateuser(request, requestOptions));
    }

    private async __authenticateuser(
        request: Terra.AuthenticationAuthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.AuthenticationAuthenticateUserResponse&gt;&gt; {
        const { resource, ..._body } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["resource"] = resource;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/authenticateUser",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationAuthenticateUserResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /auth/authenticateUser.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Generates a link to redirect an end user to for them to select an integration and log in with their fitness data provider
     *
     * @param {Terra.WidgetSessionParams} request
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     *
     * @example
     *     await client.authentication.generatewidgetsession()
     */
    public generatewidgetsession(
        request: Terra.WidgetSessionParams = {},
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.AuthenticationGenerateWidgetSessionResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__generatewidgetsession(request, requestOptions));
    }

    private async __generatewidgetsession(
        request: Terra.WidgetSessionParams = {},
        requestOptions?: Authentication.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.AuthenticationGenerateWidgetSessionResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/generateWidgetSession",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationGenerateWidgetSessionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /auth/generateWidgetSession.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes all records of the user on Terra's end, revoking Terra's access to their data
     *
     * @param {Terra.AuthenticationDeauthenticateUserRequest} request
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.authentication.deauthenticateuser({
     *         user_id: "user_id"
     *     })
     */
    public deauthenticateuser(
        request: Terra.AuthenticationDeauthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.AuthenticationDeauthenticateUserResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__deauthenticateuser(request, requestOptions));
    }

    private async __deauthenticateuser(
        request: Terra.AuthenticationDeauthenticateUserRequest,
        requestOptions?: Authentication.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.AuthenticationDeauthenticateUserResponse&gt;&gt; {
        const { user_id: userId } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/deauthenticateUser",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationDeauthenticateUserResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /auth/deauthenticateUser.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a token to be used with initConnection() functions in the Terra mobile SDKs in order to create a user record for Apple Health or Samsung Health (or equivalent)
     *
     * @param {Authentication.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.authentication.generateauthtoken()
     */
    public generateauthtoken(
        requestOptions?: Authentication.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.AuthenticationGenerateAuthTokenResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__generateauthtoken(requestOptions));
    }

    private async __generateauthtoken(
        requestOptions?: Authentication.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.AuthenticationGenerateAuthTokenResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "auth/generateAuthToken",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Terra.AuthenticationGenerateAuthTokenResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /auth/generateAuthToken.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="AuthenticationAuthenticateUserRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         resource: "resource"
 *     }
 */
export interface AuthenticationAuthenticateUserRequest {
    /**
     * resource to authenticate user with
     */
    resource: string;
    language?: string;
    reference_id?: string;
    auth_success_redirect_url?: string;
    auth_failure_redirect_url?: string;
}
</file>
                <file name="AuthenticationDeauthenticateUserRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface AuthenticationDeauthenticateUserRequest {
    /**
     * user_id to deauthenticate for
     */
    user_id: string;
}
</file>
                <file name="WidgetSessionParams.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface WidgetSessionParams {
    /** Comma separated list of providers to display on the device selection page. This overrides your selected sources on your dashboard */
    providers?: string;
    /** Display language of the widget */
    language?: string;
    /** Identifier of the end user on your system, such as a user ID or email associated with them */
    reference_id?: string;
    /** URL the user is redirected to upon successful authentication */
    auth_success_redirect_url?: string;
    /** URL the user is redirected to upon unsuccessful authentication */
    auth_failure_redirect_url?: string;
}
</file>
                <file name="index.ts">export { type AuthenticationAuthenticateUserRequest } from "./AuthenticationAuthenticateUserRequest.js";
export { type WidgetSessionParams } from "./WidgetSessionParams.js";
export { type AuthenticationDeauthenticateUserRequest } from "./AuthenticationDeauthenticateUserRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="AuthenticationAuthenticateUserResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationAuthenticateUserResponse {
    /** indicates that the request was successful */
    status?: AuthenticationAuthenticateUserResponse.Status;
    /** User ID for the user being created */
    user_id?: string;
    /** authentication URL the user must be redirected to in order to link their account */
    auth_url?: string;
}

export namespace AuthenticationAuthenticateUserResponse {
    /**
     * indicates that the request was successful
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
              <file name="AuthenticationDeauthenticateUserResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationDeauthenticateUserResponse {
    /** indicates that an error happened (value is success) */
    status?: AuthenticationDeauthenticateUserResponse.Status;
}

export namespace AuthenticationDeauthenticateUserResponse {
    /**
     * indicates that an error happened (value is success)
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
              <file name="AuthenticationGenerateAuthTokenResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationGenerateAuthTokenResponse {
    status?: string;
    token?: string;
    expires_in?: number;
}
</file>
              <file name="AuthenticationGenerateWidgetSessionResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AuthenticationGenerateWidgetSessionResponse {
    /** Session ID for the widget authentication session */
    session_id?: string;
    /** the widget URL the user must be redirected to in order to link their account */
    url?: string;
    /** indicates that an error happened (value is success) */
    status?: AuthenticationGenerateWidgetSessionResponse.Status;
    /** a number in seconds depicting how long the url is valid for */
    expires_in?: number;
}

export namespace AuthenticationGenerateWidgetSessionResponse {
    /**
     * indicates that an error happened (value is success)
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
              <file name="index.ts">export * from "./AuthenticationAuthenticateUserResponse.js";
export * from "./AuthenticationGenerateWidgetSessionResponse.js";
export * from "./AuthenticationDeauthenticateUserResponse.js";
export * from "./AuthenticationGenerateAuthTokenResponse.js";
</file>
            </directory>
          </directory>
          <directory name="body">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Body {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Body {
    protected readonly _options: Body.Options;

    constructor(_options: Body.Options) {
        this._options = _options;
    }

    /**
     * Fetches body metrics such as weight, height, body fat percentage etc. for a given user ID
     *
     * @param {Terra.BodyFetchRequest} request
     * @param {Body.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.body.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.BodyFetchRequest,
        requestOptions?: Body.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.BodyFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.BodyFetchRequest,
        requestOptions?: Body.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.BodyFetchResponse&gt;&gt; {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "body",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.BodyFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /body.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post body data to a provider. Available for Google Fit
     *
     * @param {Terra.BodyWriteRequest} request
     * @param {Body.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.body.write({
     *         data: [{
     *                 metadata: {
     *                     end_time: "2022-10-28T10:00:00.000000+01:00",
     *                     start_time: "1999-11-23T09:00:00.000000+02:00"
     *                 }
     *             }]
     *     })
     */
    public write(
        request: Terra.BodyWriteRequest,
        requestOptions?: Body.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.BodyWriteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.BodyWriteRequest,
        requestOptions?: Body.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.BodyWriteResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "body",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.BodyWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /body.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to delete Body metrics the user has registered on their account
     *
     * @param {Terra.BodyDeleteRequest} request
     * @param {Body.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.body.delete({
     *         user_id: "user_id"
     *     })
     */
    public delete(
        request: Terra.BodyDeleteRequest,
        requestOptions?: Body.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.BodyDeleteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Terra.BodyDeleteRequest,
        requestOptions?: Body.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.BodyDeleteResponse&gt;&gt; {
        const { user_id: userId, ..._body } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "body",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.BodyDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /body.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="BodyDeleteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface BodyDeleteRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /** List of identifiers for body metrics entries to be deleted */
    log_ids?: string[];
}
</file>
                <file name="BodyFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface BodyFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.BodyFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}
</file>
                <file name="BodyWriteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{
 *                 metadata: {
 *                     end_time: "2022-10-28T10:00:00.000000+01:00",
 *                     start_time: "1999-11-23T09:00:00.000000+02:00"
 *                 }
 *             }]
 *     }
 */
export interface BodyWriteRequest {
    /** Body measurement metrics to post to data provider */
    data: Terra.Body[];
}
</file>
                <file name="index.ts">export { type BodyFetchRequest } from "./BodyFetchRequest.js";
export { type BodyWriteRequest } from "./BodyWriteRequest.js";
export { type BodyDeleteRequest } from "./BodyDeleteRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="BodyDeleteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface BodyDeleteResponse {
    user?: Terra.TerraUser;
    processed_data?: BodyDeleteResponse.ProcessedData.Item[];
}

export namespace BodyDeleteResponse {
    export type ProcessedData = ProcessedData.Item[];

    export namespace ProcessedData {
        export interface Item {
            /** Identifier of the body metric entries whose deletion was attempted */
            id?: string;
            /** Response code from the provider when attempting to delete the body metric entries */
            response_code?: number;
        }
    }
}
</file>
              <file name="BodyFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type BodyFetchRequestStartDate = number | string;
</file>
              <file name="BodyFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type BodyFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Body[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;
</file>
              <file name="BodyWriteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface BodyWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}
</file>
              <file name="index.ts">export * from "./BodyFetchRequestStartDate.js";
export * from "./BodyFetchResponse.js";
export * from "./BodyWriteResponse.js";
export * from "./BodyDeleteResponse.js";
</file>
            </directory>
          </directory>
          <directory name="daily">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Daily {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Daily {
    protected readonly _options: Daily.Options;

    constructor(_options: Daily.Options) {
        this._options = _options;
    }

    /**
     * Fetches daily summaries of activity metrics such as steps, distance, calories burned etc. for a given user ID
     *
     * @param {Terra.DailyFetchRequest} request
     * @param {Daily.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.daily.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.DailyFetchRequest,
        requestOptions?: Daily.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.DailyFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.DailyFetchRequest,
        requestOptions?: Daily.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.DailyFetchResponse&gt;&gt; {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "daily",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.DailyFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /daily.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="DailyFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface DailyFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.DailyFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}
</file>
                <file name="index.ts">export { type DailyFetchRequest } from "./DailyFetchRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="DailyFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type DailyFetchRequestStartDate = number | string;
</file>
              <file name="DailyFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type DailyFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Daily[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;
</file>
              <file name="index.ts">export * from "./DailyFetchRequestStartDate.js";
export * from "./DailyFetchResponse.js";
</file>
            </directory>
          </directory>
          <directory name="integrations">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Integrations {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Integrations {
    protected readonly _options: Integrations.Options;

    constructor(_options: Integrations.Options) {
        this._options = _options;
    }

    /**
     * Retrieve a list of all available provider integrations on the API.
     *
     * @param {Integrations.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.integrations.fetch()
     */
    public fetch(
        requestOptions?: Integrations.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.IntegrationsFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(requestOptions));
    }

    private async __fetch(
        requestOptions?: Integrations.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.IntegrationsFetchResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "integrations",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.IntegrationsFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TerraError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /integrations.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a detailed list of supported integrations, optionally filtered by the developer's enabled integrations and the requirement for SDK usage.
     *
     * @param {Terra.IntegrationsDetailedFetchRequest} request
     * @param {Integrations.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.integrations.detailedfetch()
     */
    public detailedfetch(
        request: Terra.IntegrationsDetailedFetchRequest = {},
        requestOptions?: Integrations.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.IntegrationsResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__detailedfetch(request, requestOptions));
    }

    private async __detailedfetch(
        request: Terra.IntegrationsDetailedFetchRequest = {},
        requestOptions?: Integrations.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.IntegrationsResponse&gt;&gt; {
        const { sdk } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        if (sdk != null) {
            _queryParams["sdk"] = sdk.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "integrations/detailed",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.IntegrationsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TerraError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /integrations/detailed.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="IntegrationsDetailedFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface IntegrationsDetailedFetchRequest {
    /**
     * If `true`, allows SDK integrations to be included in the response.
     */
    sdk?: boolean;
}
</file>
                <file name="index.ts">export { type IntegrationsDetailedFetchRequest } from "./IntegrationsDetailedFetchRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="IntegrationsFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface IntegrationsFetchResponse {
    providers?: string[];
    sdk_resource?: string[];
    status?: IntegrationsFetchResponse.Status;
}

export namespace IntegrationsFetchResponse {
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
              <file name="index.ts">export * from "./IntegrationsFetchResponse.js";
</file>
            </directory>
          </directory>
          <directory name="menstruation">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Menstruation {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Menstruation {
    protected readonly _options: Menstruation.Options;

    constructor(_options: Menstruation.Options) {
        this._options = _options;
    }

    /**
     * Fetches menstruation data such as cycle length, period length, ovulation date etc. for a given user ID
     *
     * @param {Terra.MenstruationFetchRequest} request
     * @param {Menstruation.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.menstruation.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.MenstruationFetchRequest,
        requestOptions?: Menstruation.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.MenstruationFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.MenstruationFetchRequest,
        requestOptions?: Menstruation.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.MenstruationFetchResponse&gt;&gt; {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "menstruation",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.MenstruationFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /menstruation.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="MenstruationFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface MenstruationFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.MenstruationFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}
</file>
                <file name="index.ts">export { type MenstruationFetchRequest } from "./MenstruationFetchRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="MenstruationFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type MenstruationFetchRequestStartDate = number | string;
</file>
              <file name="MenstruationFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type MenstruationFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Menstruation[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;
</file>
              <file name="index.ts">export * from "./MenstruationFetchRequestStartDate.js";
export * from "./MenstruationFetchResponse.js";
</file>
            </directory>
          </directory>
          <directory name="nutrition">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Nutrition {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Nutrition {
    protected readonly _options: Nutrition.Options;

    constructor(_options: Nutrition.Options) {
        this._options = _options;
    }

    /**
     * Fetches nutrition log data such as meal type, calories, macronutrients etc. for a given user ID
     *
     * @param {Terra.NutritionFetchRequest} request
     * @param {Nutrition.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.nutrition.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.NutritionFetchRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.NutritionFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.NutritionFetchRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.NutritionFetchResponse&gt;&gt; {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "nutrition",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.NutritionFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /nutrition.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post nutrition logs to a provider. Available for Fitbit
     *
     * @param {Terra.NutritionWriteRequest} request
     * @param {Nutrition.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.nutrition.write({
     *         data: [{
     *                 metadata: {
     *                     end_time: "2022-10-28T10:00:00.000000+01:00",
     *                     start_time: "1999-11-23T09:00:00.000000+02:00"
     *                 }
     *             }]
     *     })
     */
    public write(
        request: Terra.NutritionWriteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.NutritionWriteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.NutritionWriteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.NutritionWriteResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "nutrition",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.NutritionWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /nutrition.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to delete nutrition logs the user has registered on their account
     *
     * @param {Terra.NutritionDeleteRequest} request
     * @param {Nutrition.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.nutrition.delete({
     *         user_id: "user_id"
     *     })
     */
    public delete(
        request: Terra.NutritionDeleteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.NutritionDeleteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Terra.NutritionDeleteRequest,
        requestOptions?: Nutrition.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.NutritionDeleteResponse&gt;&gt; {
        const { user_id: userId, ..._body } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "nutrition",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.NutritionDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /nutrition.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="NutritionDeleteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface NutritionDeleteRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /** List of identifiers for nutrition entries to be deleted */
    data?: string[];
}
</file>
                <file name="NutritionFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface NutritionFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.NutritionFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}
</file>
                <file name="NutritionWriteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{
 *                 metadata: {
 *                     end_time: "2022-10-28T10:00:00.000000+01:00",
 *                     start_time: "1999-11-23T09:00:00.000000+02:00"
 *                 }
 *             }]
 *     }
 */
export interface NutritionWriteRequest {
    /** Nutrition entry to post to data provider */
    data: Terra.Nutrition[];
}
</file>
                <file name="index.ts">export { type NutritionFetchRequest } from "./NutritionFetchRequest.js";
export { type NutritionWriteRequest } from "./NutritionWriteRequest.js";
export { type NutritionDeleteRequest } from "./NutritionDeleteRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="NutritionDeleteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface NutritionDeleteResponse {
    user?: Terra.TerraUser;
    processed_data?: NutritionDeleteResponse.ProcessedData.Item[];
}

export namespace NutritionDeleteResponse {
    export type ProcessedData = ProcessedData.Item[];

    export namespace ProcessedData {
        export interface Item {
            /** Identifier of the nutrition log whose deletion was attempted */
            id?: string;
            /** Response code from the provider when attempting to delete the nutrition log */
            response_code?: number;
        }
    }
}
</file>
              <file name="NutritionFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type NutritionFetchRequestStartDate = number | string;
</file>
              <file name="NutritionFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type NutritionFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Nutrition[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;
</file>
              <file name="NutritionWriteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface NutritionWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}
</file>
              <file name="index.ts">export * from "./NutritionFetchRequestStartDate.js";
export * from "./NutritionFetchResponse.js";
export * from "./NutritionWriteResponse.js";
export * from "./NutritionDeleteResponse.js";
</file>
            </directory>
          </directory>
          <directory name="plannedworkout">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Plannedworkout {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Plannedworkout {
    protected readonly _options: Plannedworkout.Options;

    constructor(_options: Plannedworkout.Options) {
        this._options = _options;
    }

    /**
     * Used to get workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
     *
     * @param {Terra.PlannedWorkoutFetchRequest} request
     * @param {Plannedworkout.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.plannedworkout.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.PlannedWorkoutFetchRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.PlannedWorkoutFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.PlannedWorkoutFetchRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.PlannedWorkoutFetchResponse&gt;&gt; {
        const { user_id: userId, start_date: startDate, end_date: endDate, to_webhook: toWebhook } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "plannedWorkout",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.PlannedWorkoutFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /plannedWorkout.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to post workout plans users can follow on their wearable. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
     *
     * @param {Terra.PlannedWorkoutWriteRequest} request
     * @param {Plannedworkout.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.plannedworkout.write({
     *         data: [{}]
     *     })
     */
    public write(
        request: Terra.PlannedWorkoutWriteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.PlannedWorkoutWriteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__write(request, requestOptions));
    }

    private async __write(
        request: Terra.PlannedWorkoutWriteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.PlannedWorkoutWriteResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "plannedWorkout",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.PlannedWorkoutWriteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /plannedWorkout.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to delete workout plans the user has registered on their account. This can be stregnth workouts (sets, reps, weight lifted) or cardio workouts (warmup, intervals of different intensities, cooldown etc)
     *
     * @param {Terra.PlannedWorkoutDeleteRequest} request
     * @param {Plannedworkout.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.plannedworkout.delete({
     *         user_id: "user_id"
     *     })
     */
    public delete(
        request: Terra.PlannedWorkoutDeleteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.PlannedWorkoutDeleteResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Terra.PlannedWorkoutDeleteRequest,
        requestOptions?: Plannedworkout.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.PlannedWorkoutDeleteResponse&gt;&gt; {
        const { user_id: userId, ..._body } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "plannedWorkout",
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.PlannedWorkoutDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling DELETE /plannedWorkout.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="PlannedWorkoutDeleteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         user_id: "user_id"
 *     }
 */
export interface PlannedWorkoutDeleteRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /** List of identifiers for planned workout entries to be deleted */
    data?: string[];
}
</file>
                <file name="PlannedWorkoutFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface PlannedWorkoutFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.PlannedWorkoutFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
}
</file>
                <file name="PlannedWorkoutWriteRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         data: [{}]
 *     }
 */
export interface PlannedWorkoutWriteRequest {
    /** PlannedWorkout entry to post to data provider */
    data: Terra.PlannedWorkout[];
}
</file>
                <file name="index.ts">export { type PlannedWorkoutFetchRequest } from "./PlannedWorkoutFetchRequest.js";
export { type PlannedWorkoutWriteRequest } from "./PlannedWorkoutWriteRequest.js";
export { type PlannedWorkoutDeleteRequest } from "./PlannedWorkoutDeleteRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="PlannedWorkoutDeleteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface PlannedWorkoutDeleteResponse {
    user?: Terra.TerraUser;
    processed_data?: PlannedWorkoutDeleteResponse.ProcessedData.Item[];
}

export namespace PlannedWorkoutDeleteResponse {
    export type ProcessedData = ProcessedData.Item[];

    export namespace ProcessedData {
        export interface Item {
            /** Identifier of the planned workout whose deletion was attempted */
            id?: string;
            /** Response code from the provider when attempting to delete the planned workout */
            response_code?: number;
        }
    }
}
</file>
              <file name="PlannedWorkoutFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PlannedWorkoutFetchRequestStartDate = number | string;
</file>
              <file name="PlannedWorkoutFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type PlannedWorkoutFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.PlannedWorkout[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook;
</file>
              <file name="PlannedWorkoutWriteResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface PlannedWorkoutWriteResponse {
    user?: Terra.TerraUser;
    /** List of identifiers for the objects created, returned in the same order they were posted. I.e. Posting [ObjectA, ObjectB] will return [IdentifierA, IdentifierB] */
    log_ids?: string[];
    message?: string;
}
</file>
              <file name="index.ts">export * from "./PlannedWorkoutFetchRequestStartDate.js";
export * from "./PlannedWorkoutFetchResponse.js";
export * from "./PlannedWorkoutWriteResponse.js";
export * from "./PlannedWorkoutDeleteResponse.js";
</file>
            </directory>
          </directory>
          <directory name="sleep">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Sleep {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class Sleep {
    protected readonly _options: Sleep.Options;

    constructor(_options: Sleep.Options) {
        this._options = _options;
    }

    /**
     * Fetches sleep data such as sleep duration, sleep stages, sleep quality etc. for a given user ID, for sleep sessions with a defined start and end time
     *
     * @param {Terra.SleepFetchRequest} request
     * @param {Sleep.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.UnauthorizedError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.sleep.fetch({
     *         user_id: "user_id",
     *         start_date: 1
     *     })
     */
    public fetch(
        request: Terra.SleepFetchRequest,
        requestOptions?: Sleep.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.SleepFetchResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__fetch(request, requestOptions));
    }

    private async __fetch(
        request: Terra.SleepFetchRequest,
        requestOptions?: Sleep.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.SleepFetchResponse&gt;&gt; {
        const {
            user_id: userId,
            start_date: startDate,
            end_date: endDate,
            to_webhook: toWebhook,
            with_samples: withSamples,
        } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        _queryParams["user_id"] = userId;
        _queryParams["start_date"] = typeof startDate === "string" ? startDate : toJson(startDate);
        if (endDate != null) {
            _queryParams["end_date"] = endDate.toString();
        }

        if (toWebhook != null) {
            _queryParams["to_webhook"] = toWebhook.toString();
        }

        if (withSamples != null) {
            _queryParams["with_samples"] = withSamples.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "sleep",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.SleepFetchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Terra.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /sleep.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="SleepFetchRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../../index.js";

/**
 * @example
 *     {
 *         user_id: "user_id",
 *         start_date: 1
 *     }
 */
export interface SleepFetchRequest {
    /**
     * user ID to query data for
     */
    user_id: string;
    /**
     * start date of data to query for - either ISO8601 date or unix timestamp
     */
    start_date: Terra.SleepFetchRequestStartDate;
    /**
     * end date of data to query for - either ISO8601 date or unix timestamp
     */
    end_date?: number;
    /**
     * boolean flag specifying whether to send the data retrieved to the webhook, or in the response
     */
    to_webhook?: boolean;
    /**
     * boolean flag specifying whether to include detailed samples in the returned payload
     */
    with_samples?: boolean;
}
</file>
                <file name="index.ts">export { type SleepFetchRequest } from "./SleepFetchRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="SleepFetchRequestStartDate.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type SleepFetchRequestStartDate = number | string;
</file>
              <file name="SleepFetchResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type SleepFetchResponse =
    | {
          user?: Terra.TerraUser | undefined;
          data?: Terra.Sleep[] | undefined;
          type?: string | undefined;
      }
    | Terra.NoDataReturned
    | Terra.DataSentToWebhook
    | Terra.RequestProcessing
    | Terra.RateLimitRequestProcessing
    | Terra.LargeRequestProcessingEvent;
</file>
              <file name="index.ts">export * from "./SleepFetchRequestStartDate.js";
export * from "./SleepFetchResponse.js";
</file>
            </directory>
          </directory>
          <directory name="user">
            <file name="index.ts">export * from "./types/index.js";
export * from "./client/index.js";
</file>
            <directory name="client">
              <file name="Client.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Terra from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace User {
    export interface Options {
        environment?: core.Supplier&lt;environments.TerraEnvironment | string&gt;;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier&lt;string&gt;;
        apiKey?: core.Supplier&lt;string | undefined&gt;;
        /** Override the dev-id header */
        devId: core.Supplier&lt;string&gt;;
        /** Additional headers to include in requests. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the dev-id header */
        devId?: string;
        /** Additional headers to include in the request. */
        headers?: Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt;;
    }
}

export class User {
    protected readonly _options: User.Options;

    constructor(_options: User.Options) {
        this._options = _options;
    }

    /**
     * Update a Terra user's reference_id or active status
     *
     * @param {string} userId - Terra user ID to update
     * @param {Terra.UserModifyUserRequest} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     *
     * @example
     *     await client.user.modifyuser("user_id")
     */
    public modifyuser(
        userId: string,
        request: Terra.UserModifyUserRequest = {},
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.UserModifyUserResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__modifyuser(userId, request, requestOptions));
    }

    private async __modifyuser(
        userId: string,
        request: Terra.UserModifyUserRequest = {},
        requestOptions?: User.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.UserModifyUserResponse&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                `users/${encodeURIComponent(userId)}`,
            ),
            method: "PATCH",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.UserModifyUserResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling PATCH /users/{user_id}.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to query for information on one Terra user ID, or to query for all registered Terra User objects under one reference ID
     *
     * @param {Terra.UserGetInfoForUserIdRequest} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.user.getinfoforuserid()
     */
    public getinfoforuserid(
        request: Terra.UserGetInfoForUserIdRequest = {},
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.UserGetInfoForUserIdResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__getinfoforuserid(request, requestOptions));
    }

    private async __getinfoforuserid(
        request: Terra.UserGetInfoForUserIdRequest = {},
        requestOptions?: User.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.UserGetInfoForUserIdResponse&gt;&gt; {
        const { user_id: userId, reference_id: referenceId } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        if (userId != null) {
            _queryParams["user_id"] = userId;
        }

        if (referenceId != null) {
            _queryParams["reference_id"] = referenceId;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "userInfo",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.UserGetInfoForUserIdResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /userInfo.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to query for information for all Terra User IDs. Supports optional pagination via `page` and `per_page`. If `page` is not provided, it returns all users in one go (backwards compatibility).
     *
     * @param {Terra.UserGetAllUserIDsRequest} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     *
     * @example
     *     await client.user.getalluserids()
     */
    public getalluserids(
        request: Terra.UserGetAllUserIDsRequest = {},
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.UserGetAllUserIDsResponse&gt; {
        return core.HttpResponsePromise.fromPromise(this.__getalluserids(request, requestOptions));
    }

    private async __getalluserids(
        request: Terra.UserGetAllUserIDsRequest = {},
        requestOptions?: User.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.UserGetAllUserIDsResponse&gt;&gt; {
        const { page, per_page: perPage } = request;
        const _queryParams: Record&lt;string, string | string[] | object | object[] | null&gt; = {};
        if (page != null) {
            _queryParams["page"] = page.toString();
        }

        if (perPage != null) {
            _queryParams["per_page"] = perPage.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "subscriptions",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.UserGetAllUserIDsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling GET /subscriptions.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Used to query for information for multiple Terra User IDs
     *
     * @param {string[]} request
     * @param {User.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Terra.BadRequestError}
     * @throws {@link Terra.NotFoundError}
     *
     * @example
     *     await client.user.getinfoformultipleuserids(["string"])
     */
    public getinfoformultipleuserids(
        request: string[],
        requestOptions?: User.RequestOptions,
    ): core.HttpResponsePromise&lt;Terra.TerraUser[]&gt; {
        return core.HttpResponsePromise.fromPromise(this.__getinfoformultipleuserids(request, requestOptions));
    }

    private async __getinfoformultipleuserids(
        request: string[],
        requestOptions?: User.RequestOptions,
    ): Promise&lt;core.WithRawResponse&lt;Terra.TerraUser[]&gt;&gt; {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TerraEnvironment.Default,
                "bulkUserInfo",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "dev-id": requestOptions?.devId,
                    ...(await this._getCustomAuthorizationHeaders()),
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Terra.TerraUser[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Terra.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Terra.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TerraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TerraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TerraTimeoutError("Timeout exceeded when calling POST /bulkUserInfo.");
            case "unknown":
                throw new errors.TerraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
</file>
              <file name="index.ts">export * from "./requests/index.js";
</file>
              <directory name="requests">
                <file name="UserGetAllUserIDsRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface UserGetAllUserIDsRequest {
    /**
     * Zero-based page number. If omitted, results are not paginated.
     */
    page?: number;
    /**
     * Number of results per page (default is 500).
     */
    per_page?: number;
}
</file>
                <file name="UserGetInfoForUserIdRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface UserGetInfoForUserIdRequest {
    /**
     * user ID to query for
     */
    user_id?: string;
    /**
     * reference ID to query for
     */
    reference_id?: string;
}
</file>
                <file name="UserModifyUserRequest.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
export interface UserModifyUserRequest {
    /** Identifier on your system to associate with this user */
    reference_id?: string;
    /** Whether the user should remain active */
    active?: boolean;
}
</file>
                <file name="index.ts">export { type UserModifyUserRequest } from "./UserModifyUserRequest.js";
export { type UserGetInfoForUserIdRequest } from "./UserGetInfoForUserIdRequest.js";
export { type UserGetAllUserIDsRequest } from "./UserGetAllUserIDsRequest.js";
</file>
              </directory>
            </directory>
            <directory name="types">
              <file name="UserGetAllUserIDsResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type UserGetAllUserIDsResponse =
    | {
          users?: Terra.TerraUser[] | undefined;
      }
    | {
          data?:
              | {
                    next?: number | undefined;
                    max_page?: number | undefined;
                    results?: Terra.TerraUser[] | undefined;
                }
              | undefined;
      };
</file>
              <file name="UserGetInfoForUserIdResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export type UserGetInfoForUserIdResponse =
    /**
     * User information for one connection (single User object) */
    | {
          user?: Terra.TerraUser | undefined;
          status?: ("success" | "error") | undefined;
          is_authenticated?: boolean | undefined;
      }
    /**
     * List of multiple User objects the reference_id is associated to */
    | Terra.TerraUser[];
</file>
              <file name="UserModifyUserResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../../../index.js";

export interface UserModifyUserResponse {
    user?: Terra.TerraUser;
    /** Indicates that the request was successful */
    status?: UserModifyUserResponse.Status;
}

export namespace UserModifyUserResponse {
    /**
     * Indicates that the request was successful
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
              <file name="index.ts">export * from "./UserModifyUserResponse.js";
export * from "./UserGetInfoForUserIdResponse.js";
export * from "./UserGetAllUserIDsResponse.js";
</file>
            </directory>
          </directory>
        </directory>
        <directory name="types">
          <file name="AFibClassificationSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface AFibClassificationSample {
    timestamp: string;
    afib_classification: Terra.AFibFlag;
}
</file>
          <file name="AFibFlag.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Flag indicating the atrial fibrillation classification of the individual
 */
export type AFibFlag =
    /**
     * AFib was not detected in the heart rhythm analysis. */
    | 0
    /**
     * AFib was detected in the heart rhythm analysis. */
    | 1
    /**
     * The heart rhythm analysis couldn't determine whether AFib was present or absent. */
    | 2;
export const AFibFlag = {
    Negative: 0,
    Positive: 1,
    Inconclusive: 2,
} as const;
</file>
          <file name="AccessRevokedEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Access revoked event when a user revokes access through the provider
 */
export interface AccessRevokedEvent {
    type: "access_revoked";
    /** User who revoked access */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the access revocation */
    message: string;
}
</file>
          <file name="AccessRevokedWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type AccessRevokedWebhook = Terra.AccessRevokedEvent;
</file>
          <file name="ActiveDurationsData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ActiveDurationsData {
    /** Array of detailed samples of the intensity the user was in at various points during the workout. */
    activity_levels_samples?: Terra.ActivityLevelSample[];
    /** Total number of seconds spent in an active state during the workout. */
    activity_seconds?: number;
    /** Total number of seconds spent in an inactive state during the workout. */
    inactivity_seconds?: number;
    /** Total number of seconds spent in a low intensity state during the workout. */
    low_intensity_seconds?: number;
    /** Total number of seconds spent in a moderate intensity state during the workout. */
    moderate_intensity_seconds?: number;
    /** Maximum number of continuous periods spent in an inactive state during the workout. */
    num_continuous_inactive_periods?: number;
    /** Total number of seconds spent resting during the workout. */
    rest_seconds?: number;
    /** Total number of seconds spent in a state of vigorous intensity during the workout. */
    vigorous_intensity_seconds?: number;
    standing_hours_count?: number;
    standing_seconds?: number;
}
</file>
          <file name="Activity.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Activity {
    /** Number of minutes spent at various intensities during the workout, as reported by the Fitness Data provider. */
    active_durations_data?: Terra.ActiveDurationsData;
    /** Object containing calorie-related information for the user during the specific workout. */
    calories_data?: Terra.CaloriesData;
    /** Cheat detection flag. */
    cheat_detection?: number;
    /** Object containing Terra Scores. */
    data_enrichment?: Terra.DataEnrichment;
    /** Object containing information on the device which recorded the specific workout. */
    device_data?: Terra.DeviceData;
    /** Object containing information related to distance covered during the associated workout. */
    distance_data?: Terra.DistanceData;
    /** Object containing information on the energy expended by the user during the workout. */
    energy_data?: Terra.EnergyData;
    /** Object containing heartrate-related information for the workout. */
    heart_rate_data?: Terra.HeartRateData;
    /** Object containing information on data for each lap performed by the user - mostly relates to track &amp; field running activities, and swimming activities. */
    lap_data?: Terra.LapData;
    /** Object containing information on the Metabolic Equivalent of Task for the workout. */
    MET_data?: Terra.MetData;
    /** Object containing workout metadata. */
    metadata: Terra.ActivityMetadata;
    /** Object containing information on the user's movement throughout the workout. */
    movement_data?: Terra.MovementData;
    /** Object containing information on oxygen-related metrics for the workout. */
    oxygen_data?: Terra.OxygenData;
    /** Object containing polyline-representation map data, plotting the user's trajectory throughout the workout. */
    polyline_map_data?: Terra.PolylineMapData;
    /** Object containing information on the user's position throughout the workout. */
    position_data?: Terra.PositionData;
    /** Object containing information on the power generated by the user during the workout. */
    power_data?: Terra.PowerData;
    /** Object containing information on the cardiovascular strain imposed on the user during the workout. */
    strain_data?: Terra.StrainData;
    /** Object containing information on the stress put on the user's body from a workout. */
    TSS_data?: Terra.TssData;
    /** Object containing information on the work output of the user during the workout. */
    work_data?: Terra.WorkData;
}
</file>
          <file name="ActivityEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Activity data event
 */
export interface ActivityEvent {
    type: "activity";
    /** Array of activity data */
    data: Terra.Activity[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="ActivityLevel.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Intensity of the user's activity at an instant in time
 */
export type ActivityLevel =
    /**
     * Activity level is unknown or could not be determined. */
    | 0
    /**
     * User is at rest, with minimal to no physical activity. */
    | 1
    /**
     * User is awake but inactive or sedentary. */
    | 2
    /**
     * User is engaged in light physical activity such as casual walking. */
    | 3
    /**
     * User is engaged in moderate physical activity such as brisk walking or light exercise. */
    | 4
    /**
     * User is engaged in vigorous physical activity such as running or intense exercise. */
    | 5;
export const ActivityLevel = {
    Unknown: 0,
    Rest: 1,
    Inactive: 2,
    LowIntensity: 3,
    MediumIntensity: 4,
    HighIntensity: 5,
} as const;
</file>
          <file name="ActivityLevelSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ActivityLevelSample {
    timestamp: string;
    level: Terra.ActivityLevel;
}
</file>
          <file name="ActivityMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ActivityMetadata {
    /** The City in which the workout was performed. */
    city?: string;
    /** The Country in which the workout was performed. */
    country?: string;
    /** The end time of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The name - either user-entered or given by the fitness data provider - of the associated workout. */
    name?: string;
    /** The start time of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    /** The State in which the workout was performed. */
    state?: string;
    /** A unique identifier for the workout - note that this is unique for the given user, and may not be globally unique. */
    summary_id: string;
    timestamp_localization?: Terra.TimestampLocalization;
    /** The type of activity performed for the associated workout. */
    type: Terra.ActivityType;
    /** The upload type for the associated workout, providing information on whether this was an automatic workout or user-entered. */
    upload_type: Terra.UploadType;
}
</file>
          <file name="ActivityType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * The type of activity performed for the associated workout.
 */
export type ActivityType =
    /**
     * Activity type for when the user is in a vehicle, such as a car or bus. */
    | 0
    /**
     * Activity type for general biking or cycling. */
    | 1
    /**
     * Activity type for when the user is still or not moving. */
    | 3
    /**
     * Activity type is unknown or could not be determined. */
    | 4
    /**
     * Activity type for when the device detects a tilting motion. */
    | 5
    /**
     * Activity type for general walking. */
    | 7
    /**
     * Activity type for general running. */
    | 8
    /**
     * Activity type for aerobic exercises and workouts. */
    | 9
    /**
     * Activity type for playing badminton. */
    | 10
    /**
     * Activity type for playing baseball. */
    | 11
    /**
     * Activity type for playing basketball. */
    | 12
    /**
     * Activity type for biathlon, combining cross-country skiing and rifle shooting. */
    | 13
    /**
     * Activity type for hand biking, using a hand-powered bicycle. */
    | 14
    /**
     * Activity type for off-road cycling on rough terrain. */
    | 15
    /**
     * Activity type for cycling on paved roads. */
    | 16
    /**
     * Activity type for indoor cycling classes or spinning. */
    | 17
    /**
     * Activity type for exercising on a stationary bicycle. */
    | 18
    /**
     * Activity type for cycling for transportation or utility purposes. */
    | 19
    /**
     * Activity type for boxing training or matches. */
    | 20
    /**
     * Activity type for bodyweight exercises focusing on rhythm and flow. */
    | 21
    /**
     * Activity type for workout consisting of a series of exercises performed in rotation. */
    | 22
    /**
     * Activity type for playing cricket. */
    | 23
    /**
     * Activity type for various forms of dance. */
    | 24
    /**
     * Activity type for exercising on an elliptical trainer. */
    | 25
    /**
     * Activity type for fencing sport. */
    | 26
    /**
     * Activity type for playing American football. */
    | 27
    /**
     * Activity type for playing Australian rules football. */
    | 28
    /**
     * Activity type for playing soccer/football. */
    | 29
    /**
     * Activity type for playing frisbee or disc sports. */
    | 30
    /**
     * Activity type for gardening and yard work. */
    | 31
    /**
     * Activity type for playing golf. */
    | 32
    /**
     * Activity type for performing gymnastics. */
    | 33
    /**
     * Activity type for playing handball. */
    | 34
    /**
     * Activity type for hiking or walking on trails. */
    | 35
    /**
     * Activity type for playing hockey. */
    | 36
    /**
     * Activity type for horseback riding. */
    | 37
    /**
     * Activity type for household chores and cleaning. */
    | 38
    /**
     * Activity type for skipping or jumping rope. */
    | 39
    /**
     * Activity type for kayaking on water. */
    | 40
    /**
     * Activity type for exercises using kettlebells. */
    | 41
    /**
     * Activity type for kickboxing training or matches. */
    | 42
    /**
     * Activity type for kitesurfing or kiteboarding. */
    | 43
    /**
     * Activity type for general martial arts training. */
    | 44
    /**
     * Activity type for meditation practice. */
    | 45
    /**
     * Activity type for MMA training or fighting. */
    | 46
    /**
     * Activity type for P90X home fitness program. */
    | 47
    /**
     * Activity type for paragliding sport. */
    | 48
    /**
     * Activity type for pilates exercises. */
    | 49
    /**
     * Activity type for playing polo. */
    | 50
    /**
     * Activity type for playing racquetball. */
    | 51
    /**
     * Activity type for rock climbing. */
    | 52
    /**
     * Activity type for rowing on water. */
    | 53
    /**
     * Activity type for exercising on a rowing machine. */
    | 54
    /**
     * Activity type for playing rugby. */
    | 55
    /**
     * Activity type for jogging at a leisurely pace. */
    | 56
    /**
     * Activity type for running on beach or sandy surface. */
    | 57
    /**
     * Activity type for running on a treadmill. */
    | 58
    /**
     * Activity type for sailing on water. */
    | 59
    /**
     * Activity type for scuba diving underwater. */
    | 60
    /**
     * Activity type for skateboarding. */
    | 61
    /**
     * Activity type for general skating. */
    | 62
    /**
     * Activity type for cross skating or nordic skating. */
    | 63
    /**
     * Activity type for rollerblading indoors. */
    | 64
    /**
     * Activity type for general skiing. */
    | 65
    /**
     * Activity type for backcountry or off-piste skiing. */
    | 66
    /**
     * Activity type for cross-country skiing. */
    | 67
    /**
     * Activity type for alpine or downhill skiing. */
    | 68
    /**
     * Activity type for skiing with a kite for propulsion. */
    | 69
    /**
     * Activity type for roller skiing on wheels. */
    | 70
    /**
     * Activity type for sledding or tobogganing. */
    | 71
    /**
     * Activity type for snowboarding. */
    | 73
    /**
     * Activity type for riding a snowmobile. */
    | 74
    /**
     * Activity type for walking with snowshoes. */
    | 75
    /**
     * Activity type for playing squash. */
    | 76
    /**
     * Activity type for climbing stairs. */
    | 77
    /**
     * Activity type for exercising on a stair climbing machine. */
    | 78
    /**
     * Activity type for stand-up paddleboarding. */
    | 79
    /**
     * Activity type for resistance training or weight lifting. */
    | 80
    /**
     * Activity type for surfing on waves. */
    | 81
    /**
     * Activity type for general swimming. */
    | 82
    /**
     * Activity type for swimming in a swimming pool. */
    | 83
    /**
     * Activity type for swimming in open water like oceans, lakes or rivers. */
    | 84
    /**
     * Activity type for playing table tennis or ping pong. */
    | 85
    /**
     * Activity type for general team sports not otherwise classified. */
    | 86
    /**
     * Activity type for playing tennis. */
    | 87
    /**
     * Activity type for exercising on a treadmill. */
    | 88
    /**
     * Activity type for general volleyball. */
    | 89
    /**
     * Activity type for playing volleyball on a beach. */
    | 90
    /**
     * Activity type for playing volleyball indoors. */
    | 91
    /**
     * Activity type for wakeboarding on water. */
    | 92
    /**
     * Activity type for walking specifically for exercise. */
    | 93
    /**
     * Activity type for walking with poles. */
    | 94
    /**
     * Activity type for walking on a treadmill. */
    | 95
    /**
     * Activity type for playing water polo. */
    | 96
    /**
     * Activity type for weightlifting exercises. */
    | 97
    /**
     * Activity type for wheelchair-based movement. */
    | 98
    /**
     * Activity type for windsurfing on water. */
    | 99
    /**
     * Activity type for practicing yoga. */
    | 100
    /**
     * Activity type for Zumba dance fitness. */
    | 101
    /**
     * Activity type for diving or jumping into water. */
    | 102
    /**
     * Activity type for exercising on an ergometer. */
    | 103
    /**
     * Activity type for skating on ice. */
    | 104
    /**
     * Activity type for skating indoors. */
    | 105
    /**
     * Activity type for playing curling on ice. */
    | 106
    /**
     * Activity type for activities that don't fit into other categories. */
    | 108
    /**
     * Activity type for CrossFit training. */
    | 113
    /**
     * Activity type for high-intensity interval training. */
    | 114
    /**
     * Activity type for general interval training workouts. */
    | 115
    /**
     * Activity type for walking while pushing a stroller. */
    | 116
    /**
     * Activity type for riding in an elevator. */
    | 117
    /**
     * Activity type for riding on an escalator. */
    | 118
    /**
     * Activity type for practicing archery. */
    | 119
    /**
     * Activity type for playing softball. */
    | 120
    /**
     * Activity type for practicing guided breathing exercises. */
    | 122
    /**
     * Activity type for general cardiovascular exercise. */
    | 123
    /**
     * Activity type for playing lacrosse. */
    | 124
    /**
     * Activity type for stretching exercises. */
    | 125
    /**
     * Activity type for triathlon events combining swimming, cycling and running. */
    | 126
    /**
     * Activity type for inline skating or rollerblading. */
    | 127
    /**
     * Activity type for sky diving or parachuting. */
    | 128
    /**
     * Activity type for general paddling activities. */
    | 129
    /**
     * Activity type for mountaineering or alpine climbing. */
    | 130
    /**
     * Activity type for fishing activities. */
    | 131
    /**
     * Activity type for water skiing. */
    | 132
    /**
     * Activity type for running indoors. */
    | 133
    /**
     * Activity type for playing padel tennis. */
    | 134
    /**
     * Activity type for driving a vehicle. */
    | 135
    /**
     * Activity type for driving off-road or on unpaved surfaces. */
    | 136
    /**
     * Activity type for riding a motorcycle. */
    | 137
    /**
     * Activity type for motorsport racing. */
    | 138
    /**
     * Activity type for enduro motorcycle racing. */
    | 139
    /**
     * Activity type for canoeing on water. */
    | 140
    /**
     * Activity type for orienteering navigation sport. */
    | 141
    /**
     * Activity type for hang gliding. */
    | 142
    /**
     * Activity type for piloting an aircraft. */
    | 143
    /**
     * Activity type for hot air balloon flying. */
    | 144
    /**
     * Activity type for riding a jet ski on water. */
    | 145
    /**
     * Activity type for operating a motorized boat. */
    | 146
    /**
     * Activity type for playing Gaelic football. */
    | 147
    /**
     * Activity type for playing hurling. */
    | 148;
export const ActivityType = {
    InVehicle: 0,
    Biking: 1,
    Still: 3,
    Unknown: 4,
    Tilting: 5,
    Walking: 7,
    Running: 8,
    Aerobics: 9,
    Badminton: 10,
    Baseball: 11,
    Basketball: 12,
    Biathlon: 13,
    HandBiking: 14,
    MountainBiking: 15,
    RoadBiking: 16,
    Spinning: 17,
    StationaryBiking: 18,
    UtilityBiking: 19,
    Boxing: 20,
    Calisthenics: 21,
    CircuitTraining: 22,
    Cricket: 23,
    Dancing: 24,
    Elliptical: 25,
    Fencing: 26,
    AmericanFootball: 27,
    AustralianFootball: 28,
    EnglishFootball: 29,
    Frisbee: 30,
    Gardening: 31,
    Golf: 32,
    Gymnastics: 33,
    Handball: 34,
    Hiking: 35,
    Hockey: 36,
    HorsebackRiding: 37,
    Housework: 38,
    JumpingRope: 39,
    Kayaking: 40,
    KettlebellTraining: 41,
    Kickboxing: 42,
    Kitesurfing: 43,
    MartialArts: 44,
    Meditation: 45,
    MixedMartialArts: 46,
    P90XExercises: 47,
    Paragliding: 48,
    Pilates: 49,
    Polo: 50,
    Racquetball: 51,
    RockClimbing: 52,
    Rowing: 53,
    RowingMachine: 54,
    Rugby: 55,
    Jogging: 56,
    RunningOnSand: 57,
    TreadmillRunning: 58,
    Sailing: 59,
    ScubaDiving: 60,
    Skateboarding: 61,
    Skating: 62,
    CrossSkating: 63,
    IndoorRollerblading: 64,
    Skiing: 65,
    BackCountrySkiing: 66,
    CrossCountrySkiing: 67,
    DownhillSkiing: 68,
    KiteSkiing: 69,
    RollerSkiing: 70,
    Sledding: 71,
    Snowboarding: 73,
    Snowmobile: 74,
    Snowshoeing: 75,
    Squash: 76,
    StairClimbing: 77,
    StairClimbingMachine: 78,
    StandUpPaddleboarding: 79,
    StrengthTraining: 80,
    Surfing: 81,
    Swimming: 82,
    SwimmingInPool: 83,
    OpenWaterSwimming: 84,
    TableTennis: 85,
    TeamSports: 86,
    Tennis: 87,
    Treadmill: 88,
    Volleyball: 89,
    BeachVolleyball: 90,
    IndoorVolleyball: 91,
    Wakeboarding: 92,
    WalkingForFitness: 93,
    NordicWalking: 94,
    TreadmillWalking: 95,
    WaterPolo: 96,
    Weightlifting: 97,
    Wheelchair: 98,
    Windsurfing: 99,
    Yoga: 100,
    Zumba: 101,
    Diving: 102,
    Ergometer: 103,
    IceSkating: 104,
    IndoorSkating: 105,
    Curling: 106,
    Other: 108,
    Crossfit: 113,
    Hiit: 114,
    IntervalTraining: 115,
    WalkingWithStroller: 116,
    Elevator: 117,
    Escalator: 118,
    Archery: 119,
    Softball: 120,
    GuidedBreathing: 122,
    CardioTraining: 123,
    Lacrosse: 124,
    Stretching: 125,
    Triathlon: 126,
    InlineSkating: 127,
    SkyDiving: 128,
    Paddling: 129,
    Mountaineering: 130,
    Fishing: 131,
    WaterSkiing: 132,
    IndoorRunning: 133,
    PadelTennis: 134,
    Driving: 135,
    OffRoadDriving: 136,
    Motorbiking: 137,
    MotorRacing: 138,
    Enduro: 139,
    Canoeing: 140,
    Orienteering: 141,
    HangGliding: 142,
    Flying: 143,
    HotAirBallooning: 144,
    JetSkiing: 145,
    PowerBoating: 146,
    GaelicFootball: 147,
    Hurling: 148,
} as const;
</file>
          <file name="ActivityWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type ActivityWebhook = Terra.ActivityEvent;
</file>
          <file name="AsleepDurations.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AsleepDurations {
    /** Total duration for which the user was asleep, in any state. */
    duration_asleep_state_seconds?: number;
    /** Total duration for which the user was in a state of deep sleep. */
    duration_deep_sleep_state_seconds?: number;
    /** Total duration for which the user was in a state of light sleep. */
    duration_light_sleep_state_seconds?: number;
    /** Total duration for which the user was in a state of REM sleep. */
    duration_REM_sleep_state_seconds?: number;
    /** Number of periods of REM sleep captured during the sleep session. */
    num_REM_events?: number;
}
</file>
          <file name="Athlete.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Athlete {
    /** User's age. */
    age?: number;
    /** User's country of residence. */
    country?: string;
    /** User's bio - a short description they display on their profile. */
    bio?: string;
    /** User's state of residence. */
    state?: string;
    /** User's last name. */
    last_name?: string;
    /** User's sex. */
    sex?: string;
    /** User's city of residence. */
    city?: string;
    /** User's email. */
    email?: string;
    /** User's date of birth, in ISO8601 format. */
    date_of_birth?: string;
    /** User's first name. */
    first_name?: string;
    /** User's gender. */
    gender?: string;
    /** User's account creation date. */
    joined_provider?: string;
    devices?: Terra.DeviceData[];
}
</file>
          <file name="AthleteCollection.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface AthleteCollection {
    /** Object containing the user's information */
    athlete?: Terra.Athlete;
    /** Terra User object */
    user?: Terra.TerraUser;
}
</file>
          <file name="AthleteEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Athlete data event
 */
export interface AthleteEvent {
    type: "athlete";
    /** Athlete data */
    athlete: Terra.Athlete;
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="AthleteWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type AthleteWebhook = Terra.AthleteEvent;
</file>
          <file name="AuthErrorEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Authentication error event
 */
export interface AuthErrorEvent extends Terra.AuthEvent {
    /** User who attempted to authenticate */
    user: Terra.TerraUser;
    /** Provider information */
    provider: string;
    /** Error message */
    message: string;
    /** Reason for the error */
    reason: string;
    /** Client-provided reference ID */
    reference_id: string;
    /** Widget session identifier */
    widget_session_id: string;
}
</file>
          <file name="AuthEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Authentication event
 */
export interface AuthEvent {
    type: "auth";
}
</file>
          <file name="AuthSuccessEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Authentication success event
 */
export interface AuthSuccessEvent extends Terra.AuthEvent {
    /** User who authenticated */
    user: Terra.TerraUser;
    /** Client-provided reference ID */
    reference_id: string;
    /** Widget session identifier */
    widget_session_id: string;
}
</file>
          <file name="AuthenticationFailedWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type AuthenticationFailedWebhook = Terra.AuthErrorEvent;
</file>
          <file name="AwakeDurations.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface AwakeDurations {
    /** Total duration for which the user was awake during the sleep session. */
    duration_awake_state_seconds?: number;
    /** Total duration for which the user was awake during the sleep session, when the interruption of their sleep was greater than 90 seconds. */
    duration_long_interruption_seconds?: number;
    /** Total duration for which the user was awake during the sleep session, when the interruption of their sleep was less than 90 seconds. */
    duration_short_interruption_seconds?: number;
    /** Number of times the user got out of bed during the sleep session. */
    num_out_of_bed_events?: number;
    /** Number of times the user woke up during the sleep session. */
    num_wakeup_events?: number;
    /** Sleep latency, defined as time between the moment the user lays in bed with the intention to sleep and the moment they actually fall asleep. */
    sleep_latency_seconds?: number;
    /** Wake up latency, defined as time between the moment the user wakes up and the moment they get out of bed. */
    wake_up_latency_seconds?: number;
}
</file>
          <file name="BadRequestErrorBody.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BadRequestErrorBody {
    /** a detailed message describing the error */
    message?: string;
    /** indicates that an error happened (value is error) */
    status?: "error";
}
</file>
          <file name="BloodPressureData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface BloodPressureData {
    /** List of Blood Pressure measurements sampled throughout the day. */
    blood_pressure_samples?: Terra.BloodPressureSample[];
}
</file>
          <file name="BloodPressureSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BloodPressureSample {
    timestamp: string;
    diastolic_bp: number;
    systolic_bp: number;
}
</file>
          <file name="Body.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Body {
    /** Object containing information on user's Blood Pressure. */
    blood_pressure_data?: Terra.BloodPressureData;
    /** Object containing information on the device which recorded data for the payload. */
    device_data?: Terra.DeviceData;
    /** Object containing information on user's heart metrics. */
    heart_data?: Terra.HeartData;
    /** Object containing information on user's hydration (both internal &amp; consumption of water) for the day. */
    hydration_data?: Terra.HydrationData;
    /** Object containing information on user's ketone data for the day. */
    ketone_data?: Terra.KetoneData;
    /** Object containing information on body measurements for the day. */
    measurements_data?: Terra.MeasurementsData;
    /** Object containing daily summary metadata. */
    metadata: Terra.BodyMetadata;
    /** Object containing information on user's oxygen-related data. */
    oxygen_data?: Terra.OxygenData;
    /** Object containing temperature information (core, skin, ambient) during the day. */
    temperature_data?: Terra.TemperatureData;
    /** Object containing information on user's blood glucose for the day. */
    glucose_data?: Terra.GlucoseData;
}
</file>
          <file name="BodyBatterySample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BodyBatterySample {
    timestamp: string;
    level: number;
}
</file>
          <file name="BodyEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Body data event
 */
export interface BodyEvent {
    type: "body";
    /** Array of body data */
    data: Terra.Body[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="BodyMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface BodyMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
}
</file>
          <file name="BodyWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type BodyWebhook = Terra.BodyEvent;
</file>
          <file name="BreathSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BreathSample {
    timestamp: string;
    breaths_per_min: number;
}
</file>
          <file name="BreathsData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface BreathsData {
    /** Average breathing rate of the user during the sleep session. */
    avg_breaths_per_min?: number;
    /** Maximum breathing rate of the user during the sleep session. */
    max_breaths_per_min?: number;
    /** Minimum breathing rate of the user during the sleep session. */
    min_breaths_per_min?: number;
    /** Flag indicating if the reading was performed on demand, or if it was automatically captured by the device. */
    on_demand_reading?: boolean;
    /** List of breathing rate information sampled throughout the sleep session. */
    samples?: Terra.BreathSample[];
    /** The start time of the recording of breathing rate data, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time?: string;
    /** The end time of the recording of breathing rate data, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time?: string;
}
</file>
          <file name="CadencePlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CadencePlannedWorkoutStepTarget {
    /** Ideal cadence value to be maintained for the workout step */
    cadence?: number;
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: CadencePlannedWorkoutStepTarget.TargetType;
    /** Minimum cadence threshold for the workout step - i.e. the user is to stay above this value during the workout */
    cadence_low?: number;
    /** Maximum cadence threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    cadence_high?: number;
}

export namespace CadencePlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="CadenceSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CadenceSample {
    timestamp: string;
    cadence_rpm: number;
    timer_duration_seconds: number;
}
</file>
          <file name="CalorieSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CalorieSample {
    timestamp: string;
    calories: number;
    timer_duration_seconds: number;
}
</file>
          <file name="CaloriesData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface CaloriesData {
    BMR_calories?: number;
    calorie_samples?: Terra.CalorieSample[];
    net_activity_calories?: number;
    net_intake_calories?: number;
    total_burned_calories?: number;
}
</file>
          <file name="CaloriesPlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CaloriesPlannedWorkoutStepDuration {
    /** Calorie burn target for the workout step - once the user reaches the target, the step will be completed */
    calories?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: CaloriesPlannedWorkoutStepDuration.DurationType;
}

export namespace CaloriesPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="CardioPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface CardioPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Name of exercise to be performed for the workout step */
    exercice_name?: string;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Type of exercise to be performed for the workout step */
    exercice_category?: CardioPlannedWorkoutStep.ExerciceCategory;
    /** Name of workout step */
    name?: string;
}

export namespace CardioPlannedWorkoutStep {
    /**
     * Type of exercise to be performed for the workout step
     */
    export type ExerciceCategory =
        | "UNKNOWN"
        | "BENCH_PRESS"
        | "CALF_RAISE"
        | "CARDIO"
        | "CARRY"
        | "CHOP"
        | "CORE"
        | "CRUNCH"
        | "CURL"
        | "DEADLIFT"
        | "FLYE"
        | "HIP_RAISE"
        | "HIP_STABILITY"
        | "HIP_SWING"
        | "HYPEREXTENSION"
        | "LATERAL_RAISE"
        | "LEG_CURL"
        | "LEG_RAISE"
        | "LUNGE"
        | "OLYMPIC_LIFT"
        | "PLANK"
        | "PLYO"
        | "PULL_UP"
        | "PUSH_UP"
        | "ROW"
        | "SHOULDER_PRESS"
        | "SHOULDER_STABILITY"
        | "SHRUG"
        | "SIT_UP"
        | "SQUAT"
        | "TOTAL_BODY"
        | "TRICEPS_EXTENSION"
        | "WARM_UP"
        | "RUN"
        | "BIKE"
        | "CARDIO_SENSORS";
    export const ExerciceCategory = {
        Unknown: "UNKNOWN",
        BenchPress: "BENCH_PRESS",
        CalfRaise: "CALF_RAISE",
        Cardio: "CARDIO",
        Carry: "CARRY",
        Chop: "CHOP",
        Core: "CORE",
        Crunch: "CRUNCH",
        Curl: "CURL",
        Deadlift: "DEADLIFT",
        Flye: "FLYE",
        HipRaise: "HIP_RAISE",
        HipStability: "HIP_STABILITY",
        HipSwing: "HIP_SWING",
        Hyperextension: "HYPEREXTENSION",
        LateralRaise: "LATERAL_RAISE",
        LegCurl: "LEG_CURL",
        LegRaise: "LEG_RAISE",
        Lunge: "LUNGE",
        OlympicLift: "OLYMPIC_LIFT",
        Plank: "PLANK",
        Plyo: "PLYO",
        PullUp: "PULL_UP",
        PushUp: "PUSH_UP",
        Row: "ROW",
        ShoulderPress: "SHOULDER_PRESS",
        ShoulderStability: "SHOULDER_STABILITY",
        Shrug: "SHRUG",
        SitUp: "SIT_UP",
        Squat: "SQUAT",
        TotalBody: "TOTAL_BODY",
        TricepsExtension: "TRICEPS_EXTENSION",
        WarmUp: "WARM_UP",
        Run: "RUN",
        Bike: "BIKE",
        CardioSensors: "CARDIO_SENSORS",
    } as const;
}
</file>
          <file name="ConnectionErrorEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Connection error event
 */
export interface ConnectionErrorEvent {
    type: "connection_error";
    /** User with connection issues */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the connection issue */
    message: string;
}
</file>
          <file name="ConnectionErrorWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type ConnectionErrorWebhook = Terra.ConnectionErrorEvent;
</file>
          <file name="CyclingPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface CyclingPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}
</file>
          <file name="Daily.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Daily {
    /** Object containing information related to the time spent in different activity intensities during over the day. */
    active_durations_data?: Terra.ActiveDurationsData;
    /** Object containing calorie-related information for the user during the specific day. */
    calories_data?: Terra.CaloriesData;
    /** Object containing additional enrichment data for the day. */
    data_enrichment?: Terra.DailyDataEnrichment;
    /** Object containing information on the device which recorded data for the day. */
    device_data?: Terra.DeviceData;
    /** Object containing information related to distance covered during the associated day. */
    distance_data?: Terra.DailyDistanceData;
    /** Object containing heartrate-related information for the day. */
    heart_rate_data?: Terra.HeartRateData;
    /** Object containing information on the Metabolic Equivalent of Task for the day. */
    MET_data?: Terra.MetData;
    /** Object containing daily summary metadata. */
    metadata: Terra.DailyMetadata;
    /** Object containing information on oxygen-related metrics for the day. */
    oxygen_data?: Terra.OxygenData;
    /** Scores for the user's performance on different metrics for the given day, as calculated by the fitness data provider. */
    scores?: Terra.ScoresData;
    /** Object containing information on the strain put on the user's body over a day. */
    strain_data?: Terra.StrainData;
    /** Object containing information on the stress put on the user over a day. */
    stress_data?: Terra.StressData;
    /** Object containing all user-entered or automatically tagged events in the day. */
    tag_data?: Terra.TagData;
}
</file>
          <file name="DailyDataEnrichment.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DailyDataEnrichment {
    cardiovascular_contributors?: Terra.DataContributor[];
    cardiovascular_score?: number;
    immune_contributors?: Terra.DataContributor[];
    immune_index?: number;
    readiness_contributors?: Terra.DataContributor[];
    readiness_score?: number;
    respiratory_contributors?: Terra.DataContributor[];
    respiratory_score?: number;
    start_time?: string;
    stress_contributors?: Terra.DataContributor[];
    total_stress_score?: number;
}
</file>
          <file name="DailyDistanceData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DailyDistanceData {
    /** Object containing detailed distance information - this may include second-by-second samples. */
    detailed?: Terra.DistanceDataDetailed;
    /** Total distance covered by the user throughout the day. */
    distance_meters?: number;
    /** Average elevation of the user throughout the day. */
    elevation?: Terra.ElevationData;
    /** Total number of elevation gain in floors climbed equivalent throughout the day, as determined by the fitness data provider. */
    floors_climbed?: number;
    /** Total number of steps performed during the day. */
    steps?: number;
    /** Summary information of the user's swimming statistics for the day, if applicable. */
    swimming?: Terra.SwimmingData;
}
</file>
          <file name="DailyEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Daily data event
 */
export interface DailyEvent {
    type: "daily";
    /** Array of daily data */
    data: Terra.Daily[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="DailyMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DailyMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
    /** The upload type for data in the associated day, providing information on whether data was automatically uploaded or user-entered. If any data point in a day is altered, the day should be classed as manual. */
    upload_type: Terra.UploadType;
}
</file>
          <file name="DailyPatternSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DailyPatternSample {
    time_from_midnight: number;
    percentile_5: number;
    percentile_25: number;
    percentile_50: number;
    percentile_75: number;
    percentile_95: number;
}
</file>
          <file name="DailyWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type DailyWebhook = Terra.DailyEvent;
</file>
          <file name="DataContributor.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DataContributor {
    contributor_name: string;
    contributor_score: number;
}
</file>
          <file name="DataEnrichment.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DataEnrichment {
    /** User's stress score. */
    stress_score?: number;
}
</file>
          <file name="DataProcessingWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type DataProcessingWebhook = Terra.ProcessingEvent;
</file>
          <file name="DataSentToWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DataSentToWebhook {
    /** Payload reference, tying the request to the webhook payload which will be received */
    reference?: string;
    message?: string;
    /** Terra User object */
    user?: Terra.TerraUser;
}
</file>
          <file name="DeauthEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * User deauthentication event
 */
export interface DeauthEvent {
    type: "deauth";
    /** User who deauthenticated */
    user: Terra.TerraUser;
    /** Status of deauthentication */
    status: "success";
    /** Confirmation message */
    message: string;
}
</file>
          <file name="DeviceData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DeviceData {
    /** Activation timestamp of the device, if applicable. */
    activation_timestamp?: string;
    /** Data provided by the device, as enumerated types. */
    data_provided?: Terra.DeviceDataType[];
    /** Hardware version of the device. */
    hardware_version?: string;
    /** Last upload date from the device. */
    last_upload_date?: string;
    /** Device manufacturer name. */
    manufacturer?: string;
    /** Device name - note that this can also be the name of the application/package which the data comes from, if coming from a data aggregator such as Google Fit. */
    name?: string;
    /** Data pertaining to other devices which may have contributed data for this workout. */
    other_devices?: Terra.OtherDeviceData[];
    /** Sensor state of the device. */
    sensor_state?: string;
    /** Device Serial Number. */
    serial_number?: string;
    /** Device Software Version. */
    software_version?: string;
}
</file>
          <file name="DeviceDataType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents data types that a certain device contributed to.
 */
export type DeviceDataType =
    /**
     * Count of steps taken by the user. */
    | "STEPS"
    /**
     * Duration of time the user spent in physical activity. */
    | "ACTIVE_MINUTES"
    /**
     * User's basal metabolic rate - calories burned at rest. */
    | "BMR"
    /**
     * Calories burned by the user during activity. */
    | "CALORIES"
    /**
     * Distance traveled by the user during activity. */
    | "DISTANCE"
    /**
     * User's heart rate measurements. */
    | "HEART_RATE"
    /**
     * Blood oxygen saturation level (SpO2) of the user. */
    | "OXYGEN_SATURATION"
    /**
     * Classification of user's sleep stages or types. */
    | "SLEEP_TYPE"
    /**
     * User's movement speed during activity. */
    | "SPEED"
    /**
     * Rate of movement repetition during activity (steps per minute). */
    | "CADENCE";
export const DeviceDataType = {
    Steps: "STEPS",
    ActiveMinutes: "ACTIVE_MINUTES",
    BasalMetabolicRate: "BMR",
    Calories: "CALORIES",
    Distance: "DISTANCE",
    HeartRate: "HEART_RATE",
    OxygenSaturation: "OXYGEN_SATURATION",
    SleepClassification: "SLEEP_TYPE",
    Speed: "SPEED",
    Cadence: "CADENCE",
} as const;
</file>
          <file name="DistanceData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DistanceData {
    /** Object containing detailed distance information - this may included second-by-second samples. */
    detailed?: Terra.DistanceDataDetailed;
    /** Object containing summary information related to distance covered throughout the workout. */
    summary?: Terra.DistanceDataSummary;
}
</file>
          <file name="DistanceDataDetailed.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DistanceDataDetailed {
    /** Array of detailed samples of distance covered throughout the workout. */
    distance_samples?: Terra.DistanceSample[];
    /** Array of detailed samples of elevation throughout the workout. */
    elevation_samples?: Terra.ElevationSample[];
    /** Array of detailed samples of floors climbed throughout the workout, as determined by the fitness data provider. */
    floors_climbed_samples?: Terra.FloorsClimbedSample[];
    /** Array of detailed samples of steps performed throughout the workout. */
    step_samples?: Terra.StepSample[];
}
</file>
          <file name="DistanceDataSummary.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface DistanceDataSummary {
    /** Total distance covered by the user throughout the workout. */
    distance_meters?: number;
    /** Average elevation of the user throughout the workout. */
    elevation?: Terra.ElevationData;
    /** Total number of elevation gain in floors climbed equivalent throughout the workout, as determined by the fitness data provider. */
    floors_climbed?: number;
    /** Total number of steps performed during the workout. */
    steps?: number;
    /** Summary information of the user's swimming statistics for the workout, if applicable. */
    swimming?: Terra.SwimmingData;
}
</file>
          <file name="DistancePlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DistancePlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: DistancePlannedWorkoutStepDuration.DurationType;
    /** Target distance for the workout step - once the user covers this distance, the step will be completed */
    distance_meters?: number;
}

export namespace DistancePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="DistanceSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DistanceSample {
    timestamp: string;
    distance_meters: number;
    timer_duration_seconds: number;
}
</file>
          <file name="DrinkSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DrinkSample {
    timestamp: string;
    drink_volume: number;
    drink_unit: string;
    drink_name: string;
}
</file>
          <file name="EcgReading.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface EcgReading {
    start_timestamp: string;
    avg_hr_bpm: number;
    afib_classification: Terra.AFibFlag;
    raw_signal: Terra.RawEcgSample[];
}
</file>
          <file name="ElevationData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ElevationData {
    /** Average elevation of the user throughout the workout. */
    avg_meters?: number;
    /** Planned elevation gain for the workout. */
    gain_actual_meters?: number;
    /** Elevation gain of the user throughout the workout - this includes all elevation gain, and does _not_ represent net gain. */
    gain_planned_meters?: number;
    /** Elevation loss of the user throughout the workout. */
    loss_actual_meters?: number;
    /** Maximum elevation of the user during the workout. */
    max_meters?: number;
    /** Minimum elevation of the user during the workout. */
    min_meters?: number;
}
</file>
          <file name="ElevationSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ElevationSample {
    timestamp: string;
    elev_meters: number;
    timer_duration_seconds: number;
}
</file>
          <file name="EnergyData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface EnergyData {
    /** Total number of kiloJoules planned to be expended during the workout - represents the user's predefined goal for the workout */
    energy_kilojoules?: number;
    /** Total number of kiloJoules expended during the workout */
    energy_planned_kilojoules?: number;
}
</file>
          <file name="FixedRestPlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FixedRestPlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: FixedRestPlannedWorkoutStepDuration.DurationType;
    /** Time duration to be elapsed for the rest period */
    rest_seconds?: number;
}

export namespace FixedRestPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="FloorsClimbedSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FloorsClimbedSample {
    timestamp: string;
    floors_climbed: number;
    timer_duration_seconds: number;
}
</file>
          <file name="GlucoseData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface GlucoseData {
    /** List of blood glucose readings sampled throughout the day. */
    blood_glucose_samples?: Terra.GlucoseDataSample[];
    /** List of blood glucose readings sampled throughout the day - this represents additional data points, potentially at higher frequency from the ones in blood_glucose_samples, which may come at a cost of reduced accuracy. */
    detailed_blood_glucose_samples?: Terra.GlucoseDataSample[];
    /** User's average glucose level throughout the day. */
    day_avg_blood_glucose_mg_per_dL?: number;
    /** GMI (Glucose Management Indicator) is a metric derived from continuous glucose monitoring (CGM) data that estimates average glucose levels to help guide diabetes management, without implying a precise match to laboratory A1C. */
    gmi?: number;
    /** Time that the user's glucose is within acceptable range (not hyper or hypoglycemic). */
    time_in_range?: number;
    /** Number of data points recorded by the sensor throughout the day. */
    sensor_usage?: number;
    /** List of glucose percentile samples throughout the day. */
    daily_patterns?: Terra.DailyPatternSample[];
}
</file>
          <file name="GlucoseDataSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GlucoseDataSample {
    timestamp: string;
    blood_glucose_mg_per_dL: number;
    glucose_level_flag: number;
    trend_arrow: number;
}
</file>
          <file name="GoogleNoDataSourceWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type GoogleNoDataSourceWebhook = Terra.GoogleNoDatasourceEvent;
</file>
          <file name="GoogleNoDatasourceEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Google no datasource event
 */
export interface GoogleNoDatasourceEvent {
    type: "google_no_datasource";
    /** Affected user */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the issue */
    message: string;
}
</file>
          <file name="HealthCheckWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type HealthCheckWebhook = Terra.HealthcheckEvent;
</file>
          <file name="HealthcheckEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Healthcheck event sent periodically to verify your webhook endpoint is functional
 */
export interface HealthcheckEvent {
    type: "healthcheck";
    /** Timestamp when the event was created */
    creation_timestamp: string;
    /** Percentage change in trends */
    trend_percentage: number;
    /** Number of webhooks sent in the last hour */
    sent_webhooks_last_hour: number;
}
</file>
          <file name="HeartData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartData {
    /** List of Atrial Fibrillation classification measurements sampled through the day. */
    afib_classification_samples?: Terra.AFibClassificationSample[];
    /** List of ECGReadings sampled through the day. */
    ecg_signal?: Terra.EcgReading[];
    /** Object containing heart rate data. */
    heart_rate_data?: Terra.HeartRateData;
    /** List of Pulse Wave Velocity measurements sampled throughout the day. This represents a measurement of arterial stiffness that is an independent predictor of cardiovascular risk. */
    pulse_wave_velocity_samples?: Terra.PulseVelocitySample[];
    /** List of RR Interval samples throughout the day. */
    rr_interval_samples?: Terra.RrIntervalSample[];
}
</file>
          <file name="HeartRateContext.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents the context in which heart rate was measured.
 */
export type HeartRateContext =
    /**
     * Heart rate measurement context is not specified. */
    | 0
    /**
     * Heart rate was measured during physical activity or exercise. */
    | 1
    /**
     * Heart rate was measured during rest or non-active periods. */
    | 2;
export const HeartRateContext = {
    NotSet: 0,
    Active: 1,
    NotActive: 2,
} as const;
</file>
          <file name="HeartRateData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateData {
    /** Object containing detailed heart rate information for the associated workout. */
    detailed?: Terra.HeartRateDataDetailed;
    /** Object containing summary heart rate information for the associated workout. */
    summary?: Terra.HeartRateDataSummary;
}
</file>
          <file name="HeartRateDataDetailed.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateDataDetailed {
    /** Array of HeartRate data samples recorded for the user during the workout. */
    hr_samples?: Terra.HeartRateDataSample[];
    /** Array of HeartRate Variability data samples recorded for the user during the workout, computed using RMSSD. */
    hrv_samples_rmssd?: Terra.HeartRateVariabilityDataSampleRmssd[];
    /** Array of HeartRate Variability data samples recorded for the user during the workout, computed using SDNN. */
    hrv_samples_sdnn?: Terra.HeartRateVariabilityDataSampleSdnn[];
}
</file>
          <file name="HeartRateDataSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateDataSample {
    timestamp: string;
    bpm: number;
    timer_duration_seconds: number;
    context: Terra.HeartRateContext;
}
</file>
          <file name="HeartRateDataSummary.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateDataSummary {
    /** Average HeartRate of the user during the workout. */
    avg_hr_bpm?: number;
    /** Average HeartRate Variability of the user during the workout, computed using RMSSD. */
    avg_hrv_rmssd?: number;
    /** Average HeartRate Variability of the user during the workout, computed using SDNN. */
    avg_hrv_sdnn?: number;
    /** Array of time spent in various HR zones throughout the workout. */
    hr_zone_data?: Terra.HeartRateZoneData[];
    /** Maximum HeartRate of the user during the workout. */
    max_hr_bpm?: number;
    /** Minimum HeartRate of the user during the workout. */
    min_hr_bpm?: number;
    /** Resting HeartRate of the user, as determined by the fitness data provider. */
    resting_hr_bpm?: number;
    /** User's maximum HeartRate based on their age, and other factors as determined by the fitness data provider. */
    user_max_hr_bpm?: number;
}
</file>
          <file name="HeartRateVariabilityDataSampleRmssd.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HeartRateVariabilityDataSampleRmssd {
    timestamp: string;
    hrv_rmssd: number;
}
</file>
          <file name="HeartRateVariabilityDataSampleSdnn.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HeartRateVariabilityDataSampleSdnn {
    timestamp: string;
    hrv_sdnn: number;
}
</file>
          <file name="HeartRateZone.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents the heart rate zone the user is currently in during a workout or activity
 */
export type HeartRateZone =
    /**
     * Resting heart rate zone. */
    | 0
    /**
     * Very light activity zone. */
    | 1
    /**
     * Light activity zone. */
    | 2
    /**
     * Moderate activity zone. */
    | 3
    /**
     * Hard activity zone. */
    | 4
    /**
     * Maximum effort zone. */
    | 5
    /**
     * Heart rate zone that doesn't fit into the standard zones or couldn't be classified. */
    | 6;
export const HeartRateZone = {
    Zone0: 0,
    Zone1: 1,
    Zone2: 2,
    Zone3: 3,
    Zone4: 4,
    Zone5: 5,
    Other: 6,
} as const;
</file>
          <file name="HeartRateZoneData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HeartRateZoneData {
    zone: Terra.HeartRateZone;
    start_percentage: number;
    end_percentage: number;
    name: string;
    duration_seconds: number;
}
</file>
          <file name="HrAbovePlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HrAbovePlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: HrAbovePlannedWorkoutStepDuration.DurationType;
    /** Threshold heart rate goal to complete the workout step - once the user's heart rate reaches above below this value, the step will be completed */
    hr_above_bpm?: number;
}

export namespace HrAbovePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="HrBelowPlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HrBelowPlannedWorkoutStepDuration {
    /** Threshold heart rate goal to complete the workout step - once the user's heart rate reaches below this value, the step will be completed */
    hr_below_bpm?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: HrBelowPlannedWorkoutStepDuration.DurationType;
}

export namespace HrBelowPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="HrPlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HrPlannedWorkoutStepTarget {
    /** Maximum max heart rate percentage threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    hr_percentage_low?: number;
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: HrPlannedWorkoutStepTarget.TargetType;
    /** Minimum heart rate percentage threshold for the workout step - i.e. the user is to stay above this value during the workout */
    hr_percentage_high?: number;
    /** Ideal percentage of user's maximum HR to be maintained workout step */
    hr_percentage?: number;
    /** Maximum heart rate threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    hr_bpm_high?: number;
    /** Minimum heart rate threshold for the workout step - i.e. the user is to stay above this value during the workout */
    hr_bpm_low?: number;
}

export namespace HrPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="HydrationData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface HydrationData {
    /** User's total water consumption throughout the day. */
    day_total_water_consumption_ml?: number;
    /** User's hydration level samples throughout the day. */
    hydration_amount_samples?: Terra.HydrationMeasurementSample[];
}
</file>
          <file name="HydrationMeasurementSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface HydrationMeasurementSample {
    timestamp: string;
    hydration_kg: number;
}
</file>
          <file name="IfPlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface IfPlannedWorkoutStepTarget {
    /** Maximum Intensity Factor to be achieved for the workout step */
    if_high?: number;
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: IfPlannedWorkoutStepTarget.TargetType;
    /** Minimum Intensity Factor to be achieved for the workout step */
    if_low?: number;
}

export namespace IfPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="IntegrationProvider.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface IntegrationProvider {
    /** Identifier for the provider */
    provider?: string;
    /** Display name of the integration */
    name?: string;
    /** URL for the provider's icon image */
    icon?: string;
    /** Indicates how the integration is set up */
    setup?: string;
    /** Whether the integration is enabled */
    enabled?: boolean;
    /** Indicates the types of data available through the provider */
    types?: IntegrationProvider.Types;
}

export namespace IntegrationProvider {
    /**
     * Indicates the types of data available through the provider
     */
    export interface Types {
        activity?: boolean;
        body?: boolean;
        nutrition?: boolean;
        daily?: boolean;
        sleep?: boolean;
        menstruation?: boolean;
    }
}
</file>
          <file name="IntegrationsResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface IntegrationsResponse {
    /** Status of the API response */
    status?: string;
    /** List of integration providers with their details */
    providers?: Terra.IntegrationProvider[];
}
</file>
          <file name="KetoneData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface KetoneData {
    /** List of ketone data sampled through the day. */
    ketone_samples?: Terra.KetoneSample[];
}
</file>
          <file name="KetoneSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface KetoneSample {
    timestamp: string;
    ketone_mg_per_dL: number;
    sample_type: Terra.KetoneSampleType;
}
</file>
          <file name="KetoneSampleType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Flag indicating the ketone sample type (e.g. blood, breath, urine)
 */
export type KetoneSampleType =
    /**
     * The type of ketone sample is unknown or not specified. */
    | 0
    /**
     * Ketone sample taken from blood. */
    | 1
    /**
     * Ketone sample taken from urine. */
    | 2
    /**
     * Ketone sample taken from breath. */
    | 3;
export const KetoneSampleType = {
    Unknown: 0,
    Blood: 1,
    Urine: 2,
    Breath: 3,
} as const;
</file>
          <file name="LapData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface LapData {
    /** Array of datapoints for each lap performed by the user during the workout. */
    laps?: Terra.LapSample[];
}
</file>
          <file name="LapSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface LapSample {
    start_time: string;
    end_time: string;
    distance_meters: number;
    calories: number;
    total_strokes: number;
    stroke_type: Terra.StrokeType;
    avg_speed_meters_per_second: number;
}
</file>
          <file name="LargeRequestProcessingEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Large request processing event
 */
export interface LargeRequestProcessingEvent {
    type: "large_request_processing";
    /** Status of the processing */
    status: "processing";
    /** Information about the processing */
    message: string;
    /** User whose data is being processed */
    user: Terra.TerraUser;
    /** Reference ID for tracking this request */
    reference: string;
}
</file>
          <file name="LargeRequestProcessingResponse.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type LargeRequestProcessingResponse = Terra.LargeRequestProcessingEvent;
</file>
          <file name="LargeRequestSendingEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Large request sending event
 */
export interface LargeRequestSendingEvent {
    type: "large_request_sending";
    /** User whose data is being sent */
    user: Terra.TerraUser;
    /** Reference ID for tracking this request */
    reference: string;
    /** Information about the request */
    message: string;
    /** Number of expected payload events */
    expected_payloads: number;
}
</file>
          <file name="LargeRequestSendingWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type LargeRequestSendingWebhook = Terra.LargeRequestSendingEvent;
</file>
          <file name="Meal.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Meal {
    /** Micronutrient information for associated food. */
    micros: Terra.NutritionMicros;
    /** Enum representing the category the consumed food/meal falls under (i.e. Breakfast/Lunch/Dinner etc). */
    type: Terra.MealType;
    /** Identifier for food logged by the user. */
    id: string;
    /** Timestamp the food is associated with, in ISO8601 format, with microsecond precision. */
    timestamp: string;
    /** Quantity of the food that was consumed, containing information on amount &amp; units in which this was recorded. */
    quantity: Terra.NutritionQuantity;
    /** Name of food logged by the user. */
    name: string;
    /** Macronutrient information for associated food. */
    macros: Terra.NutritionMacros;
}
</file>
          <file name="MealType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Enum representing the category the consumed food/meal falls under (i.e. Breakfast/Lunch/Dinner etc)
 */
export type MealType =
    /**
     * Meal type is unknown or could not be determined. */
    | 0
    /**
     * Meal consumed in the morning, typically the first meal of the day. */
    | 1
    /**
     * Light meal or snack consumed in the morning, between breakfast and lunch. */
    | 2
    /**
     * Meal consumed around midday, typically the second meal of the day. */
    | 3
    /**
     * Light meal or snack consumed in the afternoon, between lunch and dinner. */
    | 4
    /**
     * Meal consumed in the evening, typically the last main meal of the day. */
    | 5
    /**
     * Any light meal or snack consumed at any time, not fitting into main meal categories. */
    | 6;
export const MealType = {
    Unknown: 0,
    Breakfast: 1,
    MorningSnack: 2,
    Lunch: 3,
    AfternoonSnack: 4,
    Dinner: 5,
    Snack: 6,
} as const;
</file>
          <file name="MeasurementDataSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MeasurementDataSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    measurement_time?: string;
    /** User's Body Mass Index (BMI). */
    BMI?: number;
    /** User's Basal Metabolic Rate - minimum amount of calories that a person's body needs to perform necessary functions. */
    BMR?: number;
    /** User's Resting Metabolic Rate - amount of energy that a person's body needs to function while at rest. RMR accounts for additional low-effort daily activities on top of basic body functions. */
    RMR?: number;
    /** Estimate of how fit the user is compared to their actual age, as measured by the device. */
    estimated_fitness_age?: string;
    /** User's skin fold measurement. */
    skin_fold_mm?: number;
    /** User's body fat percentage. */
    bodyfat_percentage?: number;
    /** User's body weight. */
    weight_kg?: number;
    /** User's height. */
    height_cm?: number;
    /** User's total bone mass. */
    bone_mass_g?: number;
    /** User's total muscle mass (i.e. skeletal muscle mass). */
    muscle_mass_g?: number;
    /** Total lean mass of the user - calculated as the difference between total body weight and body fat weight. */
    lean_mass_g?: number;
    /** Total amount of fluid in the user's body. */
    water_percentage?: number;
    /** Quantity of insulin administered to the user. */
    insulin_units?: number;
    /** Type of insulin administered to the user. */
    insulin_type?: string;
    /** Color of the user's urine. */
    urine_color?: string;
    /** User notes associated with the measurement. */
    user_notes?: string;
}
</file>
          <file name="MeasurementsData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MeasurementsData {
    /** List of body metrics &amp; measurements taken throughout the associated day. */
    measurements?: Terra.MeasurementDataSample[];
}
</file>
          <file name="MenstrualPhase.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents menstrual cycle phases.
 */
export type MenstrualPhase =
    /**
     * The menstrual phase when bleeding occurs. */
    | "menstrual"
    /**
     * The follicular phase when follicles in ovaries develop. */
    | "follicular"
    /**
     * The ovulation phase when an egg is released. */
    | "ovulation"
    /**
     * The luteal phase following ovulation. */
    | "luteal"
    /**
     * Premenstrual syndrome phase before menstruation begins. */
    | "pms"
    /**
     * The fertile window when conception is most likely. */
    | "fertile"
    /**
     * First third of pregnancy, weeks 1-12. */
    | "first_trimester"
    /**
     * Middle third of pregnancy, weeks 13-26. */
    | "second_trimester"
    /**
     * Final third of pregnancy, weeks 27-40. */
    | "third_trimester"
    /**
     * Menstrual cycle phase could not be determined. */
    | "unknown";
export const MenstrualPhase = {
    Menstrual: "menstrual",
    Follicular: "follicular",
    Ovulation: "ovulation",
    Luteal: "luteal",
    Pms: "pms",
    Fertile: "fertile",
    FirstTrimester: "first_trimester",
    SecondTrimester: "second_trimester",
    ThirdTrimester: "third_trimester",
    Unknown: "unknown",
} as const;
</file>
          <file name="Menstruation.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Menstruation {
    /** Object containing daily summary metadata. */
    metadata: Terra.MenstruationMetadata;
    /** Object containing information on user's menstruation for a given day. */
    menstruation_data?: Terra.MenstruationData;
}
</file>
          <file name="MenstruationData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MenstruationData {
    /** Total length of period (i.e. menstrual bleeding). */
    period_length_days?: number;
    /** Phase in associated cycle, (i.e. menstruation, fertile etc). */
    current_phase?: Terra.MenstrualPhase;
    /** Length of current phase. */
    length_of_current_phase_days?: number;
    /** Number of days to reach the next phase (predicted). */
    days_until_next_phase?: number;
    /** Start date of menstrual cycle, in ISO8601 format. */
    period_start_date?: string;
    /** Prediction of the cycle's total length. */
    predicted_cycle_length_days?: number;
    /** Number of day in cycle this object is associated with. */
    day_in_cycle?: number;
    /** Last time when the user recorded information regarding their cycle, in ISO8601 format, with microseconds precision. */
    last_updated_time?: string;
    /** Total cycle length. */
    cycle_length_days?: string;
    /** Flag indicating whether associated object is a prediction or user-logged information. */
    is_predicted_cycle?: string;
    /** List of user logs of information related to the strength of user's menstrual flow. */
    menstruation_flow?: Terra.MenstruationFlowSample[];
}
</file>
          <file name="MenstruationEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Menstruation data event
 */
export interface MenstruationEvent {
    type: "menstruation";
    /** Array of menstruation data */
    data: Terra.Menstruation[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="MenstruationFlow.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Flag indicating the strength of the user's menstrual flow
 */
export type MenstruationFlow =
    /**
     * Flow status is unknown or not recorded. */
    | 0
    /**
     * No menstrual flow present. */
    | 1
    /**
     * Light menstrual flow. */
    | 2
    /**
     * Moderate menstrual flow. */
    | 3
    /**
     * Heavy menstrual flow. */
    | 4
    /**
     * Menstrual flow occurred but intensity not specified. */
    | 5;
export const MenstruationFlow = {
    Unknown: 0,
    None: 1,
    Light: 2,
    Medium: 3,
    Heavy: 4,
    Had: 5,
} as const;
</file>
          <file name="MenstruationFlowSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MenstruationFlowSample {
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp: string;
    /** Flag indicating the strength of the user's menstrual flow. */
    flow: Terra.MenstruationFlow;
}
</file>
          <file name="MenstruationMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MenstruationMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
}
</file>
          <file name="MenstruationWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type MenstruationWebhook = Terra.MenstruationEvent;
</file>
          <file name="MetData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MetData {
    /** An array of Metabolic Equivalent Time samples, as calculated by the user's wearable. */
    MET_samples?: Terra.MetSample[];
    /** The average MET level of the activity. */
    avg_level?: number;
    /** Number of minutes spent in High Intensity during the workout - based off MET scale. */
    num_high_intensity_minutes?: number;
    /** Number of minutes spent in state of Inactivity during the workout - based off MET scale. */
    num_inactive_minutes?: number;
    /** Number of minutes spent in Low Intensity during the workout - based off MET scale. */
    num_low_intensity_minutes?: number;
    /** Number of minutes spent in Moderate Intensity during the workout - based off MET scale. */
    num_moderate_intensity_minutes?: number;
}
</file>
          <file name="MetSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MetSample {
    timestamp: string;
    level: number;
}
</file>
          <file name="MovementData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface MovementData {
    /** Adjusted max speed of the user during the workout - generated using Terra's algorithms to remove potential affecting the user's actual max speed measurement. */
    adjusted_max_speed_meters_per_second?: number;
    /** Average cadence of the user during the workout, in RPM. */
    avg_cadence_rpm?: number;
    /** Average pace of the user during the workout. */
    avg_pace_minutes_per_kilometer?: number;
    /** Average speed of the user during the workout. */
    avg_speed_meters_per_second?: number;
    /** Average torque generated by the user during the workout - mainly relevant for cycling activities. */
    avg_torque_newton_meters?: number;
    /** Average velocity of the user during the workout - only calculated by certain providers, representing a separate quantity from speed. */
    avg_velocity_meters_per_second?: number;
    /** Array of cadence values recorded throughout the workout, sampled at intervals determined by the fitness data provider. */
    cadence_samples?: Terra.CadenceSample[];
    /** Maximum cadence of the user during the workout - mainly relevant for cycling activities. */
    max_cadence_rpm?: number;
    /** Maximum pace of the user during the workout. */
    max_pace_minutes_per_kilometer?: number;
    /** Maximum speed of the user during the workout. */
    max_speed_meters_per_second?: number;
    /** Maximum torque generated by the user during the workout - mainly relevant for cycling activities. */
    max_torque_newton_meters?: number;
    /** Maximum velocity of the user during the workout - only calculated by certain providers, representing a separate quantity from speed. */
    max_velocity_meters_per_second?: number;
    /** Average normalized speed of the user during the workout - only calculated by certain providers, representing a separate quantity from speed. */
    normalized_speed_meters_per_second?: number;
    /** Array of the datapoints for the user's speed sampled throughout the workout. */
    speed_samples?: Terra.SpeedSample[];
    /** Array of the datapoints for the user's torque sampled throughout the workout. */
    torque_samples?: Terra.TorqueSample[];
}
</file>
          <file name="NoDataReturned.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NoDataReturned {
    status?: NoDataReturned.Status;
    message?: string;
    /** Terra User object */
    user?: Terra.TerraUser;
}

export namespace NoDataReturned {
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
          <file name="NotFoundErrorBody.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NotFoundErrorBody {
    /** a detailed message describing the error */
    message?: string;
    /** indicates that an error happened (value is error) */
    status?: "error";
}
</file>
          <file name="Nutrition.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Nutrition {
    /** Information on drinks the user consumed throughout the day. */
    drink_samples?: Terra.DrinkSample[];
    /** Information on individual foods consumed throughout a given day. */
    meals?: Terra.Meal[];
    /** Object containing daily summary metadata. */
    metadata: Terra.NutritionMetadata;
    /** Summative nutritional information for a given day. */
    summary?: Terra.NutritionSummary;
}
</file>
          <file name="NutritionEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Nutrition data event
 */
export interface NutritionEvent {
    type: "nutrition";
    /** Array of nutrition data */
    data: Terra.Nutrition[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="NutritionMacros.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NutritionMacros {
    /** Alcohol content of the associated food(s). */
    alcohol_g?: number;
    /** Calorie content of the associated food(s). */
    calories?: number;
    /** Carbohydrates content of the associated food(s). */
    carbohydrates_g?: number;
    /** Cholesterol content of the associated food(s). */
    cholesterol_mg?: number;
    /** Fat content of the associated food(s). */
    fat_g?: number;
    /** Fiber content of the associated food(s). */
    fiber_g?: number;
    /** Net carbs content of the associated food(s). */
    net_carbohydrates_g?: number;
    /** Protein content of the associated food(s). */
    protein_g?: number;
    /** Saturated fat content of the associated food(s). */
    saturated_fat_g?: number;
    /** Sodium content of the associated food(s). */
    sodium_mg?: number;
    /** Sugar content of the associated food(s). */
    sugar_g?: number;
    /** Trans fat content of the associated food(s). */
    trans_fat_g?: number;
}
</file>
          <file name="NutritionMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NutritionMetadata {
    /** The end time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h after start_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** The start time of the associated day, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    timestamp_localization?: Terra.TimestampLocalization;
}
</file>
          <file name="NutritionMicros.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NutritionMicros {
    /** Biotin content of the associated food(s). */
    biotin_mg?: number;
    /** Caffeine content of the associated food(s). */
    caffeine_mg?: number;
    /** Calcium content of the associated food(s). */
    calcium_mg?: number;
    /** Chloride content of the associated food(s). */
    chloride_mg?: number;
    /** Chromium content of the associated food(s). */
    chromium_mg?: number;
    /** Copper content of the associated food(s). */
    copper_mg?: number;
    /** Folate content of the associated food(s). */
    folate_mg?: number;
    /** Folic Acid content of the associated food(s). */
    folic_acid_mg?: number;
    /** Iodine content of the associated food(s). */
    iodine_mg?: number;
    /** Iron content of the associated food(s). */
    iron_mg?: number;
    /** Magnesium content of the associated food(s). */
    magnesium_mg?: number;
    /** Manganese content of the associated food(s). */
    manganese_mg?: number;
    /** Molybdenum content of the associated food(s). */
    molybdenum_mg?: number;
    /** Niacin content of the associated food(s). */
    niacin_mg?: number;
    /** Pantothenic content of the associated food(s). */
    pantothenic_acid_mg?: number;
    /** Phosphorus content of the associated food(s). */
    phosphorus_mg?: number;
    /** Potassium content of the associated food(s). */
    potassium_mg?: number;
    /** Riboflavin content of the associated food(s). */
    riboflavin_mg?: number;
    /** Selenium content of the associated food(s). */
    selenium_mg?: number;
    /** Thiamin content of the associated food(s). */
    thiamin_mg?: number;
    /** Vitamin A content of the associated food(s). */
    vitamin_A_mg?: number;
    /** Vitamin B12 content of the associated food(s). */
    vitamin_B12_mg?: number;
    /** Vitamin B6 content of the associated food(s). */
    vitamin_B6_mg?: number;
    /** Vitamin C content of the associated food(s). */
    vitamin_C_mg?: number;
    /** Vitamin D content of the associated food(s). */
    vitamin_D_mg?: number;
    /** Vitamin D2 content of the associated food(s). */
    vitamin_D2_mg?: number;
    /** Vitamin D3 content of the associated food(s). */
    vitamin_D3_mg?: number;
    /** Vitamin E content of the associated food(s). */
    vitamin_E_mg?: number;
    /** Vitamin K content of the associated food(s). */
    vitamin_K_mg?: number;
    /** Zinc content of the associated food(s). */
    zinc_mg?: number;
    /** Cystine content of the associated food(s). */
    cystine_g?: number;
    /** Histidine content of the associated food(s). */
    histidine_g?: number;
    /** Isoleucine content of the associated food(s). */
    isoleucine_g?: number;
    /** Leucine content of the associated food(s). */
    leucine_g?: number;
    /** Lysine content of the associated food(s). */
    lysine_g?: number;
    /** Methionine content of the associated food(s). */
    methionine_g?: number;
    /** Phenylalanine content of the associated food(s). */
    phenylalanine_g?: number;
    /** Threonine content of the associated food(s). */
    threonine_g?: number;
    /** Tryptophan content of the associated food(s). */
    tryptophan_g?: number;
    /** Tyrosine content of the associated food(s). */
    tyrosine_g?: number;
    /** Valine content of the associated food(s). */
    valine_g?: number;
    /** Monounsaturated fat content of the associated food(s). */
    monounsaturated_fat_g?: number;
    /** Polyunsaturated fat content of the associated food(s). */
    polyunsaturated_fat_g?: number;
    /** Omega3 content of the associated food(s). */
    omega3_g?: number;
    /** Omega6 content of the associated food(s). */
    omega6_g?: number;
    /** Starch content of the associated food(s). */
    starch_g?: number;
}
</file>
          <file name="NutritionQuantity.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NutritionQuantity {
    unit: Terra.NutritionUnits;
    amount: number;
}
</file>
          <file name="NutritionSummary.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface NutritionSummary {
    /** Summary of macronutrient information for a given day. */
    macros?: Terra.NutritionMacros;
    /** Summary of micronutrient information for a given day. */
    micros?: Terra.NutritionMicros;
    /** Water consumption of the user for a given day. */
    water_ml?: number;
    /** Non-water drink consumption of the user for a given day. */
    drink_ml?: number;
}
</file>
          <file name="NutritionUnits.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents units used for nutrition measurements
 */
export type NutritionUnits =
    /**
     * The unit of measurement is unknown or not specified. */
    | 0
    /**
     * Measurement in grams, a metric unit of mass. */
    | 1
    /**
     * Measurement in teaspoons, approximately 5 milliliters. */
    | 2
    /**
     * Measurement in tablespoons, approximately 15 milliliters. */
    | 3
    /**
     * Measurement in cups, approximately 240 milliliters. */
    | 4
    /**
     * Quantity measured in medium-sized eggs. */
    | 5
    /**
     * Quantity measured in large-sized eggs. */
    | 6
    /**
     * Quantity measured in small-sized eggs. */
    | 7
    /**
     * Measurement in milliliters, a metric unit of volume. */
    | 8
    /**
     * Measurement in ounces, approximately 28 grams. */
    | 9
    /**
     * Quantity measured by individual count or number of items. */
    | 10
    /**
     * Quantity measured in scoops, typically used for protein powder or supplements. */
    | 11
    /**
     * Measurement in fluid ounces, approximately 30 milliliters. */
    | 12;
export const NutritionUnits = {
    Unknown: 0,
    Gram: 1,
    Teaspoon: 2,
    Tablespoon: 3,
    Cup: 4,
    MediumEgg: 5,
    LargeEgg: 6,
    SmallEgg: 7,
    Milliliter: 8,
    Ounce: 9,
    Count: 10,
    Scoop: 11,
    FluidOunce: 12,
} as const;
</file>
          <file name="NutritionWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type NutritionWebhook = Terra.NutritionEvent;
</file>
          <file name="OtherDeviceData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OtherDeviceData {
    /** Device manufacturer name. */
    manufacturer?: string;
    /** Hardware version of the device. */
    hardware_version?: string;
    /** Device Serial Number. */
    serial_number?: string;
    /** Device name - note that this can also be the name of the application/package which the data comes from, if coming from a data aggregator such as Google Fit. */
    name?: string;
    /** Device Software Version. */
    software_version?: string;
    activation_timestamp?: string;
    data_provided?: Terra.DeviceDataType[];
    last_upload_date?: string;
}
</file>
          <file name="OtherSleepDurations.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface OtherSleepDurations {
    /** Total duration of time spent in bed. */
    duration_in_bed_seconds?: number;
    /** Total duration during which the user's state (awake, asleep, REM, etc) was unmeasurable during the sleep session. */
    duration_unmeasurable_sleep_seconds?: number;
}
</file>
          <file name="OxygenData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OxygenData {
    /** Average Oxygen Saturation percentage of the user during the day (SpO2 or SmO2). */
    avg_saturation_percentage?: number;
    /** Array of Oxygen Saturation percentage datapoints sampled throughout the day. */
    saturation_samples?: Terra.OxygenSaturationSample[];
    /** Array of VO2 datapoints sampled throughout the day. */
    vo2_samples?: Terra.Vo2MaxSample[];
    /** VO2Max for the given user. */
    vo2max_ml_per_min_per_kg?: number;
}
</file>
          <file name="OxygenSaturationData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface OxygenSaturationData {
    /** Average Oxygen Saturation percentage of the user during the sleep session. */
    avg_saturation_percentage?: number;
    /** The end time of the recording of oxygen saturation, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time?: string;
    /** Array of Oxygen Saturation percentage datapoints sampled throughout the sleep session. */
    samples?: Terra.OxygenSaturationSample[];
    /** The start time of the recording of oxygen saturation, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time?: string;
}
</file>
          <file name="OxygenSaturationSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface OxygenSaturationSample {
    timestamp: string;
    percentage: number;
}
</file>
          <file name="PacePlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PacePlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: PacePlannedWorkoutStepTarget.TargetType;
    /** Ideal pace value to be maintained for the workout step */
    pace_minutes_per_kilometer?: number;
}

export namespace PacePlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="PermissionChangeEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Permission change event
 */
export interface PermissionChangeEvent {
    type: "permission_change";
    /** User who changed permissions */
    user: Terra.TerraUser;
    /** Status of the event */
    status: "warning";
    /** Information about the permission change */
    message: string;
    /** API version */
    version: string;
    /** Newly added scopes */
    scopes_added: string;
    /** Removed scopes */
    scopes_removed: string;
}
</file>
          <file name="PermissionChangeWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PermissionChangeWebhook = Terra.PermissionChangeEvent;
</file>
          <file name="PilatesPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PilatesPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}
</file>
          <file name="PlannedWorkout.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PlannedWorkout {
    /** List of exercises/steps/intervals for the workout plan */
    steps?: Terra.PlannedWorkoutSteps[];
    /** Metadata for the workout plan */
    metadata?: Terra.PlannedWorkoutMetadata;
}
</file>
          <file name="PlannedWorkoutMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PlannedWorkoutMetadata {
    /** Estimated energy expenditure for the workout */
    estimated_energy_kj?: number;
    /** Estimated speed for the workout */
    estimated_speed_meters_per_second?: number;
    /** Estimated elevation gain for the workout */
    estimated_elevation_gain_meters?: number;
    /** Estimated Training Stress Score for the workout */
    estimated_tss?: number;
    /** Estimated calorie burn for the workout */
    estimated_calories?: number;
    /** The creation datetime of the associated workout, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    created_date?: string;
    /** The planned start datetime, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time */
    planned_date?: string;
    /** The name - either user-entered or given by the fitness data provider - of the associated workout plan */
    type?: PlannedWorkoutMetadata.Type;
    id?: string;
    /** Estimated workout duration */
    estimated_duration_seconds?: number;
    /** Estimated pace for the workout */
    estimated_pace_minutes_per_kilometer?: number;
    /** Name of the original source of the workout plan */
    provider?: string;
    /** */
    estimated_tscore?: number;
    /** Description of the workout */
    description?: string;
    /** Name of the workout plan */
    name?: string;
    /** Estimated distance for the workout */
    estimated_distance_meters?: number;
    /** Estimated Intensity Factor for the workout */
    estimated_if?: number;
    /** Pool length of the pool used for the workout - only relevant for swimming activity types */
    pool_length_meters?: number;
}

export namespace PlannedWorkoutMetadata {
    /**
     * The name - either user-entered or given by the fitness data provider - of the associated workout plan
     */
    export type Type =
        | "IN_VEHICLE"
        | "BIKING"
        | "STILL"
        | "UNKNOWN"
        | "TILTING"
        | "WALKING"
        | "RUNNING"
        | "AEROBICS"
        | "BADMINTON"
        | "BASEBALL"
        | "BASKETBALL"
        | "BIATHLON"
        | "HANDBIKING"
        | "MOUNTAIN_BIKING"
        | "ROAD_BIKING"
        | "SPINNING"
        | "STATIONARY_BIKING"
        | "UTILITY_BIKING"
        | "BOXING"
        | "CALISTHENICS"
        | "CIRCUIT_TRAINING"
        | "CRICKET"
        | "DANCING"
        | "ELLIPTICAL"
        | "FENCING"
        | "AMERICAN_FOOTBALL"
        | "AUSTRALIAN_FOOTBALL"
        | "ENGLISH_FOOTBALL"
        | "FRISBEE"
        | "GARDENING"
        | "GOLF"
        | "GYMNASTICS"
        | "HANDBALL"
        | "HIKING"
        | "HOCKEY"
        | "HORSEBACK_RIDING"
        | "HOUSEWORK"
        | "JUMPING_ROPE"
        | "KAYAKING"
        | "KETTLEBELL_TRAINING"
        | "KICKBOXING"
        | "KITESURFING"
        | "MARTIAL_ARTS"
        | "MEDITATION"
        | "MIXED_MARTIAL_ARTS"
        | "P90X_EXERCISES"
        | "PARAGLIDING"
        | "PILATES"
        | "POLO"
        | "RACQUETBALL"
        | "ROCK_CLIMBING"
        | "ROWING"
        | "ROWING_MACHINE"
        | "RUGBY"
        | "JOGGING"
        | "RUNNING_ON_SAND"
        | "TREADMILL_RUNNING"
        | "SAILING"
        | "SCUBA_DIVING"
        | "SKATEBOARDING"
        | "SKATING"
        | "CROSS_SKATING"
        | "INDOOR_ROLLERBLADING"
        | "SKIING"
        | "BACK_COUNTRY_SKIING"
        | "CROSS_COUNTRY_SKIING"
        | "DOWNHILL_SKIING"
        | "KITE_SKIING"
        | "ROLLER_SKIING"
        | "SLEDDING"
        | "SNOWBOARDING"
        | "SNOWMOBILE"
        | "SNOWSHOEING"
        | "SQUASH"
        | "STAIR_CLIMBING"
        | "STAIR_CLIMBING_MACHINE"
        | "STAND_UP_PADDLEBOARDING"
        | "STRENGTH_TRAINING"
        | "SURFING"
        | "SWIMMING"
        | "SWIMMING_SWIMMING_POOL"
        | "SWIMMING_OPEN_WATER"
        | "TABLE_TENNIS"
        | "TEAM_SPORTS"
        | "TENNIS"
        | "TREADMILL"
        | "VOLLEYBALL"
        | "VOLLEYBALL_BEACH"
        | "VOLLEYBALL_INDOOR"
        | "WAKEBOARDING"
        | "WALKING_FITNESS"
        | "NORDIC_WALKING"
        | "WALKING_TREADMILL"
        | "WATERPOLO"
        | "WEIGHTLIFTING"
        | "WHEELCHAIR"
        | "WINDSURFING"
        | "YOGA"
        | "ZUMBA"
        | "DIVING"
        | "ERGOMETER"
        | "ICE_SKATING"
        | "INDOOR_SKATING"
        | "CURLING"
        | "OTHER"
        | "CROSSFIT"
        | "HIIT"
        | "INTERVAL_TRAINING"
        | "WALKING_STROLLER"
        | "ELEVATOR"
        | "ESCALATOR"
        | "ARCHERY"
        | "SOFTBALL"
        | "GUIDED_BREATHING"
        | "CARDIO_TRAINING"
        | "LACROSSE"
        | "STRETCHING"
        | "TRIATHLON"
        | "INLINE_SKATING"
        | "SKY_DIVING"
        | "PADDLING"
        | "MOUNTAINEERING"
        | "FISHING"
        | "WATER_SKIING"
        | "INDOOR_RUNNING";
    export const Type = {
        InVehicle: "IN_VEHICLE",
        Biking: "BIKING",
        Still: "STILL",
        Unknown: "UNKNOWN",
        Tilting: "TILTING",
        Walking: "WALKING",
        Running: "RUNNING",
        Aerobics: "AEROBICS",
        Badminton: "BADMINTON",
        Baseball: "BASEBALL",
        Basketball: "BASKETBALL",
        Biathlon: "BIATHLON",
        Handbiking: "HANDBIKING",
        MountainBiking: "MOUNTAIN_BIKING",
        RoadBiking: "ROAD_BIKING",
        Spinning: "SPINNING",
        StationaryBiking: "STATIONARY_BIKING",
        UtilityBiking: "UTILITY_BIKING",
        Boxing: "BOXING",
        Calisthenics: "CALISTHENICS",
        CircuitTraining: "CIRCUIT_TRAINING",
        Cricket: "CRICKET",
        Dancing: "DANCING",
        Elliptical: "ELLIPTICAL",
        Fencing: "FENCING",
        AmericanFootball: "AMERICAN_FOOTBALL",
        AustralianFootball: "AUSTRALIAN_FOOTBALL",
        EnglishFootball: "ENGLISH_FOOTBALL",
        Frisbee: "FRISBEE",
        Gardening: "GARDENING",
        Golf: "GOLF",
        Gymnastics: "GYMNASTICS",
        Handball: "HANDBALL",
        Hiking: "HIKING",
        Hockey: "HOCKEY",
        HorsebackRiding: "HORSEBACK_RIDING",
        Housework: "HOUSEWORK",
        JumpingRope: "JUMPING_ROPE",
        Kayaking: "KAYAKING",
        KettlebellTraining: "KETTLEBELL_TRAINING",
        Kickboxing: "KICKBOXING",
        Kitesurfing: "KITESURFING",
        MartialArts: "MARTIAL_ARTS",
        Meditation: "MEDITATION",
        MixedMartialArts: "MIXED_MARTIAL_ARTS",
        P90XExercises: "P90X_EXERCISES",
        Paragliding: "PARAGLIDING",
        Pilates: "PILATES",
        Polo: "POLO",
        Racquetball: "RACQUETBALL",
        RockClimbing: "ROCK_CLIMBING",
        Rowing: "ROWING",
        RowingMachine: "ROWING_MACHINE",
        Rugby: "RUGBY",
        Jogging: "JOGGING",
        RunningOnSand: "RUNNING_ON_SAND",
        TreadmillRunning: "TREADMILL_RUNNING",
        Sailing: "SAILING",
        ScubaDiving: "SCUBA_DIVING",
        Skateboarding: "SKATEBOARDING",
        Skating: "SKATING",
        CrossSkating: "CROSS_SKATING",
        IndoorRollerblading: "INDOOR_ROLLERBLADING",
        Skiing: "SKIING",
        BackCountrySkiing: "BACK_COUNTRY_SKIING",
        CrossCountrySkiing: "CROSS_COUNTRY_SKIING",
        DownhillSkiing: "DOWNHILL_SKIING",
        KiteSkiing: "KITE_SKIING",
        RollerSkiing: "ROLLER_SKIING",
        Sledding: "SLEDDING",
        Snowboarding: "SNOWBOARDING",
        Snowmobile: "SNOWMOBILE",
        Snowshoeing: "SNOWSHOEING",
        Squash: "SQUASH",
        StairClimbing: "STAIR_CLIMBING",
        StairClimbingMachine: "STAIR_CLIMBING_MACHINE",
        StandUpPaddleboarding: "STAND_UP_PADDLEBOARDING",
        StrengthTraining: "STRENGTH_TRAINING",
        Surfing: "SURFING",
        Swimming: "SWIMMING",
        SwimmingSwimmingPool: "SWIMMING_SWIMMING_POOL",
        SwimmingOpenWater: "SWIMMING_OPEN_WATER",
        TableTennis: "TABLE_TENNIS",
        TeamSports: "TEAM_SPORTS",
        Tennis: "TENNIS",
        Treadmill: "TREADMILL",
        Volleyball: "VOLLEYBALL",
        VolleyballBeach: "VOLLEYBALL_BEACH",
        VolleyballIndoor: "VOLLEYBALL_INDOOR",
        Wakeboarding: "WAKEBOARDING",
        WalkingFitness: "WALKING_FITNESS",
        NordicWalking: "NORDIC_WALKING",
        WalkingTreadmill: "WALKING_TREADMILL",
        Waterpolo: "WATERPOLO",
        Weightlifting: "WEIGHTLIFTING",
        Wheelchair: "WHEELCHAIR",
        Windsurfing: "WINDSURFING",
        Yoga: "YOGA",
        Zumba: "ZUMBA",
        Diving: "DIVING",
        Ergometer: "ERGOMETER",
        IceSkating: "ICE_SKATING",
        IndoorSkating: "INDOOR_SKATING",
        Curling: "CURLING",
        Other: "OTHER",
        Crossfit: "CROSSFIT",
        Hiit: "HIIT",
        IntervalTraining: "INTERVAL_TRAINING",
        WalkingStroller: "WALKING_STROLLER",
        Elevator: "ELEVATOR",
        Escalator: "ESCALATOR",
        Archery: "ARCHERY",
        Softball: "SOFTBALL",
        GuidedBreathing: "GUIDED_BREATHING",
        CardioTraining: "CARDIO_TRAINING",
        Lacrosse: "LACROSSE",
        Stretching: "STRETCHING",
        Triathlon: "TRIATHLON",
        InlineSkating: "INLINE_SKATING",
        SkyDiving: "SKY_DIVING",
        Paddling: "PADDLING",
        Mountaineering: "MOUNTAINEERING",
        Fishing: "FISHING",
        WaterSkiing: "WATER_SKIING",
        IndoorRunning: "INDOOR_RUNNING",
    } as const;
}
</file>
          <file name="PlannedWorkoutRepeatStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PlannedWorkoutRepeatStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** List of steps to be repeated for this workout step - e.g. if a user wants to schedule 5 repetitions of 100m sprints plus 20s rest in between */
    steps?: Terra.PlannedWorkoutStep[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}
</file>
          <file name="PlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTargets[];
    /** Planned intensity for the workout step */
    intensity?: PlannedWorkoutStep.Intensity;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDurations[];
    /** Name of workout step */
    name?: string;
}

export namespace PlannedWorkoutStep {
    /**
     * Planned intensity for the workout step
     */
    export type Intensity = "REST" | "WARMUP" | "COOLDOWN" | "RECOVERY" | "INTERVAL" | "ACTIVE";
    export const Intensity = {
        Rest: "REST",
        Warmup: "WARMUP",
        Cooldown: "COOLDOWN",
        Recovery: "RECOVERY",
        Interval: "INTERVAL",
        Active: "ACTIVE",
    } as const;
}
</file>
          <file name="PlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PlannedWorkoutStepDuration {
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: PlannedWorkoutStepDuration.DurationType;
}

export namespace PlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="PlannedWorkoutStepDurations.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PlannedWorkoutStepDurations =
    | Terra.PlannedWorkoutStepDurations.PlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.TimePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.PowerAbovePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.PowerBelowPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.FixedRestPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.CaloriesPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.HrAbovePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.HrBelowPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.RepsPlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.DistancePlannedWorkoutStepDuration
    | Terra.PlannedWorkoutStepDurations.StepsPlannedWorkoutStepDuration;

export namespace PlannedWorkoutStepDurations {
    export interface PlannedWorkoutStepDuration extends Terra.PlannedWorkoutStepDuration {
        type: "PlannedWorkoutStepDuration";
    }

    export interface TimePlannedWorkoutStepDuration extends Terra.TimePlannedWorkoutStepDuration {
        type: "TimePlannedWorkoutStepDuration";
    }

    export interface PowerAbovePlannedWorkoutStepDuration extends Terra.PowerAbovePlannedWorkoutStepDuration {
        type: "PowerAbovePlannedWorkoutStepDuration";
    }

    export interface PowerBelowPlannedWorkoutStepDuration extends Terra.PowerBelowPlannedWorkoutStepDuration {
        type: "PowerBelowPlannedWorkoutStepDuration";
    }

    export interface FixedRestPlannedWorkoutStepDuration extends Terra.FixedRestPlannedWorkoutStepDuration {
        type: "FixedRestPlannedWorkoutStepDuration";
    }

    export interface CaloriesPlannedWorkoutStepDuration extends Terra.CaloriesPlannedWorkoutStepDuration {
        type: "CaloriesPlannedWorkoutStepDuration";
    }

    export interface HrAbovePlannedWorkoutStepDuration extends Terra.HrAbovePlannedWorkoutStepDuration {
        type: "HRAbovePlannedWorkoutStepDuration";
    }

    export interface HrBelowPlannedWorkoutStepDuration extends Terra.HrBelowPlannedWorkoutStepDuration {
        type: "HRBelowPlannedWorkoutStepDuration";
    }

    export interface RepsPlannedWorkoutStepDuration extends Terra.RepsPlannedWorkoutStepDuration {
        type: "RepsPlannedWorkoutStepDuration";
    }

    export interface DistancePlannedWorkoutStepDuration extends Terra.DistancePlannedWorkoutStepDuration {
        type: "DistancePlannedWorkoutStepDuration";
    }

    export interface StepsPlannedWorkoutStepDuration extends Terra.StepsPlannedWorkoutStepDuration {
        type: "StepsPlannedWorkoutStepDuration";
    }
}
</file>
          <file name="PlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: PlannedWorkoutStepTarget.TargetType;
}

export namespace PlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="PlannedWorkoutStepTargets.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PlannedWorkoutStepTargets =
    | Terra.PlannedWorkoutStepTargets.PlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.CadencePlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.HrPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.PowerPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.SpeedPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.PacePlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.TssPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.IfPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.RepetitionPlannedWorkoutStepTarget
    | Terra.PlannedWorkoutStepTargets.SwimStrokePlannedWorkoutStepTarget;

export namespace PlannedWorkoutStepTargets {
    export interface PlannedWorkoutStepTarget extends Terra.PlannedWorkoutStepTarget {
        type: "PlannedWorkoutStepTarget";
    }

    export interface CadencePlannedWorkoutStepTarget extends Terra.CadencePlannedWorkoutStepTarget {
        type: "CadencePlannedWorkoutStepTarget";
    }

    export interface HrPlannedWorkoutStepTarget extends Terra.HrPlannedWorkoutStepTarget {
        type: "HRPlannedWorkoutStepTarget";
    }

    export interface PowerPlannedWorkoutStepTarget extends Terra.PowerPlannedWorkoutStepTarget {
        type: "PowerPlannedWorkoutStepTarget";
    }

    export interface SpeedPlannedWorkoutStepTarget extends Terra.SpeedPlannedWorkoutStepTarget {
        type: "SpeedPlannedWorkoutStepTarget";
    }

    export interface PacePlannedWorkoutStepTarget extends Terra.PacePlannedWorkoutStepTarget {
        type: "PacePlannedWorkoutStepTarget";
    }

    export interface TssPlannedWorkoutStepTarget extends Terra.TssPlannedWorkoutStepTarget {
        type: "TSSPlannedWorkoutStepTarget";
    }

    export interface IfPlannedWorkoutStepTarget extends Terra.IfPlannedWorkoutStepTarget {
        type: "IFPlannedWorkoutStepTarget";
    }

    export interface RepetitionPlannedWorkoutStepTarget extends Terra.RepetitionPlannedWorkoutStepTarget {
        type: "RepetitionPlannedWorkoutStepTarget";
    }

    export interface SwimStrokePlannedWorkoutStepTarget extends Terra.SwimStrokePlannedWorkoutStepTarget {
        type: "SwimStrokePlannedWorkoutStepTarget";
    }
}
</file>
          <file name="PlannedWorkoutSteps.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type PlannedWorkoutSteps =
    | Terra.PlannedWorkoutSteps.PlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.PlannedWorkoutRepeatStep
    | Terra.PlannedWorkoutSteps.SwimmingPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.CardioPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.StrengthPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.YogaPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.PilatesPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.RunningPlannedWorkoutStep
    | Terra.PlannedWorkoutSteps.CyclingPlannedWorkoutStep;

export namespace PlannedWorkoutSteps {
    export interface PlannedWorkoutStep extends Terra.PlannedWorkoutStep {
        type: "PlannedWorkoutStep";
    }

    export interface PlannedWorkoutRepeatStep extends Terra.PlannedWorkoutRepeatStep {
        type: "PlannedWorkoutRepeatStep";
    }

    export interface SwimmingPlannedWorkoutStep extends Terra.SwimmingPlannedWorkoutStep {
        type: "SwimmingPlannedWorkoutStep";
    }

    export interface CardioPlannedWorkoutStep extends Terra.CardioPlannedWorkoutStep {
        type: "CardioPlannedWorkoutStep";
    }

    export interface StrengthPlannedWorkoutStep extends Terra.StrengthPlannedWorkoutStep {
        type: "StrengthPlannedWorkoutStep";
    }

    export interface YogaPlannedWorkoutStep extends Terra.YogaPlannedWorkoutStep {
        type: "YogaPlannedWorkoutStep";
    }

    export interface PilatesPlannedWorkoutStep extends Terra.PilatesPlannedWorkoutStep {
        type: "PilatesPlannedWorkoutStep";
    }

    export interface RunningPlannedWorkoutStep extends Terra.RunningPlannedWorkoutStep {
        type: "RunningPlannedWorkoutStep";
    }

    export interface CyclingPlannedWorkoutStep extends Terra.CyclingPlannedWorkoutStep {
        type: "CyclingPlannedWorkoutStep";
    }
}
</file>
          <file name="PolylineMapData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PolylineMapData {
    /** The polyline representation of the user's trajectory throughout the workout */
    summary_polyline?: string;
}
</file>
          <file name="PositionData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PositionData {
    /** Position of the user at the midway point of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable. */
    center_pos_lat_lng_deg?: number[];
    /** Position of the user at the end of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable. */
    end_pos_lat_lng_deg?: number[];
    /** Array of datapoints of the position of the user, sampled throughout the workout. */
    position_samples?: Terra.PositionSample[];
    /** Position of the user at the start of the workout, represented by a 2-value array of latitude, longitude, wherein each of the two numbers can be nullable. */
    start_pos_lat_lng_deg?: number[];
}
</file>
          <file name="PositionSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PositionSample {
    timestamp: string;
    coords_lat_lng_deg: number[];
    timer_duration_seconds: number;
}
</file>
          <file name="PowerAbovePlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerAbovePlannedWorkoutStepDuration {
    /** Threshold power goal to complete the workout step - once the user reaches above this power level, the step will be completed */
    power_above_watts?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: PowerAbovePlannedWorkoutStepDuration.DurationType;
}

export namespace PowerAbovePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="PowerBelowPlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerBelowPlannedWorkoutStepDuration {
    /** Threshold power goal to complete the workout step - once the user reaches below this power level, the step will be completed */
    power_below_watts?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: PowerBelowPlannedWorkoutStepDuration.DurationType;
}

export namespace PowerBelowPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="PowerData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface PowerData {
    /** Average power output of the user during the workout. */
    avg_watts?: number;
    /** Maximum power output of the user during the workout. */
    max_watts?: number;
    /** Array containing datapoints of the power output of the user sampled throughout the workout. */
    power_samples?: Terra.PowerSample[];
}
</file>
          <file name="PowerPlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: PowerPlannedWorkoutStepTarget.TargetType;
    /** Maximum percentage of Functional Threshold Power for the workout step - i.e. the user is to stay under this value during the workout step */
    power_percentage_low?: number;
    /** Minimum percentage of Functional Threshold Power for the workout step - i.e. the user is to stay above this value during the workout */
    power_percentage_high?: number;
    /** Maximum power threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    power_watt_high?: number;
    /** Minimum power threshold for the workout step - i.e. the user is to stay above this value during the workout */
    power_watt_low?: number;
    power_watt?: number;
    /** Ideal percentage of user's Functional Threshold Power to be maintained workout step */
    power_percentage?: number;
}

export namespace PowerPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="PowerSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PowerSample {
    timestamp: string;
    watts: number;
    timer_duration_seconds: number;
}
</file>
          <file name="ProcessingEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Processing event returned when data is being fetched asynchronously
 */
export interface ProcessingEvent {
    type: "processing";
    /** Status of the processing */
    status: "success";
    /** Information about the processing */
    message: string;
    /** User whose data is being processed */
    user: Terra.TerraUser;
    /** Seconds to wait before retrying */
    retry_after_seconds: number;
}
</file>
          <file name="PulseVelocitySample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PulseVelocitySample {
    timestamp: string;
    pulse_wave_velocity_meters_per_second: number;
}
</file>
          <file name="RateLimitHitEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Rate limit hit event
 */
export interface RateLimitHitEvent {
    type: "rate_limit_hit";
    /** User whose request hit rate limits */
    user: Terra.TerraUser;
    /** Start date of the requested data range */
    start_date: string;
    /** End date of the requested data range */
    end_date: string;
    /** When the request will be retried */
    retrying_at: string;
    /** Information about the rate limit */
    message: string;
}
</file>
          <file name="RateLimitHitWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type RateLimitHitWebhook = Terra.RateLimitHitEvent;
</file>
          <file name="RateLimitRequestProcessing.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RateLimitRequestProcessing {
    message?: string;
    type?: string;
    user: Terra.TerraUser;
}
</file>
          <file name="RawEcgSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RawEcgSample {
    potential_uV: number;
    timestamp: string;
}
</file>
          <file name="ReadinessData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface ReadinessData {
    /** User's readiness score for a given day, resulting from the sleep session. */
    readiness?: number;
    /** User's recovery score for a given day, resulting from the sleep session - takes Enum value. */
    recovery_level?: Terra.RecoveryLevel;
}
</file>
          <file name="RecoveryLevel.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * User's recovery score for a given day, resulting from the sleep session
 */
export type RecoveryLevel =
    /**
     * Recovery level could not be determined or is not available. */
    | 0
    /**
     * Extremely low recovery. */
    | 1
    /**
     * Low recovery level. */
    | 2
    /**
     * Below average recovery. */
    | 3
    /**
     * Moderate recovery level. */
    | 4
    /**
     * Above average recovery. */
    | 5
    /**
     * Excellent recovery level. */
    | 6;
export const RecoveryLevel = {
    Unknown: 0,
    VeryPoor: 1,
    Poor: 2,
    Compromised: 3,
    Ok: 4,
    Good: 5,
    VeryGood: 6,
} as const;
</file>
          <file name="RepetitionPlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RepetitionPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: RepetitionPlannedWorkoutStepTarget.TargetType;
    /** Number of repetitions of the workout step to be performed */
    repetitions?: number;
}

export namespace RepetitionPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="RepsPlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RepsPlannedWorkoutStepDuration {
    /** Target number of reps for the workout step - once the user completes this rep target, the step will be completed */
    reps?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: RepsPlannedWorkoutStepDuration.DurationType;
}

export namespace RepsPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="RequestProcessing.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RequestProcessing {
    /** Recommended time after which the request may be retried */
    retry_after_seconds?: number;
    message?: string;
    type?: string;
    /** Terra User object */
    user?: Terra.TerraUser;
}
</file>
          <file name="RespirationData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RespirationData {
    /** Object containing information on breathing rate for the sleep session. */
    breaths_data?: Terra.BreathsData;
    /** Object containing information on saturation metrics for the sleep session. */
    oxygen_saturation_data?: Terra.OxygenSaturationData;
    /** Object containing information on snoring metrics for the sleep session. */
    snoring_data?: Terra.SnoringData;
}
</file>
          <file name="RrIntervalSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RrIntervalSample {
    /** User's RR Interval for a specific heart beat in milliseconds. */
    rr_interval_ms?: number;
    /** Time with which the record is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp?: string;
    /** The heart beat value at that specific instance. */
    hr_bpm?: number;
}
</file>
          <file name="RunningPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface RunningPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}
</file>
          <file name="S3PayloadEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * S3 Upload event with data download URL
 */
export interface S3PayloadEvent {
    type: "s3_payload";
    /** Status of the upload */
    status: "success";
    /** URL to download the data */
    url: string;
    /** Time in seconds until URL expiration */
    expires_in: number;
}
</file>
          <file name="S3UploadWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type S3UploadWebhook = Terra.S3PayloadEvent;
</file>
          <file name="ScoresData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ScoresData {
    /** Activity score for the given day. */
    activity?: number;
    /** Recovery score for the given day. */
    recovery?: number;
    /** Sleep score for the given day, pertaining to the previous night's sleep. */
    sleep?: number;
}
</file>
          <file name="Sleep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface Sleep {
    /** Object containing additional enrichment data for the sleep session. */
    data_enrichment?: Terra.SleepDataEnrichment;
    /** Object containing information on the device which recorded data for the payload. */
    device_data?: Terra.DeviceData;
    /** Object containing information on the user's heart rate during the sleep session. */
    heart_rate_data?: Terra.HeartRateData;
    /** Object containing daily summary metadata. */
    metadata: Terra.SleepMetadata;
    /** Object containing information on the user's readiness for the day, based off the quality and duration of their sleep. */
    readiness_data?: Terra.ReadinessData;
    /** Object containing information on the user's respiration throughout the sleep session. */
    respiration_data?: Terra.RespirationData;
    /** User's sleep score */
    scores?: Sleep.Scores;
    /** Object containing information on the user's duration spent in various sleep stages. */
    sleep_durations_data?: Terra.SleepDurationsData;
    /** Object containing body temperature information of the user during the sleep recording session. */
    temperature_data?: Terra.SleepTemperatureData;
}

export namespace Sleep {
    /**
     * User's sleep score
     */
    export interface Scores {
        /** User's sleep score. */
        sleep_score?: number;
    }
}
</file>
          <file name="SleepDataEnrichment.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepDataEnrichment {
    sleep_contributors?: Terra.DataContributor[];
    sleep_score?: number;
}
</file>
          <file name="SleepDurationsData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepDurationsData {
    /** Object containing information on the duration the user spent asleep during the sleep recording session. */
    asleep?: Terra.AsleepDurations;
    /** Object containing information on the duration the user spent awake during the sleep recording session. */
    awake?: Terra.AwakeDurations;
    /** List of sleep stage (Hypnogram) samples recorded during the user's sleep session. */
    hypnogram_samples?: Terra.SleepHypnogramSample[];
    /** Object containing information on the miscellaneous duration data for the sleep recording session. */
    other?: Terra.OtherSleepDurations;
    /** Sleep efficiency of the user given as a percentage, measured as time spent asleep divided by time spent in bed. */
    sleep_efficiency?: number;
}
</file>
          <file name="SleepEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Sleep data event
 */
export interface SleepEvent {
    type: "sleep";
    /** Array of sleep data */
    data: Terra.Sleep[];
    /** User whose data is being provided */
    user: Terra.TerraUser;
    /** API version */
    version: string;
}
</file>
          <file name="SleepHypnogramSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepHypnogramSample {
    timestamp: string;
    level: Terra.SleepLevel;
}
</file>
          <file name="SleepLevel.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents the sleep level of the user during a sleep session, indicating the depth and quality of sleep
 */
export type SleepLevel =
    /**
     * Sleep level is unknown or could not be determined. */
    | 0
    /**
     * User is awake during the sleep session. */
    | 1
    /**
     * User is in a general sleep state. */
    | 2
    /**
     * User has left the bed during a sleep session. */
    | 3
    /**
     * User is in light sleep stage. */
    | 4
    /**
     * User is in deep sleep stage. */
    | 5
    /**
     * User is in REM sleep stage. */
    | 6;
export const SleepLevel = {
    Unknown: 0,
    Awake: 1,
    Sleeping: 2,
    OutOfBed: 3,
    LightSleep: 4,
    DeepSleep: 5,
    RemSleep: 6,
} as const;
</file>
          <file name="SleepMetadata.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SleepMetadata {
    /** The end time of the associated sleep session, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time: string;
    /** Flag indicating whether the sleep session was a nap, or the user's main sleep session for the day. */
    is_nap?: boolean;
    /** The start time of the associated sleep session, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time: string;
    /** A unique identifier for the sleep session. */
    summary_id?: string;
    timestamp_localization?: Terra.TimestampLocalization;
    /** The upload type for the associated sleep session, providing information on whether this was an automatic sleep or user-entered. */
    upload_type: Terra.SleepUploadType;
}
</file>
          <file name="SleepTemperatureData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SleepTemperatureData {
    /** Variation in user's skin temperature from their baseline. */
    delta?: number;
}
</file>
          <file name="SleepUploadType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * The upload type for the associated workout, providing information on whether this was an automatic workout or user-entered
 */
export type SleepUploadType =
    /**
     * The sleep data upload type is unknown or could not be determined. */
    | 0
    /**
     * The sleep data was manually entered by the user. */
    | 1
    /**
     * The sleep data was automatically detected and recorded by a device or service. */
    | 2
    /**
     * The sleep data is preliminary or tentative and may be subject to change. */
    | 3
    /**
     * The sleep data upload type cannot be clearly categorized. */
    | 4;
export const SleepUploadType = {
    Unknown: 0,
    Manual: 1,
    Automatic: 2,
    Tentative: 3,
    Indeterminate: 4,
} as const;
</file>
          <file name="SleepWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type SleepWebhook = Terra.SleepEvent;
</file>
          <file name="SnoringData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SnoringData {
    /** The start time of the recording of snoring data, in ISO8601 format with microsecond precision. Will always fall on midnight of any given day, and will always be equal to 24h before end_time. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    start_time?: string;
    /** The end time of the recording of snoring data, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    end_time?: string;
    /** Number of times over the sleep period when the user started snoring, as determined by the device. */
    num_snoring_events?: number;
    /** List of snoring information data points sampled throughout the sleep session. */
    samples?: Terra.SnoringSample[];
    /** Total duration for which the user was snoring. */
    total_snoring_duration_seconds?: number;
}
</file>
          <file name="SnoringSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SnoringSample {
    timestamp: string;
    duration_seconds: number;
}
</file>
          <file name="SpeedPlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SpeedPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: SpeedPlannedWorkoutStepTarget.TargetType;
    /** Maximum speed threshold for the workout step - i.e. the user is to stay under this value during the workout step */
    speed_percentage_high?: number;
    /** Minimum speed threshold for the workout step - i.e. the user is to stay above this value during the workout step */
    speed_percentage_low?: number;
    /** Ideal percentage of user's Threshold Speed, based off their Threshold Pace, to be maintained workout step. Usually, the Threshold Pace is defined as the pace one could race at for 50 to 60 minutes */
    speed_percentage?: number;
    /** Ideal speed value to be maintained for the workout step */
    speed_meters_per_second?: number;
}

export namespace SpeedPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="SpeedSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SpeedSample {
    timestamp: string;
    speed_meters_per_second: number;
    timer_duration_seconds: number;
}
</file>
          <file name="StepSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StepSample {
    timestamp: string;
    steps: number;
    timer_duration_seconds: number;
}
</file>
          <file name="StepsPlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StepsPlannedWorkoutStepDuration {
    /** Target number of steps for the workout step - once the user performs this number of steps, the step will be completed */
    steps?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: StepsPlannedWorkoutStepDuration.DurationType;
}

export namespace StepsPlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="StrainData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StrainData {
    /** Level of cardiovascular strain imposed on the user during the day. */
    strain_level?: number;
}
</file>
          <file name="StrengthPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface StrengthPlannedWorkoutStep {
    /** Weight to be lifted for the exercise */
    weight_kg?: number;
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Name of strength exercise to be performed for the workout step */
    exercice_name?: string;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Type of strength exercise to be performed for the workout step */
    exercice_category?: StrengthPlannedWorkoutStep.ExerciceCategory;
    /** Name of workout step */
    name?: string;
}

export namespace StrengthPlannedWorkoutStep {
    /**
     * Type of strength exercise to be performed for the workout step
     */
    export type ExerciceCategory =
        | "UNKNOWN"
        | "BENCH_PRESS"
        | "CALF_RAISE"
        | "CARDIO"
        | "CARRY"
        | "CHOP"
        | "CORE"
        | "CRUNCH"
        | "CURL"
        | "DEADLIFT"
        | "FLYE"
        | "HIP_RAISE"
        | "HIP_STABILITY"
        | "HIP_SWING"
        | "HYPEREXTENSION"
        | "LATERAL_RAISE"
        | "LEG_CURL"
        | "LEG_RAISE"
        | "LUNGE"
        | "OLYMPIC_LIFT"
        | "PLANK"
        | "PLYO"
        | "PULL_UP"
        | "PUSH_UP"
        | "ROW"
        | "SHOULDER_PRESS"
        | "SHOULDER_STABILITY"
        | "SHRUG"
        | "SIT_UP"
        | "SQUAT"
        | "TOTAL_BODY"
        | "TRICEPS_EXTENSION"
        | "WARM_UP"
        | "RUN"
        | "BIKE"
        | "CARDIO_SENSORS";
    export const ExerciceCategory = {
        Unknown: "UNKNOWN",
        BenchPress: "BENCH_PRESS",
        CalfRaise: "CALF_RAISE",
        Cardio: "CARDIO",
        Carry: "CARRY",
        Chop: "CHOP",
        Core: "CORE",
        Crunch: "CRUNCH",
        Curl: "CURL",
        Deadlift: "DEADLIFT",
        Flye: "FLYE",
        HipRaise: "HIP_RAISE",
        HipStability: "HIP_STABILITY",
        HipSwing: "HIP_SWING",
        Hyperextension: "HYPEREXTENSION",
        LateralRaise: "LATERAL_RAISE",
        LegCurl: "LEG_CURL",
        LegRaise: "LEG_RAISE",
        Lunge: "LUNGE",
        OlympicLift: "OLYMPIC_LIFT",
        Plank: "PLANK",
        Plyo: "PLYO",
        PullUp: "PULL_UP",
        PushUp: "PUSH_UP",
        Row: "ROW",
        ShoulderPress: "SHOULDER_PRESS",
        ShoulderStability: "SHOULDER_STABILITY",
        Shrug: "SHRUG",
        SitUp: "SIT_UP",
        Squat: "SQUAT",
        TotalBody: "TOTAL_BODY",
        TricepsExtension: "TRICEPS_EXTENSION",
        WarmUp: "WARM_UP",
        Run: "RUN",
        Bike: "BIKE",
        CardioSensors: "CARDIO_SENSORS",
    } as const;
}
</file>
          <file name="StressData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface StressData {
    /** Average stress level for the day. */
    avg_stress_level?: number;
    /** Total number of seconds spent in a stressed state while active during the day. */
    activity_stress_duration_seconds?: number;
    /** Total number of seconds spent in a state of low stress during the day. */
    low_stress_duration_seconds?: number;
    /** Maximum stress level recorded during the day. */
    max_stress_level?: number;
    /** Total number of seconds spent in a state of medium stress during the day. */
    medium_stress_duration_seconds?: number;
    /** Array of stress level data points sampled throughout the day. */
    samples?: Terra.StressSample[];
    /** Total number of seconds spent in a stressed state while at rest during the day. */
    rest_stress_duration_seconds?: number;
    /** Total number of seconds spent in a state of high stress during the day. */
    high_stress_duration_seconds?: number;
    /** Total number of seconds spent in a stressed state while at rest during the day. */
    stress_duration_seconds?: number;
    /** Stress rating for the day. */
    stress_rating?: Terra.StressLevel;
    /** Array of Body Battery data points sampled throughout the day. */
    body_battery_samples?: Terra.BodyBatterySample[];
}
</file>
          <file name="StressLevel.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Represents stress level ranges.
 */
export type StressLevel =
    /**
     * Stress level is unknown or could not be determined. */
    | 0
    /**
     * Very low stress level (range 1-25). */
    | 1
    /**
     * Low stress level (range 26-50). */
    | 2
    /**
     * Moderate stress level (range 51-75). */
    | 3
    /**
     * High stress level (range 76-100). */
    | 4;
export const StressLevel = {
    Unknown: 0,
    Rest: 1,
    Low: 2,
    Medium: 3,
    High: 4,
} as const;
</file>
          <file name="StressSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StressSample {
    timestamp: string;
    level: number;
}
</file>
          <file name="StrokeType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Stroke type used for the workout step (e.g. breaststroke)
 */
export type StrokeType =
    /**
     * Any swimming stroke style that doesn't fit the standard categories. */
    | "other"
    /**
     * Front crawl stroke where swimmers alternate arm movements with face in water. */
    | "freestyle"
    /**
     * Swimming stroke performed on the back with alternating arm movements. */
    | "backstroke"
    /**
     * Swimming stroke where arms move simultaneously in a heart-shaped pattern with a frog kick. */
    | "breaststroke"
    /**
     * Swimming stroke with simultaneous overhead arm movements and dolphin kick. */
    | "butterfly";
export const StrokeType = {
    Other: "other",
    Freestyle: "freestyle",
    Backstroke: "backstroke",
    Breaststroke: "breaststroke",
    Butterfly: "butterfly",
} as const;
</file>
          <file name="SwimStrokePlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SwimStrokePlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: SwimStrokePlannedWorkoutStepTarget.TargetType;
    /** Number of swim strokes to be performed during the workout step */
    swim_strokes?: number;
}

export namespace SwimStrokePlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="SwimmingData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SwimmingData {
    /** Total number of swimming laps performed during the day. */
    num_laps?: number;
    /** Total number of swimming strokes performed during the day. */
    num_strokes?: number;
    /** Pool length for associated with the day. */
    pool_length_meters?: number;
}
</file>
          <file name="SwimmingPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface SwimmingPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Workout equipment to be used during the workout step */
    equipement_type?: SwimmingPlannedWorkoutStep.EquipementType;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
    /** Stroke type used for the workout step (e.g. breaststroke) */
    stroke_type?: SwimmingPlannedWorkoutStep.StrokeType;
}

export namespace SwimmingPlannedWorkoutStep {
    /**
     * Workout equipment to be used during the workout step
     */
    export type EquipementType =
        | "NONE"
        | "SWIM_FINS"
        | "SWIM_KICKBOARD"
        | "SWIM_PADDLES"
        | "SWIM_PULL_BUOY"
        | "SWIM_SNORKEL";
    export const EquipementType = {
        None: "NONE",
        SwimFins: "SWIM_FINS",
        SwimKickboard: "SWIM_KICKBOARD",
        SwimPaddles: "SWIM_PADDLES",
        SwimPullBuoy: "SWIM_PULL_BUOY",
        SwimSnorkel: "SWIM_SNORKEL",
    } as const;
    /**
     * Stroke type used for the workout step (e.g. breaststroke)
     */
    export type StrokeType = "OTHER" | "FREESTYLE" | "BACKSTROKE" | "BREASTSTROKE" | "BUTTERFLY" | "REST";
    export const StrokeType = {
        Other: "OTHER",
        Freestyle: "FREESTYLE",
        Backstroke: "BACKSTROKE",
        Breaststroke: "BREASTSTROKE",
        Butterfly: "BUTTERFLY",
        Rest: "REST",
    } as const;
}
</file>
          <file name="TagData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface TagData {
    /** Array of user-entered tags for the day. */
    tags?: Terra.TagEntry[];
}
</file>
          <file name="TagEntry.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TagEntry {
    /** Time with which the tag is associated, in ISO8601 format with microsecond precision. TimeZone info will be provided whenever possible. If absent, the time corresponds to the user's local time. */
    timestamp: string;
    /** Tag name, representing a certain event associated with the user's day. */
    tag_name: string;
    /** User-input notes associated with the given tag. */
    notes: string;
}
</file>
          <file name="TemperatureData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface TemperatureData {
    /** List of ambient temperature measurements sampled throughout the day. */
    ambient_temperature_samples?: Terra.TemperatureSample[];
    /** List of body temperature measurements sampled throughout the day. */
    body_temperature_samples?: Terra.TemperatureSample[];
    /** List of skin temperature measurements sampled throughout the day. */
    skin_temperature_samples?: Terra.TemperatureSample[];
}
</file>
          <file name="TemperatureSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TemperatureSample {
    timestamp: string;
    temperature_celsius: number;
}
</file>
          <file name="TerraUser.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TerraUser {
    /** Terra identifier for the wearable connection */
    user_id: string;
    /** Connection data source */
    provider: string;
    /** Last time at which a webhook update was sent for the connection */
    last_webhook_update?: string;
    /** (when available) Permissions granted by the user during authentication - to be used as debugging metadata */
    scopes?: string;
    /** Connection identifier on the developer's end, used to tie connection back to a user on the developer's platform */
    reference_id?: string;
    /** whether the user is active or not (inactive users will not receive any data updates and are in considered */
    active?: boolean;
}
</file>
          <file name="TimePlannedWorkoutStepDuration.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TimePlannedWorkoutStepDuration {
    /** Time duration to be elapsed for the workout step */
    seconds?: number;
    /** Type of condition that must be fulfilled to consider the workout step complete */
    duration_type?: TimePlannedWorkoutStepDuration.DurationType;
}

export namespace TimePlannedWorkoutStepDuration {
    /**
     * Type of condition that must be fulfilled to consider the workout step complete
     */
    export type DurationType =
        | "TIME"
        | "DISTANCE_METERS"
        | "HR_LESS_THAN"
        | "HR_GREATER_THAN"
        | "CALORIES"
        | "OPEN"
        | "POWER_LESS_THAN"
        | "POWER_GREATER_THAN"
        | "REPETITION_TIME"
        | "REPS"
        | "FIXED_REST"
        | "TIME_AT_VALID_CDA"
        | "STEPS";
    export const DurationType = {
        Time: "TIME",
        DistanceMeters: "DISTANCE_METERS",
        HrLessThan: "HR_LESS_THAN",
        HrGreaterThan: "HR_GREATER_THAN",
        Calories: "CALORIES",
        Open: "OPEN",
        PowerLessThan: "POWER_LESS_THAN",
        PowerGreaterThan: "POWER_GREATER_THAN",
        RepetitionTime: "REPETITION_TIME",
        Reps: "REPS",
        FixedRest: "FIXED_REST",
        TimeAtValidCda: "TIME_AT_VALID_CDA",
        Steps: "STEPS",
    } as const;
}
</file>
          <file name="TimestampLocalization.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Indicates whether the timestamps in this payload are localized (LOCAL) or in UTC.
 */
export type TimestampLocalization = number;
</file>
          <file name="TorqueSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TorqueSample {
    timestamp: string;
    timer_duration_seconds: number;
    torque_newton_meters: number;
}
</file>
          <file name="TssData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface TssData {
    /** Array of TSS information sampled throughout the workout */
    TSS_samples?: Terra.TssSample[];
}
</file>
          <file name="TssPlannedWorkoutStepTarget.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TssPlannedWorkoutStepTarget {
    /** Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed */
    target_type?: TssPlannedWorkoutStepTarget.TargetType;
    /** Planned Training Stress Score to be achieved for the workout step */
    tss?: number;
}

export namespace TssPlannedWorkoutStepTarget {
    /**
     * Type of target for the workout - i.e. metric type for which a criterion must be met for the workout to be completed
     */
    export type TargetType =
        | "SPEED"
        | "HEART_RATE"
        | "OPEN"
        | "CADENCE"
        | "POWER"
        | "GRADE"
        | "RESISTANCE"
        | "POWER_LAP"
        | "SWIM_STROKE"
        | "SPEED_LAP"
        | "HEART_RATE_LAP"
        | "PACE"
        | "HEART_RATE_THRESHOLD_PERCENTAGE"
        | "HEART_RATE_MAX_PERCENTAGE"
        | "SPEED_PERCENTAGE"
        | "POWER_PERCENTAGE"
        | "REPETITION"
        | "TSS"
        | "IF";
    export const TargetType = {
        Speed: "SPEED",
        HeartRate: "HEART_RATE",
        Open: "OPEN",
        Cadence: "CADENCE",
        Power: "POWER",
        Grade: "GRADE",
        Resistance: "RESISTANCE",
        PowerLap: "POWER_LAP",
        SwimStroke: "SWIM_STROKE",
        SpeedLap: "SPEED_LAP",
        HeartRateLap: "HEART_RATE_LAP",
        Pace: "PACE",
        HeartRateThresholdPercentage: "HEART_RATE_THRESHOLD_PERCENTAGE",
        HeartRateMaxPercentage: "HEART_RATE_MAX_PERCENTAGE",
        SpeedPercentage: "SPEED_PERCENTAGE",
        PowerPercentage: "POWER_PERCENTAGE",
        Repetition: "REPETITION",
        Tss: "TSS",
        If: "IF",
    } as const;
}
</file>
          <file name="TssSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TssSample {
    planned: number;
    actual: number;
    method: string;
    intensity_factor_planned: number;
    intensity_factor_actual: number;
    normalized_power_watts: number;
}
</file>
          <file name="UnauthorizedErrorBody.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UnauthorizedErrorBody {
    /** a detailed message describing the error */
    message?: string;
    /** indicates that an error happened (value is error) */
    status?: UnauthorizedErrorBody.Status;
}

export namespace UnauthorizedErrorBody {
    /**
     * indicates that an error happened (value is error)
     */
    export type Status = "success" | "error";
    export const Status = {
        Success: "success",
        Error: "error",
    } as const;
}
</file>
          <file name="UploadType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * The type of upload for the associated workout, providing information on how the workout data was recorded or entered
 */
export type UploadType =
    /**
     * The upload type is unknown or could not be determined. */
    | 0
    /**
     * The workout was automatically detected and recorded by a device or service. */
    | 1
    /**
     * The workout was manually entered by the user. */
    | 2
    /**
     * The workout data represents an update to a previously recorded workout. */
    | 3
    /**
     * The workout was marked for deletion. */
    | 4
    /**
     * The workout upload is pending processing or confirmation. */
    | 5
    /**
     * The workout was uploaded or synced from a third-party service or application. */
    | 6;
export const UploadType = {
    Unknown: 0,
    Automatic: 1,
    Manual: 2,
    Update: 3,
    Delete: 4,
    Pending: 5,
    ThirdPartyUpload: 6,
} as const;
</file>
          <file name="User.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type User = Terra.TerraUser;
</file>
          <file name="UserAuthWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserAuthWebhook = Terra.AuthSuccessEvent;
</file>
          <file name="UserAuthWebhookError.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserAuthWebhookError = Terra.AuthErrorEvent;
</file>
          <file name="UserAuthWebhookPayload.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserAuthWebhookPayload = Terra.UserAuthWebhookPayload.Success | Terra.UserAuthWebhookPayload.Error_;

export namespace UserAuthWebhookPayload {
    export interface Success extends Terra.AuthSuccessEvent {
        status: "success";
    }

    export interface Error_ extends Terra.AuthErrorEvent {
        status: "error";
    }
}
</file>
          <file name="UserDeauthWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserDeauthWebhook = Terra.DeauthEvent;
</file>
          <file name="UserReauthEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * User re-authentication event
 */
export interface UserReauthEvent {
    type: "user_reauth";
    /** The new user record */
    new_user: Terra.TerraUser;
    /** The old user record that will be deleted */
    old_user: Terra.TerraUser;
    /** Status of the re-authentication */
    status: "warning";
    /** Information about the re-authentication */
    message: string;
}
</file>
          <file name="UserReauthWebhook.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type UserReauthWebhook = Terra.UserReauthEvent;
</file>
          <file name="Vo2MaxSample.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Vo2MaxSample {
    timestamp: string;
    vo2max_ml_per_min_per_kg: number;
}
</file>
          <file name="WebhookEvent.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Base webhook event structure that all events extend from
 */
export interface WebhookEvent {
    /** The type of event */
    type: string;
}
</file>
          <file name="WebhookEventType.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

/**
 * Union of all possible webhook event types
 */
export type WebhookEventType =
    | Terra.HealthcheckEvent
    | Terra.AuthSuccessEvent
    | Terra.AuthErrorEvent
    | Terra.DeauthEvent
    | Terra.UserReauthEvent
    | Terra.AccessRevokedEvent
    | Terra.ConnectionErrorEvent
    | Terra.GoogleNoDatasourceEvent
    | Terra.PermissionChangeEvent
    | Terra.ProcessingEvent
    | Terra.LargeRequestProcessingEvent
    | Terra.LargeRequestSendingEvent
    | Terra.RateLimitHitEvent
    | Terra.ActivityEvent
    | Terra.AthleteEvent
    | Terra.BodyEvent
    | Terra.DailyEvent
    | Terra.MenstruationEvent
    | Terra.NutritionEvent
    | Terra.SleepEvent
    | Terra.S3PayloadEvent;
</file>
          <file name="WebhookEvents.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export type WebhookEvents = Terra.WebhookEventType;
</file>
          <file name="WorkData.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface WorkData {
    /** Total work output of the user for the workout, in kilojoules. */
    work_kilojoules?: number;
}
</file>
          <file name="YogaPlannedWorkoutStep.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as Terra from "../index.js";

export interface YogaPlannedWorkoutStep {
    /** List of targets for the workout */
    targets?: Terra.PlannedWorkoutStepTarget[];
    /** Planned intensity for the workout step */
    intensity?: number;
    /** Position of the workout step in the overall workout */
    order?: number;
    /** Description of workout step */
    description?: string;
    /** List of conditions to be fulfilled for the workout step to be completed - all of the conditions must be completed */
    durations?: Terra.PlannedWorkoutStepDuration[];
    /** Name of workout step */
    name?: string;
}
</file>
          <file name="index.ts">export * from "./BadRequestErrorBody.js";
export * from "./NotFoundErrorBody.js";
export * from "./UnauthorizedErrorBody.js";
export * from "./UserAuthWebhookPayload.js";
export * from "./User.js";
export * from "./NoDataReturned.js";
export * from "./RequestProcessing.js";
export * from "./RateLimitRequestProcessing.js";
export * from "./DataSentToWebhook.js";
export * from "./Activity.js";
export * from "./Athlete.js";
export * from "./AthleteCollection.js";
export * from "./Body.js";
export * from "./Daily.js";
export * from "./Menstruation.js";
export * from "./Nutrition.js";
export * from "./Sleep.js";
export * from "./PlannedWorkoutStepTarget.js";
export * from "./CadencePlannedWorkoutStepTarget.js";
export * from "./HrPlannedWorkoutStepTarget.js";
export * from "./PowerPlannedWorkoutStepTarget.js";
export * from "./SpeedPlannedWorkoutStepTarget.js";
export * from "./PacePlannedWorkoutStepTarget.js";
export * from "./TssPlannedWorkoutStepTarget.js";
export * from "./IfPlannedWorkoutStepTarget.js";
export * from "./RepetitionPlannedWorkoutStepTarget.js";
export * from "./SwimStrokePlannedWorkoutStepTarget.js";
export * from "./PlannedWorkoutStepTargets.js";
export * from "./PlannedWorkoutStepDuration.js";
export * from "./TimePlannedWorkoutStepDuration.js";
export * from "./PowerAbovePlannedWorkoutStepDuration.js";
export * from "./PowerBelowPlannedWorkoutStepDuration.js";
export * from "./FixedRestPlannedWorkoutStepDuration.js";
export * from "./CaloriesPlannedWorkoutStepDuration.js";
export * from "./HrAbovePlannedWorkoutStepDuration.js";
export * from "./HrBelowPlannedWorkoutStepDuration.js";
export * from "./RepsPlannedWorkoutStepDuration.js";
export * from "./DistancePlannedWorkoutStepDuration.js";
export * from "./StepsPlannedWorkoutStepDuration.js";
export * from "./PlannedWorkoutStepDurations.js";
export * from "./PlannedWorkoutStep.js";
export * from "./PlannedWorkoutRepeatStep.js";
export * from "./SwimmingPlannedWorkoutStep.js";
export * from "./CardioPlannedWorkoutStep.js";
export * from "./StrengthPlannedWorkoutStep.js";
export * from "./YogaPlannedWorkoutStep.js";
export * from "./PilatesPlannedWorkoutStep.js";
export * from "./RunningPlannedWorkoutStep.js";
export * from "./CyclingPlannedWorkoutStep.js";
export * from "./PlannedWorkoutSteps.js";
export * from "./PlannedWorkoutMetadata.js";
export * from "./PlannedWorkout.js";
export * from "./DataProcessingWebhook.js";
export * from "./UserAuthWebhook.js";
export * from "./UserAuthWebhookError.js";
export * from "./PermissionChangeWebhook.js";
export * from "./UserReauthWebhook.js";
export * from "./UserDeauthWebhook.js";
export * from "./AccessRevokedWebhook.js";
export * from "./GoogleNoDataSourceWebhook.js";
export * from "./ConnectionErrorWebhook.js";
export * from "./LargeRequestSendingWebhook.js";
export * from "./LargeRequestProcessingResponse.js";
export * from "./AuthenticationFailedWebhook.js";
export * from "./HealthCheckWebhook.js";
export * from "./RateLimitHitWebhook.js";
export * from "./S3UploadWebhook.js";
export * from "./ActivityWebhook.js";
export * from "./DailyWebhook.js";
export * from "./NutritionWebhook.js";
export * from "./AthleteWebhook.js";
export * from "./SleepWebhook.js";
export * from "./MenstruationWebhook.js";
export * from "./BodyWebhook.js";
export * from "./IntegrationsResponse.js";
export * from "./IntegrationProvider.js";
export * from "./WebhookEvents.js";
export * from "./TerraUser.js";
export * from "./ActivityLevel.js";
export * from "./ActivityLevelSample.js";
export * from "./ActiveDurationsData.js";
export * from "./CalorieSample.js";
export * from "./CaloriesData.js";
export * from "./DataEnrichment.js";
export * from "./DeviceDataType.js";
export * from "./OtherDeviceData.js";
export * from "./DeviceData.js";
export * from "./DistanceSample.js";
export * from "./ElevationSample.js";
export * from "./FloorsClimbedSample.js";
export * from "./StepSample.js";
export * from "./DistanceDataDetailed.js";
export * from "./ElevationData.js";
export * from "./SwimmingData.js";
export * from "./DistanceDataSummary.js";
export * from "./DistanceData.js";
export * from "./EnergyData.js";
export * from "./HeartRateContext.js";
export * from "./HeartRateDataSample.js";
export * from "./HeartRateVariabilityDataSampleRmssd.js";
export * from "./HeartRateVariabilityDataSampleSdnn.js";
export * from "./HeartRateDataDetailed.js";
export * from "./HeartRateZone.js";
export * from "./HeartRateZoneData.js";
export * from "./HeartRateDataSummary.js";
export * from "./HeartRateData.js";
export * from "./StrokeType.js";
export * from "./LapSample.js";
export * from "./LapData.js";
export * from "./MetSample.js";
export * from "./MetData.js";
export * from "./TimestampLocalization.js";
export * from "./ActivityType.js";
export * from "./UploadType.js";
export * from "./ActivityMetadata.js";
export * from "./CadenceSample.js";
export * from "./SpeedSample.js";
export * from "./TorqueSample.js";
export * from "./MovementData.js";
export * from "./OxygenSaturationSample.js";
export * from "./Vo2MaxSample.js";
export * from "./OxygenData.js";
export * from "./PolylineMapData.js";
export * from "./PositionSample.js";
export * from "./PositionData.js";
export * from "./PowerSample.js";
export * from "./PowerData.js";
export * from "./StrainData.js";
export * from "./TssSample.js";
export * from "./TssData.js";
export * from "./WorkData.js";
export * from "./WebhookEvent.js";
export * from "./LargeRequestProcessingEvent.js";
export * from "./BloodPressureSample.js";
export * from "./BloodPressureData.js";
export * from "./AFibFlag.js";
export * from "./AFibClassificationSample.js";
export * from "./RawEcgSample.js";
export * from "./EcgReading.js";
export * from "./PulseVelocitySample.js";
export * from "./RrIntervalSample.js";
export * from "./HeartData.js";
export * from "./HydrationMeasurementSample.js";
export * from "./HydrationData.js";
export * from "./KetoneSampleType.js";
export * from "./KetoneSample.js";
export * from "./KetoneData.js";
export * from "./MeasurementDataSample.js";
export * from "./MeasurementsData.js";
export * from "./BodyMetadata.js";
export * from "./TemperatureSample.js";
export * from "./TemperatureData.js";
export * from "./GlucoseDataSample.js";
export * from "./DailyPatternSample.js";
export * from "./GlucoseData.js";
export * from "./DataContributor.js";
export * from "./DailyDataEnrichment.js";
export * from "./DailyDistanceData.js";
export * from "./DailyMetadata.js";
export * from "./ScoresData.js";
export * from "./StressSample.js";
export * from "./StressLevel.js";
export * from "./BodyBatterySample.js";
export * from "./StressData.js";
export * from "./TagEntry.js";
export * from "./TagData.js";
export * from "./MenstruationMetadata.js";
export * from "./MenstrualPhase.js";
export * from "./MenstruationFlow.js";
export * from "./MenstruationFlowSample.js";
export * from "./MenstruationData.js";
export * from "./DrinkSample.js";
export * from "./NutritionMicros.js";
export * from "./MealType.js";
export * from "./NutritionUnits.js";
export * from "./NutritionQuantity.js";
export * from "./NutritionMacros.js";
export * from "./Meal.js";
export * from "./NutritionMetadata.js";
export * from "./NutritionSummary.js";
export * from "./SleepDataEnrichment.js";
export * from "./SleepUploadType.js";
export * from "./SleepMetadata.js";
export * from "./RecoveryLevel.js";
export * from "./ReadinessData.js";
export * from "./BreathSample.js";
export * from "./BreathsData.js";
export * from "./OxygenSaturationData.js";
export * from "./SnoringSample.js";
export * from "./SnoringData.js";
export * from "./RespirationData.js";
export * from "./AsleepDurations.js";
export * from "./AwakeDurations.js";
export * from "./SleepLevel.js";
export * from "./SleepHypnogramSample.js";
export * from "./OtherSleepDurations.js";
export * from "./SleepDurationsData.js";
export * from "./SleepTemperatureData.js";
export * from "./HealthcheckEvent.js";
export * from "./AuthEvent.js";
export * from "./AuthSuccessEvent.js";
export * from "./AuthErrorEvent.js";
export * from "./DeauthEvent.js";
export * from "./UserReauthEvent.js";
export * from "./AccessRevokedEvent.js";
export * from "./ConnectionErrorEvent.js";
export * from "./GoogleNoDatasourceEvent.js";
export * from "./ProcessingEvent.js";
export * from "./LargeRequestSendingEvent.js";
export * from "./RateLimitHitEvent.js";
export * from "./S3PayloadEvent.js";
export * from "./ActivityEvent.js";
export * from "./AthleteEvent.js";
export * from "./NutritionEvent.js";
export * from "./DailyEvent.js";
export * from "./SleepEvent.js";
export * from "./MenstruationEvent.js";
export * from "./BodyEvent.js";
export * from "./PermissionChangeEvent.js";
export * from "./WebhookEventType.js";
</file>
        </directory>
      </directory>
      <directory name="core">
        <file name="headers.ts">import * as core from "./index.js";

export function mergeHeaders(
    ...headersArray: (Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt; | undefined)[]
): Record&lt;string, string | core.Supplier&lt;string | undefined&gt;&gt; {
    const result: Record&lt;string, string | core.Supplier&lt;string | undefined&gt;&gt; = {};

    for (const [key, value] of headersArray
        .filter((headers) =&gt; headers != null)
        .flatMap((headers) =&gt; Object.entries(headers))) {
        if (value != null) {
            result[key] = value;
        } else if (key in result) {
            delete result[key];
        }
    }

    return result;
}

export function mergeOnlyDefinedHeaders(
    ...headersArray: (Record&lt;string, string | core.Supplier&lt;string | undefined&gt; | undefined&gt; | undefined)[]
): Record&lt;string, string | core.Supplier&lt;string | undefined&gt;&gt; {
    const result: Record&lt;string, string | core.Supplier&lt;string | undefined&gt;&gt; = {};

    for (const [key, value] of headersArray
        .filter((headers) =&gt; headers != null)
        .flatMap((headers) =&gt; Object.entries(headers))) {
        if (value != null) {
            result[key] = value;
        }
    }

    return result;
}
</file>
        <file name="index.ts">export * from "./fetcher/index.js";
export * from "./runtime/index.js";
</file>
        <file name="json.ts">/**
 * Serialize a value to JSON
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @returns JSON string
 */
export const toJson = (
    value: unknown,
    replacer?: (this: unknown, key: string, value: unknown) =&gt; unknown,
    space?: string | number,
): string =&gt; {
    return JSON.stringify(value, replacer, space);
};

/**
 * Parse JSON string to object, array, or other type
 * @param text A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
 * @returns Parsed object, array, or other type
 */
export function fromJson&lt;T = unknown&gt;(
    text: string,
    reviver?: (this: unknown, key: string, value: unknown) =&gt; unknown,
): T {
    return JSON.parse(text, reviver);
}
</file>
        <directory name="crypto">
          <file name="createHmacOverride.ts">export async function createHmacOverride(payload: string, key: string): Promise&lt;string&gt; {
    try {
        const crypto = require('crypto');
        const hmac = crypto.createHmac('sha256', key);
        hmac.update(payload, 'utf8');
        return hmac.digest('base64');
    }
    catch (err) {
        // Not in Node environmnet; use subtle crypto.
    }
    const subtleCrypto = getSubtleCrypto();
    if (!subtleCrypto) {
        throw new Error('No crypto implementation available');
    }
    const encoder = new TextEncoder();
    const cryptoKey = await subtleCrypto.importKey(
        'raw',
        encoder.encode(key),
        {
            name: 'HMAC',
            hash: { name: 'SHA-256' }
        },
        false,
        ['sign']
    );
    const signatureBuffer = await subtleCrypto.sign(
        'HMAC',
        cryptoKey,
        encoder.encode(payload)
    );
    return arrayBufferToBase64(signatureBuffer);
}

function getSubtleCrypto(): SubtleCrypto | undefined {
    if (typeof window !== 'undefined' &amp;&amp; window?.crypto?.subtle) {
        return window.crypto.subtle;
    }
    return undefined;
}

function arrayBufferToBase64(buffer: ArrayBuffer): string {
    if (typeof btoa === 'function') {
        // Browser environment
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i &lt; bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    } else {
        // Node environment
        return Buffer.from(buffer).toString('base64');
    }
}</file>
          <file name="index.ts">export { createHmacOverride } from "./createHmacOverride";</file>
        </directory>
        <directory name="fetcher">
          <file name="APIResponse.ts">import { RawResponse } from "./RawResponse.js";

/**
 * The response of an API call.
 * It is a successful response or a failed response.
 */
export type APIResponse&lt;Success, Failure&gt; = SuccessfulResponse&lt;Success&gt; | FailedResponse&lt;Failure&gt;;

export interface SuccessfulResponse&lt;T&gt; {
    ok: true;
    body: T;
    /**
     * @deprecated Use `rawResponse` instead
     */
    headers?: Record&lt;string, any&gt;;
    rawResponse: RawResponse;
}

export interface FailedResponse&lt;T&gt; {
    ok: false;
    error: T;
    rawResponse: RawResponse;
}
</file>
          <file name="Fetcher.ts">import { toJson } from "../json.js";
import { APIResponse } from "./APIResponse.js";
import { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
import { Supplier } from "./Supplier.js";
import { createRequestUrl } from "./createRequestUrl.js";
import { getFetchFn } from "./getFetchFn.js";
import { getRequestBody } from "./getRequestBody.js";
import { getResponseBody } from "./getResponseBody.js";
import { makeRequest } from "./makeRequest.js";
import { requestWithRetries } from "./requestWithRetries.js";

export type FetchFunction = &lt;R = unknown&gt;(args: Fetcher.Args) =&gt; Promise&lt;APIResponse&lt;R, Fetcher.Error&gt;&gt;;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        contentType?: string;
        headers?: Record&lt;string, string | Supplier&lt;string | undefined&gt; | undefined&gt;;
        queryParameters?: Record&lt;string, string | string[] | object | object[] | null&gt;;
        body?: unknown;
        timeoutMs?: number;
        maxRetries?: number;
        withCredentials?: boolean;
        abortSignal?: AbortSignal;
        requestType?: "json" | "file" | "bytes";
        responseType?: "json" | "blob" | "sse" | "streaming" | "text" | "arrayBuffer";
        duplex?: "half";
    }

    export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: "status-code";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: "non-json";
        statusCode: number;
        rawBody: string;
    }

    export interface TimeoutError {
        reason: "timeout";
    }

    export interface UnknownError {
        reason: "unknown";
        errorMessage: string;
    }
}

async function getHeaders(args: Fetcher.Args): Promise&lt;Record&lt;string, string&gt;&gt; {
    const newHeaders: Record&lt;string, string&gt; = {};
    if (args.body !== undefined &amp;&amp; args.contentType != null) {
        newHeaders["Content-Type"] = args.contentType;
    }

    if (args.headers == null) {
        return newHeaders;
    }

    for (const [key, value] of Object.entries(args.headers)) {
        const result = await Supplier.get(value);
        if (typeof result === "string") {
            newHeaders[key] = result;
            continue;
        }
        if (result == null) {
            continue;
        }
        newHeaders[key] = `${result}`;
    }
    return newHeaders;
}

export async function fetcherImpl&lt;R = unknown&gt;(args: Fetcher.Args): Promise&lt;APIResponse&lt;R, Fetcher.Error&gt;&gt; {
    const url = createRequestUrl(args.url, args.queryParameters);
    const requestBody: BodyInit | undefined = await getRequestBody({
        body: args.body,
        type: args.requestType === "json" ? "json" : "other",
    });
    const fetchFn = await getFetchFn();

    try {
        const response = await requestWithRetries(
            async () =&gt;
                makeRequest(
                    fetchFn,
                    url,
                    args.method,
                    await getHeaders(args),
                    requestBody,
                    args.timeoutMs,
                    args.abortSignal,
                    args.withCredentials,
                    args.duplex,
                ),
            args.maxRetries,
        );
        const responseBody = await getResponseBody(response, args.responseType);

        if (response.status &gt;= 200 &amp;&amp; response.status &lt; 400) {
            return {
                ok: true,
                body: responseBody as R,
                headers: response.headers,
                rawResponse: toRawResponse(response),
            };
        } else {
            return {
                ok: false,
                error: {
                    reason: "status-code",
                    statusCode: response.status,
                    body: responseBody,
                },
                rawResponse: toRawResponse(response),
            };
        }
    } catch (error) {
        if (args.abortSignal != null &amp;&amp; args.abortSignal.aborted) {
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: "The user aborted a request",
                },
                rawResponse: abortRawResponse,
            };
        } else if (error instanceof Error &amp;&amp; error.name === "AbortError") {
            return {
                ok: false,
                error: {
                    reason: "timeout",
                },
                rawResponse: abortRawResponse,
            };
        } else if (error instanceof Error) {
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: error.message,
                },
                rawResponse: unknownRawResponse,
            };
        }

        return {
            ok: false,
            error: {
                reason: "unknown",
                errorMessage: toJson(error),
            },
            rawResponse: unknownRawResponse,
        };
    }
}

export const fetcher: FetchFunction = fetcherImpl;
</file>
          <file name="Headers.ts">let Headers: typeof globalThis.Headers;

if (typeof globalThis.Headers !== "undefined") {
    Headers = globalThis.Headers;
} else {
    Headers = class Headers implements Headers {
        private headers: Map&lt;string, string[]&gt;;

        constructor(init?: HeadersInit) {
            this.headers = new Map();

            if (init) {
                if (init instanceof Headers) {
                    init.forEach((value, key) =&gt; this.append(key, value));
                } else if (Array.isArray(init)) {
                    for (const [key, value] of init) {
                        if (typeof key === "string" &amp;&amp; typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Each header entry must be a [string, string] tuple");
                        }
                    }
                } else {
                    for (const [key, value] of Object.entries(init)) {
                        if (typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Header values must be strings");
                        }
                    }
                }
            }
        }

        append(name: string, value: string): void {
            const key = name.toLowerCase();
            const existing = this.headers.get(key) || [];
            this.headers.set(key, [...existing, value]);
        }

        delete(name: string): void {
            const key = name.toLowerCase();
            this.headers.delete(key);
        }

        get(name: string): string | null {
            const key = name.toLowerCase();
            const values = this.headers.get(key);
            return values ? values.join(", ") : null;
        }

        has(name: string): boolean {
            const key = name.toLowerCase();
            return this.headers.has(key);
        }

        set(name: string, value: string): void {
            const key = name.toLowerCase();
            this.headers.set(key, [value]);
        }

        forEach(callbackfn: (value: string, key: string, parent: Headers) =&gt; void, thisArg?: unknown): void {
            const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
            this.headers.forEach((values, key) =&gt; boundCallback(values.join(", "), key, this));
        }

        getSetCookie(): string[] {
            return this.headers.get("set-cookie") || [];
        }

        *entries(): HeadersIterator&lt;[string, string]&gt; {
            for (const [key, values] of this.headers.entries()) {
                yield [key, values.join(", ")];
            }
        }

        *keys(): HeadersIterator&lt;string&gt; {
            yield* this.headers.keys();
        }

        *values(): HeadersIterator&lt;string&gt; {
            for (const values of this.headers.values()) {
                yield values.join(", ");
            }
        }

        [Symbol.iterator](): HeadersIterator&lt;[string, string]&gt; {
            return this.entries();
        }
    };
}

export { Headers };
</file>
          <file name="HttpResponsePromise.ts">import { WithRawResponse } from "./RawResponse.js";

/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */
export class HttpResponsePromise&lt;T&gt; extends Promise&lt;T&gt; {
    private innerPromise: Promise&lt;WithRawResponse&lt;T&gt;&gt;;
    private unwrappedPromise: Promise&lt;T&gt; | undefined;

    private constructor(promise: Promise&lt;WithRawResponse&lt;T&gt;&gt;) {
        // Initialize with a no-op to avoid premature parsing
        super((resolve) =&gt; {
            resolve(undefined as unknown as T);
        });
        this.innerPromise = promise;
    }

    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromFunction&lt;F extends (...args: never[]) =&gt; Promise&lt;WithRawResponse&lt;T&gt;&gt;, T&gt;(
        fn: F,
        ...args: Parameters&lt;F&gt;
    ): HttpResponsePromise&lt;T&gt; {
        return new HttpResponsePromise&lt;T&gt;(fn(...args));
    }

    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */
    public static interceptFunction&lt;
        F extends (...args: never[]) =&gt; Promise&lt;WithRawResponse&lt;T&gt;&gt;,
        T = Awaited&lt;ReturnType&lt;F&gt;&gt;["data"],
    &gt;(fn: F): (...args: Parameters&lt;F&gt;) =&gt; HttpResponsePromise&lt;T&gt; {
        return (...args: Parameters&lt;F&gt;): HttpResponsePromise&lt;T&gt; =&gt; {
            return HttpResponsePromise.fromPromise&lt;T&gt;(fn(...args));
        };
    }

    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromPromise&lt;T&gt;(promise: Promise&lt;WithRawResponse&lt;T&gt;&gt;): HttpResponsePromise&lt;T&gt; {
        return new HttpResponsePromise&lt;T&gt;(promise);
    }

    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromExecutor&lt;T&gt;(
        executor: (resolve: (value: WithRawResponse&lt;T&gt;) =&gt; void, reject: (reason?: unknown) =&gt; void) =&gt; void,
    ): HttpResponsePromise&lt;T&gt; {
        const promise = new Promise&lt;WithRawResponse&lt;T&gt;&gt;(executor);
        return new HttpResponsePromise&lt;T&gt;(promise);
    }

    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromResult&lt;T&gt;(result: WithRawResponse&lt;T&gt;): HttpResponsePromise&lt;T&gt; {
        const promise = Promise.resolve(result);
        return new HttpResponsePromise&lt;T&gt;(promise);
    }

    private unwrap(): Promise&lt;T&gt; {
        if (!this.unwrappedPromise) {
            this.unwrappedPromise = this.innerPromise.then(({ data }) =&gt; data);
        }
        return this.unwrappedPromise;
    }

    /** @inheritdoc */
    public override then&lt;TResult1 = T, TResult2 = never&gt;(
        onfulfilled?: ((value: T) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) | null,
        onrejected?: ((reason: unknown) =&gt; TResult2 | PromiseLike&lt;TResult2&gt;) | null,
    ): Promise&lt;TResult1 | TResult2&gt; {
        return this.unwrap().then(onfulfilled, onrejected);
    }

    /** @inheritdoc */
    public override catch&lt;TResult = never&gt;(
        onrejected?: ((reason: unknown) =&gt; TResult | PromiseLike&lt;TResult&gt;) | null,
    ): Promise&lt;T | TResult&gt; {
        return this.unwrap().catch(onrejected);
    }

    /** @inheritdoc */
    public override finally(onfinally?: (() =&gt; void) | null): Promise&lt;T&gt; {
        return this.unwrap().finally(onfinally);
    }

    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */
    public async withRawResponse(): Promise&lt;WithRawResponse&lt;T&gt;&gt; {
        return await this.innerPromise;
    }
}
</file>
          <file name="RawResponse.ts">import { Headers } from "./Headers.js";

/**
 * The raw response from the fetch call excluding the body.
 */
export type RawResponse = Omit&lt;
    {
        [K in keyof Response as Response[K] extends Function ? never : K]: Response[K]; // strips out functions
    },
    "ok" | "body" | "bodyUsed"
&gt;; // strips out body and bodyUsed

/**
 * A raw response indicating that the request was aborted.
 */
export const abortRawResponse: RawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 499,
    statusText: "Client Closed Request",
    type: "error",
    url: "",
} as const;

/**
 * A raw response indicating an unknown error.
 */
export const unknownRawResponse: RawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 0,
    statusText: "Unknown Error",
    type: "error",
    url: "",
} as const;

/**
 * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
 * excluding the `body` and `bodyUsed` fields.
 *
 * @param response - The `RawResponse` object to convert.
 * @returns A `RawResponse` object containing the extracted properties of the input response.
 */
export function toRawResponse(response: Response): RawResponse {
    return {
        headers: response.headers,
        redirected: response.redirected,
        status: response.status,
        statusText: response.statusText,
        type: response.type,
        url: response.url,
    };
}

/**
 * Creates a `RawResponse` from a standard `Response` object.
 */
export interface WithRawResponse&lt;T&gt; {
    readonly data: T;
    readonly rawResponse: RawResponse;
}
</file>
          <file name="Supplier.ts">export type Supplier&lt;T&gt; = T | Promise&lt;T&gt; | (() =&gt; T | Promise&lt;T&gt;);

export const Supplier = {
    get: async &lt;T&gt;(supplier: Supplier&lt;T&gt;): Promise&lt;T&gt; =&gt; {
        if (typeof supplier === "function") {
            return (supplier as () =&gt; T)();
        } else {
            return supplier;
        }
    },
};
</file>
          <file name="createRequestUrl.ts">import qs from "qs";

export function createRequestUrl(
    baseUrl: string,
    queryParameters?: Record&lt;string, string | string[] | object | object[] | null&gt;,
): string {
    return Object.keys(queryParameters ?? {}).length &gt; 0
        ? `${baseUrl}?${qs.stringify(queryParameters, { arrayFormat: "repeat" })}`
        : baseUrl;
}
</file>
          <file name="getFetchFn.ts">import { RUNTIME } from "../runtime/index.js";

/**
 * Returns a fetch function based on the runtime
 */
export async function getFetchFn(): Promise&lt;any&gt; {
    // In Node.js 18+ environments, use native fetch
    if (RUNTIME.type === "node" &amp;&amp; RUNTIME.parsedVersion != null &amp;&amp; RUNTIME.parsedVersion &gt;= 18) {
        return fetch;
    }

    // In Node.js 18 or lower environments, the SDK always uses`node-fetch`.
    if (RUNTIME.type === "node") {
        return (await import("node-fetch")).default as any;
    }

    // Otherwise the SDK uses global fetch if available,
    // and falls back to node-fetch.
    if (typeof fetch == "function") {
        return fetch;
    }

    // Defaults to node `node-fetch` if global fetch isn't available
    return (await import("node-fetch")).default as any;
}
</file>
          <file name="getHeader.ts">export function getHeader(headers: Record&lt;string, any&gt;, header: string): string | undefined {
    for (const [headerKey, headerValue] of Object.entries(headers)) {
        if (headerKey.toLowerCase() === header.toLowerCase()) {
            return headerValue;
        }
    }
    return undefined;
}
</file>
          <file name="getRequestBody.ts">import { toJson } from "../json.js";

export declare namespace GetRequestBody {
    interface Args {
        body: unknown;
        type: "json" | "file" | "bytes" | "other";
    }
}

export async function getRequestBody({ body, type }: GetRequestBody.Args): Promise&lt;BodyInit | undefined&gt; {
    if (type.includes("json")) {
        return toJson(body);
    } else {
        return body as BodyInit;
    }
}
</file>
          <file name="getResponseBody.ts">import { chooseStreamWrapper } from "./stream-wrappers/chooseStreamWrapper.js";

export async function getResponseBody(response: Response, responseType?: string): Promise&lt;unknown&gt; {
    if (response.body != null &amp;&amp; responseType === "blob") {
        return await response.blob();
    } else if (response.body != null &amp;&amp; responseType === "arrayBuffer") {
        return await response.arrayBuffer();
    } else if (response.body != null &amp;&amp; responseType === "sse") {
        return response.body;
    } else if (response.body != null &amp;&amp; responseType === "streaming") {
        return chooseStreamWrapper(response.body);
    } else if (response.body != null &amp;&amp; responseType === "text") {
        return await response.text();
    } else {
        const text = await response.text();
        if (text.length &gt; 0) {
            try {
                let responseBody = JSON.parse(text);
                return responseBody;
            } catch (err) {
                return {
                    ok: false,
                    error: {
                        reason: "non-json",
                        statusCode: response.status,
                        rawBody: text,
                    },
                };
            }
        } else {
            return undefined;
        }
    }
}
</file>
          <file name="index.ts">export type { APIResponse } from "./APIResponse.js";
export { fetcher } from "./Fetcher.js";
export type { Fetcher, FetchFunction } from "./Fetcher.js";
export { getHeader } from "./getHeader.js";
export { Supplier } from "./Supplier.js";
export { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
export type { RawResponse, WithRawResponse } from "./RawResponse.js";
export { HttpResponsePromise } from "./HttpResponsePromise.js";
</file>
          <file name="makeRequest.ts">import { anySignal, getTimeoutSignal } from "./signals.js";

export const makeRequest = async (
    fetchFn: (url: string, init: RequestInit) =&gt; Promise&lt;Response&gt;,
    url: string,
    method: string,
    headers: Record&lt;string, string&gt;,
    requestBody: BodyInit | undefined,
    timeoutMs?: number,
    abortSignal?: AbortSignal,
    withCredentials?: boolean,
    duplex?: "half",
): Promise&lt;Response&gt; =&gt; {
    const signals: AbortSignal[] = [];

    // Add timeout signal
    let timeoutAbortId: NodeJS.Timeout | undefined = undefined;
    if (timeoutMs != null) {
        const { signal, abortId } = getTimeoutSignal(timeoutMs);
        timeoutAbortId = abortId;
        signals.push(signal);
    }

    // Add arbitrary signal
    if (abortSignal != null) {
        signals.push(abortSignal);
    }
    let newSignals = anySignal(signals);
    const response = await fetchFn(url, {
        method: method,
        headers,
        body: requestBody,
        signal: newSignals,
        credentials: withCredentials ? "include" : undefined,
        // @ts-ignore
        duplex,
    });

    if (timeoutAbortId != null) {
        clearTimeout(timeoutAbortId);
    }

    return response;
};
</file>
          <file name="requestWithRetries.ts">const INITIAL_RETRY_DELAY = 1000; // in milliseconds
const MAX_RETRY_DELAY = 60000; // in milliseconds
const DEFAULT_MAX_RETRIES = 2;
const JITTER_FACTOR = 0.2; // 20% random jitter

function addJitter(delay: number): number {
    // Generate a random value between -JITTER_FACTOR and +JITTER_FACTOR
    const jitterMultiplier = 1 + (Math.random() * 2 - 1) * JITTER_FACTOR;
    return delay * jitterMultiplier;
}

export async function requestWithRetries(
    requestFn: () =&gt; Promise&lt;Response&gt;,
    maxRetries: number = DEFAULT_MAX_RETRIES,
): Promise&lt;Response&gt; {
    let response: Response = await requestFn();

    for (let i = 0; i &lt; maxRetries; ++i) {
        if ([408, 429].includes(response.status) || response.status &gt;= 500) {
            // Calculate base delay using exponential backoff (in milliseconds)
            const baseDelay = Math.min(INITIAL_RETRY_DELAY * Math.pow(2, i), MAX_RETRY_DELAY);

            // Add jitter to the delay
            const delayWithJitter = addJitter(baseDelay);

            await new Promise((resolve) =&gt; setTimeout(resolve, delayWithJitter));
            response = await requestFn();
        } else {
            break;
        }
    }
    return response!;
}
</file>
          <file name="signals.ts">const TIMEOUT = "timeout";

export function getTimeoutSignal(timeoutMs: number): { signal: AbortSignal; abortId: NodeJS.Timeout } {
    const controller = new AbortController();
    const abortId = setTimeout(() =&gt; controller.abort(TIMEOUT), timeoutMs);
    return { signal: controller.signal, abortId };
}

/**
 * Returns an abort signal that is getting aborted when
 * at least one of the specified abort signals is aborted.
 *
 * Requires at least node.js 18.
 */
export function anySignal(...args: AbortSignal[] | [AbortSignal[]]): AbortSignal {
    // Allowing signals to be passed either as array
    // of signals or as multiple arguments.
    const signals = (args.length === 1 &amp;&amp; Array.isArray(args[0]) ? args[0] : args) as AbortSignal[];

    const controller = new AbortController();

    for (const signal of signals) {
        if (signal.aborted) {
            // Exiting early if one of the signals
            // is already aborted.
            controller.abort((signal as any)?.reason);
            break;
        }

        // Listening for signals and removing the listeners
        // when at least one symbol is aborted.
        signal.addEventListener("abort", () =&gt; controller.abort((signal as any)?.reason), {
            signal: controller.signal,
        });
    }

    return controller.signal;
}
</file>
          <directory name="stream-wrappers">
            <file name="Node18UniversalStreamWrapper.ts">import type { Writable } from "readable-stream";

import { EventCallback, StreamWrapper } from "./chooseStreamWrapper.js";

export class Node18UniversalStreamWrapper&lt;ReadFormat extends Uint8Array | Uint16Array | Uint32Array&gt;
    implements
        StreamWrapper&lt;Node18UniversalStreamWrapper&lt;ReadFormat&gt; | Writable | WritableStream&lt;ReadFormat&gt;, ReadFormat&gt;
{
    private readableStream: ReadableStream&lt;ReadFormat&gt;;
    private reader: ReadableStreamDefaultReader&lt;ReadFormat&gt;;
    private events: Record&lt;string, EventCallback[] | undefined&gt;;
    private paused: boolean;
    private resumeCallback: ((value?: unknown) =&gt; void) | null;
    private encoding: string | null;

    constructor(readableStream: ReadableStream&lt;ReadFormat&gt;) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: [],
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }

    public on(event: string, callback: EventCallback): void {
        this.events[event]?.push(callback);
    }

    public off(event: string, callback: EventCallback): void {
        this.events[event] = this.events[event]?.filter((cb) =&gt; cb !== callback);
    }

    public pipe(
        dest: Node18UniversalStreamWrapper&lt;ReadFormat&gt; | Writable | WritableStream&lt;ReadFormat&gt;,
    ): Node18UniversalStreamWrapper&lt;ReadFormat&gt; | Writable | WritableStream&lt;ReadFormat&gt; {
        this.on("data", async (chunk) =&gt; {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._write(chunk);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.write(chunk).then(() =&gt; writer.releaseLock());
            } else {
                dest.write(chunk);
            }
        });

        this.on("end", async () =&gt; {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._end();
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.close();
            } else {
                dest.end();
            }
        });

        this.on("error", async (error) =&gt; {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._error(error);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.abort(error);
            } else {
                dest.destroy(error);
            }
        });

        this._startReading();

        return dest;
    }

    public pipeTo(
        dest: Node18UniversalStreamWrapper&lt;ReadFormat&gt; | Writable | WritableStream&lt;ReadFormat&gt;,
    ): Node18UniversalStreamWrapper&lt;ReadFormat&gt; | Writable | WritableStream&lt;ReadFormat&gt; {
        return this.pipe(dest);
    }

    public unpipe(dest: Node18UniversalStreamWrapper&lt;ReadFormat&gt; | Writable | WritableStream&lt;ReadFormat&gt;): void {
        this.off("data", async (chunk) =&gt; {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._write(chunk);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.write(chunk).then(() =&gt; writer.releaseLock());
            } else {
                dest.write(chunk);
            }
        });

        this.off("end", async () =&gt; {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._end();
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.close();
            } else {
                dest.end();
            }
        });

        this.off("error", async (error) =&gt; {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._error(error);
            } else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.abort(error);
            } else {
                dest.destroy(error);
            }
        });
    }

    public destroy(error?: Error): void {
        this.reader
            .cancel(error)
            .then(() =&gt; {
                this._emit("close");
            })
            .catch((err) =&gt; {
                this._emit("error", err);
            });
    }

    public pause(): void {
        this.paused = true;
        this._emit("pause");
    }

    public resume(): void {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }

    public get isPaused(): boolean {
        return this.paused;
    }

    public async read(): Promise&lt;ReadFormat | undefined&gt; {
        if (this.paused) {
            await new Promise((resolve) =&gt; {
                this.resumeCallback = resolve;
            });
        }
        const { done, value } = await this.reader.read();

        if (done) {
            return undefined;
        }
        return value;
    }

    public setEncoding(encoding: string): void {
        this.encoding = encoding;
    }

    public async text(): Promise&lt;string&gt; {
        const chunks: ReadFormat[] = [];

        while (true) {
            const { done, value } = await this.reader.read();
            if (done) {
                break;
            }
            if (value) {
                chunks.push(value);
            }
        }

        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(await new Blob(chunks).arrayBuffer());
    }

    public async json&lt;T&gt;(): Promise&lt;T&gt; {
        const text = await this.text();
        return JSON.parse(text);
    }

    private _write(chunk: ReadFormat): void {
        this._emit("data", chunk);
    }

    private _end(): void {
        this._emit("end");
    }

    private _error(error: any): void {
        this._emit("error", error);
    }

    private _emit(event: string, data?: any): void {
        if (this.events[event]) {
            for (const callback of this.events[event] || []) {
                callback(data);
            }
        }
    }

    private async _startReading(): Promise&lt;void&gt; {
        try {
            this._emit("readable");
            while (true) {
                if (this.paused) {
                    await new Promise((resolve) =&gt; {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    this._emit("end");
                    this._emit("close");
                    break;
                }
                if (value) {
                    this._emit("data", value);
                }
            }
        } catch (error) {
            this._emit("error", error);
        }
    }

    [Symbol.asyncIterator](): AsyncIterableIterator&lt;ReadFormat&gt; {
        return {
            next: async () =&gt; {
                if (this.paused) {
                    await new Promise((resolve) =&gt; {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
</file>
            <file name="NodePre18StreamWrapper.ts">import type { Readable, Writable } from "readable-stream";

import { EventCallback, StreamWrapper } from "./chooseStreamWrapper.js";

export class NodePre18StreamWrapper implements StreamWrapper&lt;Writable, Buffer&gt; {
    private readableStream: Readable;
    private encoding: string | undefined;

    constructor(readableStream: Readable) {
        this.readableStream = readableStream;
    }

    public on(event: string, callback: EventCallback): void {
        this.readableStream.on(event, callback);
    }

    public off(event: string, callback: EventCallback): void {
        this.readableStream.off(event, callback);
    }

    public pipe(dest: Writable): Writable {
        this.readableStream.pipe(dest);
        return dest;
    }

    public pipeTo(dest: Writable): Writable {
        return this.pipe(dest);
    }

    public unpipe(dest?: Writable): void {
        if (dest) {
            this.readableStream.unpipe(dest);
        } else {
            this.readableStream.unpipe();
        }
    }

    public destroy(error?: Error): void {
        this.readableStream.destroy(error);
    }

    public pause(): void {
        this.readableStream.pause();
    }

    public resume(): void {
        this.readableStream.resume();
    }

    public get isPaused(): boolean {
        return this.readableStream.isPaused();
    }

    public async read(): Promise&lt;Buffer | undefined&gt; {
        return new Promise((resolve, reject) =&gt; {
            const chunk = this.readableStream.read();
            if (chunk) {
                resolve(chunk);
            } else {
                this.readableStream.once("readable", () =&gt; {
                    const chunk = this.readableStream.read();
                    resolve(chunk);
                });
                this.readableStream.once("error", reject);
            }
        });
    }

    public setEncoding(encoding?: string): void {
        this.readableStream.setEncoding(encoding as BufferEncoding);
        this.encoding = encoding;
    }

    public async text(): Promise&lt;string&gt; {
        const chunks: Uint8Array[] = [];
        const encoder = new TextEncoder();
        this.readableStream.setEncoding((this.encoding || "utf-8") as BufferEncoding);

        for await (const chunk of this.readableStream) {
            chunks.push(encoder.encode(chunk));
        }

        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(Buffer.concat(chunks));
    }

    public async json&lt;T&gt;(): Promise&lt;T&gt; {
        const text = await this.text();
        return JSON.parse(text);
    }

    public [Symbol.asyncIterator](): AsyncIterableIterator&lt;Buffer&gt; {
        const readableStream = this.readableStream;
        const iterator = readableStream[Symbol.asyncIterator]();

        // Create and return an async iterator that yields buffers
        return {
            async next(): Promise&lt;IteratorResult&lt;Buffer&gt;&gt; {
                const { value, done } = await iterator.next();
                return { value: value as Buffer, done };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
</file>
            <file name="UndiciStreamWrapper.ts">import { StreamWrapper } from "./chooseStreamWrapper.js";

type EventCallback = (data?: any) =&gt; void;

export class UndiciStreamWrapper&lt;ReadFormat extends Uint8Array | Uint16Array | Uint32Array&gt;
    implements StreamWrapper&lt;UndiciStreamWrapper&lt;ReadFormat&gt; | WritableStream&lt;ReadFormat&gt;, ReadFormat&gt;
{
    private readableStream: ReadableStream&lt;ReadFormat&gt;;
    private reader: ReadableStreamDefaultReader&lt;ReadFormat&gt;;
    private events: Record&lt;string, EventCallback[] | undefined&gt;;
    private paused: boolean;
    private resumeCallback: ((value?: unknown) =&gt; void) | null;
    private encoding: string | null;

    constructor(readableStream: ReadableStream&lt;ReadFormat&gt;) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: [],
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }

    public on(event: string, callback: EventCallback): void {
        this.events[event]?.push(callback);
    }

    public off(event: string, callback: EventCallback): void {
        this.events[event] = this.events[event]?.filter((cb) =&gt; cb !== callback);
    }

    public pipe(
        dest: UndiciStreamWrapper&lt;ReadFormat&gt; | WritableStream&lt;ReadFormat&gt;,
    ): UndiciStreamWrapper&lt;ReadFormat&gt; | WritableStream&lt;ReadFormat&gt; {
        this.on("data", (chunk) =&gt; {
            if (dest instanceof UndiciStreamWrapper) {
                dest._write(chunk);
            } else {
                const writer = dest.getWriter();
                writer.write(chunk).then(() =&gt; writer.releaseLock());
            }
        });

        this.on("end", () =&gt; {
            if (dest instanceof UndiciStreamWrapper) {
                dest._end();
            } else {
                const writer = dest.getWriter();
                writer.close();
            }
        });

        this.on("error", (error) =&gt; {
            if (dest instanceof UndiciStreamWrapper) {
                dest._error(error);
            } else {
                const writer = dest.getWriter();
                writer.abort(error);
            }
        });

        this._startReading();

        return dest;
    }

    public pipeTo(
        dest: UndiciStreamWrapper&lt;ReadFormat&gt; | WritableStream&lt;ReadFormat&gt;,
    ): UndiciStreamWrapper&lt;ReadFormat&gt; | WritableStream&lt;ReadFormat&gt; {
        return this.pipe(dest);
    }

    public unpipe(dest: UndiciStreamWrapper&lt;ReadFormat&gt; | WritableStream): void {
        this.off("data", (chunk) =&gt; {
            if (dest instanceof UndiciStreamWrapper) {
                dest._write(chunk);
            } else {
                const writer = dest.getWriter();
                writer.write(chunk).then(() =&gt; writer.releaseLock());
            }
        });

        this.off("end", () =&gt; {
            if (dest instanceof UndiciStreamWrapper) {
                dest._end();
            } else {
                const writer = dest.getWriter();
                writer.close();
            }
        });

        this.off("error", (error) =&gt; {
            if (dest instanceof UndiciStreamWrapper) {
                dest._error(error);
            } else {
                const writer = dest.getWriter();
                writer.abort(error);
            }
        });
    }

    public destroy(error?: Error): void {
        this.reader
            .cancel(error)
            .then(() =&gt; {
                this._emit("close");
            })
            .catch((err) =&gt; {
                this._emit("error", err);
            });
    }

    public pause(): void {
        this.paused = true;
        this._emit("pause");
    }

    public resume(): void {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }

    public get isPaused(): boolean {
        return this.paused;
    }

    public async read(): Promise&lt;ReadFormat | undefined&gt; {
        if (this.paused) {
            await new Promise((resolve) =&gt; {
                this.resumeCallback = resolve;
            });
        }
        const { done, value } = await this.reader.read();
        if (done) {
            return undefined;
        }
        return value;
    }

    public setEncoding(encoding: string): void {
        this.encoding = encoding;
    }

    public async text(): Promise&lt;string&gt; {
        const chunks: BlobPart[] = [];

        while (true) {
            const { done, value } = await this.reader.read();
            if (done) {
                break;
            }
            if (value) {
                chunks.push(value);
            }
        }

        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(await new Blob(chunks).arrayBuffer());
    }

    public async json&lt;T&gt;(): Promise&lt;T&gt; {
        const text = await this.text();
        return JSON.parse(text);
    }

    private _write(chunk: ReadFormat): void {
        this._emit("data", chunk);
    }

    private _end(): void {
        this._emit("end");
    }

    private _error(error: any): void {
        this._emit("error", error);
    }

    private _emit(event: string, data?: any): void {
        if (this.events[event]) {
            for (const callback of this.events[event] || []) {
                callback(data);
            }
        }
    }

    private async _startReading(): Promise&lt;void&gt; {
        try {
            this._emit("readable");
            while (true) {
                if (this.paused) {
                    await new Promise((resolve) =&gt; {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    this._emit("end");
                    this._emit("close");
                    break;
                }
                if (value) {
                    this._emit("data", value);
                }
            }
        } catch (error) {
            this._emit("error", error);
        }
    }

    [Symbol.asyncIterator](): AsyncIterableIterator&lt;ReadFormat&gt; {
        return {
            next: async () =&gt; {
                if (this.paused) {
                    await new Promise((resolve) =&gt; {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
</file>
            <file name="chooseStreamWrapper.ts">import type { Readable } from "readable-stream";

import { RUNTIME } from "../../runtime/index.js";

export type EventCallback = (data?: any) =&gt; void;

export interface StreamWrapper&lt;WritableStream, ReadFormat&gt; {
    setEncoding(encoding?: string): void;
    on(event: string, callback: EventCallback): void;
    off(event: string, callback: EventCallback): void;
    pipe(dest: WritableStream): WritableStream;
    pipeTo(dest: WritableStream): WritableStream;
    unpipe(dest?: WritableStream): void;
    destroy(error?: Error): void;
    pause(): void;
    resume(): void;
    get isPaused(): boolean;
    read(): Promise&lt;ReadFormat | undefined&gt;;
    text(): Promise&lt;string&gt;;
    json&lt;T&gt;(): Promise&lt;T&gt;;
    [Symbol.asyncIterator](): AsyncIterableIterator&lt;ReadFormat&gt;;
}

export async function chooseStreamWrapper(responseBody: any): Promise&lt;Promise&lt;StreamWrapper&lt;any, any&gt;&gt;&gt; {
    if (RUNTIME.type === "node" &amp;&amp; RUNTIME.parsedVersion != null &amp;&amp; RUNTIME.parsedVersion &gt;= 18) {
        return new (await import("./Node18UniversalStreamWrapper.js")).Node18UniversalStreamWrapper(
            responseBody as ReadableStream,
        );
    } else if (RUNTIME.type !== "node" &amp;&amp; typeof fetch === "function") {
        return new (await import("./UndiciStreamWrapper.js")).UndiciStreamWrapper(responseBody as ReadableStream);
    } else {
        return new (await import("./NodePre18StreamWrapper.js")).NodePre18StreamWrapper(responseBody as Readable);
    }
}
</file>
          </directory>
        </directory>
        <directory name="runtime">
          <file name="index.ts">export { RUNTIME } from "./runtime.js";
</file>
          <file name="runtime.ts">interface DenoGlobal {
    version: {
        deno: string;
    };
}

interface BunGlobal {
    version: string;
}

declare const Deno: DenoGlobal | undefined;
declare const Bun: BunGlobal | undefined;
declare const EdgeRuntime: string | undefined;

/**
 * A constant that indicates which environment and version the SDK is running in.
 */
export const RUNTIME: Runtime = evaluateRuntime();

export interface Runtime {
    type: "browser" | "web-worker" | "deno" | "bun" | "node" | "react-native" | "unknown" | "workerd" | "edge-runtime";
    version?: string;
    parsedVersion?: number;
}

function evaluateRuntime(): Runtime {
    /**
     * A constant that indicates whether the environment the code is running is a Web Browser.
     */
    const isBrowser = typeof window !== "undefined" &amp;&amp; typeof window.document !== "undefined";
    if (isBrowser) {
        return {
            type: "browser",
            version: window.navigator.userAgent,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Cloudflare.
     * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
     */
    const isCloudflare = typeof globalThis !== "undefined" &amp;&amp; globalThis?.navigator?.userAgent === "Cloudflare-Workers";
    if (isCloudflare) {
        return {
            type: "workerd",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Edge Runtime.
     * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
     */
    const isEdgeRuntime = typeof EdgeRuntime === "string";
    if (isEdgeRuntime) {
        return {
            type: "edge-runtime",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */
    const isWebWorker =
        typeof self === "object" &amp;&amp;
        // @ts-ignore
        typeof self?.importScripts === "function" &amp;&amp;
        (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
            self.constructor?.name === "ServiceWorkerGlobalScope" ||
            self.constructor?.name === "SharedWorkerGlobalScope");
    if (isWebWorker) {
        return {
            type: "web-worker",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Deno.
     * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
     */
    const isDeno =
        typeof Deno !== "undefined" &amp;&amp; typeof Deno.version !== "undefined" &amp;&amp; typeof Deno.version.deno !== "undefined";
    if (isDeno) {
        return {
            type: "deno",
            version: Deno.version.deno,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */
    const isBun = typeof Bun !== "undefined" &amp;&amp; typeof Bun.version !== "undefined";
    if (isBun) {
        return {
            type: "bun",
            version: Bun.version,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Node.JS.
     */
    const isNode =
        typeof process !== "undefined" &amp;&amp;
        "version" in process &amp;&amp;
        !!process.version &amp;&amp;
        "versions" in process &amp;&amp;
        !!process.versions?.node;
    if (isNode) {
        return {
            type: "node",
            version: process.versions.node,
            parsedVersion: Number(process.versions.node.split(".")[0]),
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is in React-Native.
     * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
     */
    const isReactNative = typeof navigator !== "undefined" &amp;&amp; navigator?.product === "ReactNative";
    if (isReactNative) {
        return {
            type: "react-native",
        };
    }

    return {
        type: "unknown",
    };
}
</file>
        </directory>
      </directory>
      <directory name="errors">
        <file name="TerraError.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../core/index.js";
import { toJson } from "../core/json.js";

export class TerraError extends Error {
    public readonly statusCode?: number;
    public readonly body?: unknown;
    public readonly rawResponse?: core.RawResponse;

    constructor({
        message,
        statusCode,
        body,
        rawResponse,
    }: {
        message?: string;
        statusCode?: number;
        body?: unknown;
        rawResponse?: core.RawResponse;
    }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, TerraError.prototype);
        this.statusCode = statusCode;
        this.body = body;
        this.rawResponse = rawResponse;
    }
}

function buildMessage({
    message,
    statusCode,
    body,
}: {
    message: string | undefined;
    statusCode: number | undefined;
    body: unknown | undefined;
}): string {
    let lines: string[] = [];
    if (message != null) {
        lines.push(message);
    }

    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }

    if (body != null) {
        lines.push(`Body: ${toJson(body, undefined, 2)}`);
    }

    return lines.join("\n");
}
</file>
        <file name="TerraTimeoutError.ts">/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class TerraTimeoutError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, TerraTimeoutError.prototype);
    }
}
</file>
        <file name="index.ts">export { TerraError } from "./TerraError.js";
export { TerraTimeoutError } from "./TerraTimeoutError.js";
</file>
      </directory>
      <directory name="wrapper">
        <file name="WebhooksHelper.ts">import { createHmacOverride } from '../core/crypto/createHmacOverride';
import { TerraError } from '../errors';

/**
 * Utility to help with Terra webhook signature verification
 */
export class WebhooksHelper {
    /**
     * Verifies a webhook signature sent by Terra.
     *
     * @param requestBody       The raw JSON string of the request body.
     * @param signatureHeader   The value of the 'x-terra-signature' header.
     * @param signatureKey      Your Terra webhook secret.
     * @returns                 `true` if the signature is valid, indicating that the event can be trusted as it came from Terra.
     *                         `false` if the signature validation fails, indicating that the event did not come from Terra.
     */
    static async verifySignature({
        requestBody,
        signatureHeader,
        signatureKey,
    }: {
        requestBody: string,
        signatureHeader: string,
        signatureKey: string,
    }): Promise&lt;boolean&gt; {
        if (requestBody == null) {
            return false;
        }
        if (signatureKey == null || signatureKey.length == 0) {
            throw new TerraError({
                message: 'signatureKey is null or empty'
            });
        }

        try {
            const hashBase64 = await createHmacOverride(requestBody, signatureKey);
            return hashBase64 === signatureHeader;
        } catch (error) {
            throw new TerraError({
                message: `Failed to validate webhook signature: ${error instanceof Error ? error.message : String(error)}`
            });
        }
    }
}</file>
      </directory>
    </directory>
  </directory>
</root>
